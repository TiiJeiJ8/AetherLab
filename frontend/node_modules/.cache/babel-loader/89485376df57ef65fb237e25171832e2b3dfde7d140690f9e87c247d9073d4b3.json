{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.map.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"ecStat\"] = factory();else root[\"ecStat\"] = factory();\n})(this, function () {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;\n\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/exports: {},\n        /******/id: moduleId,\n        /******/loaded: false\n        /******/\n      };\n\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n      /******/ // Flag the module as loaded\n      /******/\n      module.loaded = true;\n\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"\";\n\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(0);\n    /******/\n  }\n  /************************************************************************/\n  /******/([(/* 0 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      return {\n        clustering: __webpack_require__(1),\n        regression: __webpack_require__(5),\n        statistics: __webpack_require__(6),\n        histogram: __webpack_require__(15),\n        transform: {\n          regression: __webpack_require__(18),\n          histogram: __webpack_require__(21),\n          clustering: __webpack_require__(22)\n        }\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 1 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var dataProcess = __webpack_require__(2);\n      var dataPreprocess = dataProcess.dataPreprocess;\n      var normalizeDimensions = dataProcess.normalizeDimensions;\n      var arrayUtil = __webpack_require__(3);\n      var numberUtil = __webpack_require__(4);\n      var arraySize = arrayUtil.size;\n      var sumOfColumn = arrayUtil.sumOfColumn;\n      var arraySum = arrayUtil.sum;\n      var zeros = arrayUtil.zeros;\n      // var isArray = arrayUtil.isArray;\n      var numberUtil = __webpack_require__(4);\n      var isNumber = numberUtil.isNumber;\n      var mathPow = Math.pow;\n      var OutputType = {\n        /**\n         * Data are all in one. Cluster info are added as an attribute of data.\n         * ```ts\n         * type OutputDataSingle = {\n         *     // Each index of `data` is the index of the input data.\n         *     data: OutputDataItem[];\n         *     // The index of `centroids` is the cluster index.\n         *     centroids: [ValueOnX, ValueOnY][];\n         * };\n         * type InputDataItem = (ValueOnX | ValueOnY | OtherValue)[];\n         * type OutputDataItem = (...InputDataItem | ClusterIndex | SquareDistanceToCentroid)[];\n         * ```\n         */\n        SINGLE: 'single',\n        /**\n         * Data are separated by cluster. Suitable for retrieving data form each cluster.\n         * ```ts\n         * type OutputDataMultiple = {\n         *     // Each index of `clusterAssment` is the index of the input data.\n         *     clusterAssment: [ClusterIndex, SquareDistanceToCentroid][];\n         *     // The index of `centroids` is the cluster index.\n         *     centroids: [ValueOnX, ValueOnY][];\n         *     // The index of `pointsInCluster` is the cluster index.\n         *     pointsInCluster: DataItemListInOneCluster[];\n         * }\n         * type DataItemListInOneCluster = InputDataItem[];\n         * type InputDataItem = (ValueOnX | ValueOnY | OtherValue)[];\n         * type SquareDistanceToCentroid = number;\n         * type ClusterIndex = number;\n         * type ValueOnX = number;\n         * type ValueOnY = number;\n         * type OtherValue = unknown;\n         * ```\n         */\n        MULTIPLE: 'multiple'\n      };\n\n      /**\n       * KMeans of clustering algorithm.\n       * @param {Array.<Array.<number>>} data two-dimension array\n       * @param {number} k the number of clusters in a dataset\n       * @return {Object}\n       */\n      function kMeans(data, k, dataMeta) {\n        // create array to assign data points to centroids, also holds SE of each point\n        var clusterAssigned = zeros(data.length, 2);\n        var centroids = createRandCent(k, calcExtents(data, dataMeta.dimensions));\n        var clusterChanged = true;\n        var minDist;\n        var minIndex;\n        var distIJ;\n        var ptsInClust;\n        while (clusterChanged) {\n          clusterChanged = false;\n          for (var i = 0; i < data.length; i++) {\n            minDist = Infinity;\n            minIndex = -1;\n            for (var j = 0; j < k; j++) {\n              distIJ = distEuclid(data[i], centroids[j], dataMeta);\n              if (distIJ < minDist) {\n                minDist = distIJ;\n                minIndex = j;\n              }\n            }\n            if (clusterAssigned[i][0] !== minIndex) {\n              clusterChanged = true;\n            }\n            clusterAssigned[i][0] = minIndex;\n            clusterAssigned[i][1] = minDist;\n          }\n          //recalculate centroids\n          for (var i = 0; i < k; i++) {\n            ptsInClust = [];\n            for (var j = 0; j < clusterAssigned.length; j++) {\n              if (clusterAssigned[j][0] === i) {\n                ptsInClust.push(data[j]);\n              }\n            }\n            centroids[i] = meanInColumns(ptsInClust, dataMeta);\n          }\n        }\n        var clusterWithKmeans = {\n          centroids: centroids,\n          clusterAssigned: clusterAssigned\n        };\n        return clusterWithKmeans;\n      }\n\n      /**\n       * Calculate the average of each column in a two-dimensional array\n       * and returns the values as an array.\n       */\n      function meanInColumns(dataList, dataMeta) {\n        var meanArray = [];\n        var sum;\n        var mean;\n        for (var j = 0; j < dataMeta.dimensions.length; j++) {\n          var dimIdx = dataMeta.dimensions[j];\n          sum = 0;\n          for (var i = 0; i < dataList.length; i++) {\n            sum += dataList[i][dimIdx];\n          }\n          mean = sum / dataList.length;\n          meanArray.push(mean);\n        }\n        return meanArray;\n      }\n\n      /**\n       * The combine of hierarchical clustering and k-means.\n       * @param {Array} data two-dimension array.\n       * @param {Object|number} [clusterCountOrConfig] config or clusterCountOrConfig.\n       * @param {number} clusterCountOrConfig.clusterCount Mandatory.\n       *        The number of clusters in a dataset. It has to be greater than 1.\n       * @param {boolean} [clusterCountOrConfig.stepByStep=false] Optional.\n       * @param {OutputType} [clusterCountOrConfig.outputType='multiple'] Optional.\n       *        See `OutputType`.\n       * @param {number} [clusterCountOrConfig.outputClusterIndexDimension] Mandatory.\n       *        Only work in `OutputType.SINGLE`.\n       * @param {number} [clusterCountOrConfig.outputCentroidDimensions] Optional.\n       *        If specified, the centroid will be set to those dimensions of the result data one by one.\n       *        By default not set centroid to result.\n       *        Only work in `OutputType.SINGLE`.\n       * @param {Array.<number>} [clusterCountOrConfig.dimensions] Optional.\n       *        Target dimensions to calculate the regression.\n       *        By default: use all of the data.\n       * @return {Array} See `OutputType`.\n       */\n      function hierarchicalKMeans(data, clusterCountOrConfig, stepByStep) {\n        var config = (isNumber(clusterCountOrConfig) ? {\n          clusterCount: clusterCountOrConfig,\n          stepByStep: stepByStep\n        } : clusterCountOrConfig) || {\n          clusterCount: 2\n        };\n        var k = config.clusterCount;\n        if (k < 2) {\n          return;\n        }\n        var dataMeta = parseDataMeta(data, config);\n        var isOutputTypeSingle = dataMeta.outputType === OutputType.SINGLE;\n        var dataSet = dataPreprocess(data, {\n          dimensions: dataMeta.dimensions\n        });\n        var clusterAssment = zeros(dataSet.length, 2);\n        var outputSingleData;\n        var setClusterIndex;\n        var getClusterIndex;\n        function setDistance(dataIndex, dist) {\n          clusterAssment[dataIndex][1] = dist;\n        }\n        function getDistance(dataIndex) {\n          return clusterAssment[dataIndex][1];\n        }\n        ;\n        if (isOutputTypeSingle) {\n          outputSingleData = [];\n          var outputClusterIndexDimension = dataMeta.outputClusterIndexDimension;\n          setClusterIndex = function (dataIndex, clusterIndex) {\n            outputSingleData[dataIndex][outputClusterIndexDimension] = clusterIndex;\n          };\n          getClusterIndex = function (dataIndex) {\n            return outputSingleData[dataIndex][outputClusterIndexDimension];\n          };\n          for (var i = 0; i < dataSet.length; i++) {\n            outputSingleData.push(dataSet[i].slice());\n            setDistance(i, 0);\n            setClusterIndex(i, 0);\n          }\n        } else {\n          setClusterIndex = function (dataIndex, clusterIndex) {\n            clusterAssment[dataIndex][0] = clusterIndex;\n          };\n          getClusterIndex = function (dataIndex) {\n            return clusterAssment[dataIndex][0];\n          };\n        }\n\n        // initial center point.\n        var centroid0 = meanInColumns(dataSet, dataMeta);\n        var centList = [centroid0];\n        for (var i = 0; i < dataSet.length; i++) {\n          var dist = distEuclid(dataSet[i], centroid0, dataMeta);\n          setDistance(i, dist);\n        }\n        var lowestSSE;\n        var ptsInClust;\n        var ptsNotClust;\n        var clusterInfo;\n        var sseSplit;\n        var sseNotSplit;\n        var index = 1;\n        var result = {\n          data: outputSingleData,\n          centroids: centList,\n          isEnd: false\n        };\n        if (!isOutputTypeSingle) {\n          // Only for backward compat.\n          result.clusterAssment = clusterAssment;\n        }\n        function oneStep() {\n          //the existing clusters are continuously divided\n          //until the number of clusters is k\n          if (index < k) {\n            lowestSSE = Infinity;\n            var centSplit;\n            var newCentroid;\n            var newClusterAss;\n            for (var j = 0; j < centList.length; j++) {\n              ptsInClust = [];\n              ptsNotClust = [];\n              for (var i = 0; i < dataSet.length; i++) {\n                if (getClusterIndex(i) === j) {\n                  ptsInClust.push(dataSet[i]);\n                } else {\n                  ptsNotClust.push(getDistance(i));\n                }\n              }\n              clusterInfo = kMeans(ptsInClust, 2, dataMeta);\n              sseSplit = sumOfColumn(clusterInfo.clusterAssigned, 1);\n              sseNotSplit = arraySum(ptsNotClust);\n              if (sseSplit + sseNotSplit < lowestSSE) {\n                lowestSSE = sseNotSplit + sseSplit;\n                centSplit = j;\n                newCentroid = clusterInfo.centroids;\n                newClusterAss = clusterInfo.clusterAssigned;\n              }\n            }\n            for (var i = 0; i < newClusterAss.length; i++) {\n              if (newClusterAss[i][0] === 0) {\n                newClusterAss[i][0] = centSplit;\n              } else if (newClusterAss[i][0] === 1) {\n                newClusterAss[i][0] = centList.length;\n              }\n            }\n            centList[centSplit] = newCentroid[0];\n            centList.push(newCentroid[1]);\n            for (var i = 0, j = 0; i < dataSet.length && j < newClusterAss.length; i++) {\n              if (getClusterIndex(i) === centSplit) {\n                setClusterIndex(i, newClusterAss[j][0]);\n                setDistance(i, newClusterAss[j++][1]);\n              }\n            }\n            var pointInClust = [];\n            if (!isOutputTypeSingle) {\n              for (var i = 0; i < centList.length; i++) {\n                pointInClust[i] = [];\n                for (var j = 0; j < dataSet.length; j++) {\n                  if (getClusterIndex(j) === i) {\n                    pointInClust[i].push(dataSet[j]);\n                  }\n                }\n              }\n              result.pointsInCluster = pointInClust;\n            }\n            index++;\n          } else {\n            result.isEnd = true;\n          }\n        }\n        if (!config.stepByStep) {\n          while (oneStep(), !result.isEnd);\n        } else {\n          result.next = function () {\n            oneStep();\n            setCentroidToResultData(result, dataMeta);\n            return result;\n          };\n        }\n        setCentroidToResultData(result, dataMeta);\n        return result;\n      }\n      function setCentroidToResultData(result, dataMeta) {\n        var outputCentroidDimensions = dataMeta.outputCentroidDimensions;\n        if (dataMeta.outputType !== OutputType.SINGLE || outputCentroidDimensions == null) {\n          return;\n        }\n        var outputSingleData = result.data;\n        var centroids = result.centroids;\n        for (var i = 0; i < outputSingleData.length; i++) {\n          var line = outputSingleData[i];\n          var clusterIndex = line[dataMeta.outputClusterIndexDimension];\n          var centroid = centroids[clusterIndex];\n          var dimLen = Math.min(centroid.length, outputCentroidDimensions.length);\n          for (var j = 0; j < dimLen; j++) {\n            line[outputCentroidDimensions[j]] = centroid[j];\n          }\n        }\n      }\n\n      /**\n       * Create random centroid of kmeans.\n       */\n      function createRandCent(k, extents) {\n        //constructs a two-dimensional array with all values 0\n        var centroids = zeros(k, extents.length);\n        //create random cluster centers, within bounds of each dimension\n        for (var j = 0; j < extents.length; j++) {\n          var extentItem = extents[j];\n          for (var i = 0; i < k; i++) {\n            centroids[i][j] = extentItem.min + extentItem.span * Math.random();\n          }\n        }\n        return centroids;\n      }\n\n      /**\n       * Distance method for calculating similarity\n       */\n      function distEuclid(dataItem, centroid, dataMeta) {\n        // The distance should be normalized between different dimensions,\n        // otherwise they may provide different weight in the final distance.\n        // The greater weight offers more effect in the cluster determination.\n\n        var powerSum = 0;\n        var dimensions = dataMeta.dimensions;\n        var extents = dataMeta.rawExtents;\n        //subtract the corresponding elements in the vectors\n        for (var i = 0; i < dimensions.length; i++) {\n          var span = extents[i].span;\n          // If span is 0, do not count.\n          if (span) {\n            var dimIdx = dimensions[i];\n            var dist = (dataItem[dimIdx] - centroid[i]) / span;\n            powerSum += mathPow(dist, 2);\n          }\n        }\n        return powerSum;\n      }\n      function parseDataMeta(dataSet, config) {\n        var size = arraySize(dataSet);\n        if (size.length < 1) {\n          throw new Error('The input data of clustering should be two-dimension array.');\n        }\n        var colCount = size[1];\n        var defaultDimensions = [];\n        for (var i = 0; i < colCount; i++) {\n          defaultDimensions.push(i);\n        }\n        var dimensions = normalizeDimensions(config.dimensions, defaultDimensions);\n        var outputType = config.outputType || OutputType.MULTIPLE;\n        var outputClusterIndexDimension = config.outputClusterIndexDimension;\n        if (outputType === OutputType.SINGLE && !numberUtil.isNumber(outputClusterIndexDimension)) {\n          throw new Error('outputClusterIndexDimension is required as a number.');\n        }\n        var extents = calcExtents(dataSet, dimensions);\n        return {\n          dimensions: dimensions,\n          rawExtents: extents,\n          outputType: outputType,\n          outputClusterIndexDimension: outputClusterIndexDimension,\n          outputCentroidDimensions: config.outputCentroidDimensions\n        };\n      }\n      function calcExtents(dataSet, dimensions) {\n        var extents = [];\n        var dimLen = dimensions.length;\n        for (var i = 0; i < dimLen; i++) {\n          extents.push({\n            min: Infinity,\n            max: -Infinity\n          });\n        }\n        for (var i = 0; i < dataSet.length; i++) {\n          var line = dataSet[i];\n          for (var j = 0; j < dimLen; j++) {\n            var extentItem = extents[j];\n            var val = line[dimensions[j]];\n            extentItem.min > val && (extentItem.min = val);\n            extentItem.max < val && (extentItem.max = val);\n          }\n        }\n        for (var i = 0; i < dimLen; i++) {\n          extents[i].span = extents[i].max - extents[i].min;\n        }\n        return extents;\n      }\n      return {\n        OutputType: OutputType,\n        hierarchicalKMeans: hierarchicalKMeans\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var array = __webpack_require__(3);\n      var isArray = array.isArray;\n      var size = array.size;\n      var number = __webpack_require__(4);\n      var isNumber = number.isNumber;\n\n      /**\n       * @param  {Array.<number>|number} dimensions like `[2, 4]` or `4`\n       * @param  {Array.<number>} [defaultDimensions=undefined] By default `undefined`.\n       * @return {Array.<number>} number like `4` is normalized to `[4]`,\n       *         `null`/`undefined` is normalized to `defaultDimensions`.\n       */\n      function normalizeDimensions(dimensions, defaultDimensions) {\n        return typeof dimensions === 'number' ? [dimensions] : dimensions == null ? defaultDimensions : dimensions;\n      }\n\n      /**\n       * Data preprocessing, filter the wrong data object.\n       *  for example [12,] --- missing y value\n       *              [,12] --- missing x value\n       *              [12, b] --- incorrect y value\n       *              ['a', 12] --- incorrect x value\n       * @param  {Array.<Array>} data\n       * @param  {Object?} [opt]\n       * @param  {Array.<number>} [opt.dimensions] Optional. Like [2, 4],\n       *         means that dimension index 2 and dimension index 4 need to be number.\n       *         If null/undefined (by default), all dimensions need to be number.\n       * @param  {boolean} [opt.toOneDimensionArray] Convert to one dimension array.\n       *         Each value is from `opt.dimensions[0]` or dimension 0.\n       * @return {Array.<Array.<number>>}\n       */\n      function dataPreprocess(data, opt) {\n        opt = opt || {};\n        var dimensions = opt.dimensions;\n        var numberDimensionMap = {};\n        if (dimensions != null) {\n          for (var i = 0; i < dimensions.length; i++) {\n            numberDimensionMap[dimensions[i]] = true;\n          }\n        }\n        var targetOneDim = opt.toOneDimensionArray ? dimensions ? dimensions[0] : 0 : null;\n        function shouldBeNumberDimension(dimIdx) {\n          return !dimensions || numberDimensionMap.hasOwnProperty(dimIdx);\n        }\n        if (!isArray(data)) {\n          throw new Error('Invalid data type, you should input an array');\n        }\n        var predata = [];\n        var arraySize = size(data);\n        if (arraySize.length === 1) {\n          for (var i = 0; i < arraySize[0]; i++) {\n            var item = data[i];\n            if (isNumber(item)) {\n              predata.push(item);\n            }\n          }\n        } else if (arraySize.length === 2) {\n          for (var i = 0; i < arraySize[0]; i++) {\n            var isCorrect = true;\n            var item = data[i];\n            for (var j = 0; j < arraySize[1]; j++) {\n              if (shouldBeNumberDimension(j) && !isNumber(item[j])) {\n                isCorrect = false;\n              }\n            }\n            if (isCorrect) {\n              predata.push(targetOneDim != null ? item[targetOneDim] : item);\n            }\n          }\n        }\n        return predata;\n      }\n\n      /**\n       * @param {string|number} val\n       * @return {number}\n       */\n      function getPrecision(val) {\n        var str = val.toString();\n        // scientific notation is not considered\n        var dotIndex = str.indexOf('.');\n        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n      }\n      return {\n        normalizeDimensions: normalizeDimensions,\n        dataPreprocess: dataPreprocess,\n        getPrecision: getPrecision\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 3 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var objToString = Object.prototype.toString;\n      var arrayProto = Array.prototype;\n      var nativeMap = arrayProto.map;\n\n      /**\n       * Get the size of a array\n       * @param  {Array} data\n       * @return {Array}\n       */\n      function size(data) {\n        var s = [];\n        while (isArray(data)) {\n          s.push(data.length);\n          data = data[0];\n        }\n        return s;\n      }\n\n      /**\n       * @param {*}  value\n       * @return {boolean}\n       */\n      function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n      }\n\n      /**\n       * constructs a (m x n) array with all values 0\n       * @param  {number} m  the row\n       * @param  {number} n  the column\n       * @return {Array}\n       */\n      function zeros(m, n) {\n        var zeroArray = [];\n        for (var i = 0; i < m; i++) {\n          zeroArray[i] = [];\n          for (var j = 0; j < n; j++) {\n            zeroArray[i][j] = 0;\n          }\n        }\n        return zeroArray;\n      }\n\n      /**\n       * Sums each element in the array.\n       * Internal use, for performance considerations, to avoid\n       * unnecessary judgments and calculations.\n       * @param  {Array} vector\n       * @return {number}\n       */\n      function sum(vector) {\n        var sum = 0;\n        for (var i = 0; i < vector.length; i++) {\n          sum += vector[i];\n        }\n        return sum;\n      }\n\n      /**\n       * Computes the sum of the specified column elements in a two-dimensional array\n       * @param  {Array.<Array>} dataList  two-dimensional array\n       * @param  {number} n  the specified column, zero-based\n       * @return {number}\n       */\n      function sumOfColumn(dataList, n) {\n        var sum = 0;\n        for (var i = 0; i < dataList.length; i++) {\n          sum += dataList[i][n];\n        }\n        return sum;\n      }\n      function ascending(a, b) {\n        return a > b ? 1 : a < b ? -1 : a === b ? 0 : NaN;\n      }\n\n      /**\n       * Binary search algorithm --- this bisector is specidfied to histogram, which every bin like that [a, b),\n       * so the return value use to add 1.\n       * @param  {Array.<number>} array\n       * @param  {number} value\n       * @param  {number} start\n       * @param  {number} end\n       * @return {number}\n       */\n      function bisect(array, value, start, end) {\n        //移出去\n\n        if (start == null) {\n          start = 0;\n        }\n        if (end == null) {\n          end = array.length;\n        }\n        while (start < end) {\n          var mid = Math.floor((start + end) / 2);\n          var compare = ascending(array[mid], value);\n          if (compare > 0) {\n            end = mid;\n          } else if (compare < 0) {\n            start = mid + 1;\n          } else {\n            return mid + 1;\n          }\n        }\n        return start;\n      }\n\n      /**\n       * 数组映射\n       * @memberOf module:zrender/core/util\n       * @param {Array} obj\n       * @param {Function} cb\n       * @param {*} [context]\n       * @return {Array}\n       */\n      function map(obj, cb, context) {\n        if (!(obj && cb)) {\n          return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n          return obj.map(cb, context);\n        } else {\n          var result = [];\n          for (var i = 0, len = obj.length; i < len; i++) {\n            result.push(cb.call(context, obj[i], i, obj));\n          }\n          return result;\n        }\n      }\n      return {\n        size: size,\n        isArray: isArray,\n        zeros: zeros,\n        sum: sum,\n        sumOfColumn: sumOfColumn,\n        ascending: ascending,\n        bisect: bisect,\n        map: map\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 4 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      /**\n       * Test whether value is a number.\n       * @param  {*}  value\n       * @return {boolean}\n       */\n      function isNumber(value) {\n        value = value === null ? NaN : +value;\n        return typeof value === 'number' && !isNaN(value);\n      }\n\n      /**\n       * Test if a number is integer.\n       * @param  {number}  value\n       * @return {boolean}\n       */\n      function isInteger(value) {\n        return isFinite(value) && value === Math.round(value);\n      }\n      function quantityExponent(val) {\n        if (val === 0) {\n          return 0;\n        }\n        var exp = Math.floor(Math.log(val) / Math.LN10);\n        // Fix pricision loss.\n        if (val / Math.pow(10, exp) >= 10) {\n          exp++;\n        }\n        return exp;\n      }\n      return {\n        isNumber: isNumber,\n        isInteger: isInteger,\n        quantityExponent: quantityExponent\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 5 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var dataProcess = __webpack_require__(2);\n      var dataPreprocess = dataProcess.dataPreprocess;\n      var normalizeDimensions = dataProcess.normalizeDimensions;\n      var regreMethods = {\n        /**\n         * Common linear regression algorithm\n         */\n        linear: function (predata, opt) {\n          var xDimIdx = opt.dimensions[0];\n          var yDimIdx = opt.dimensions[1];\n          var sumX = 0;\n          var sumY = 0;\n          var sumXY = 0;\n          var sumXX = 0;\n          var len = predata.length;\n          for (var i = 0; i < len; i++) {\n            var rawItem = predata[i];\n            sumX += rawItem[xDimIdx];\n            sumY += rawItem[yDimIdx];\n            sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n            sumXX += rawItem[xDimIdx] * rawItem[xDimIdx];\n          }\n          var gradient = (len * sumXY - sumX * sumY) / (len * sumXX - sumX * sumX);\n          var intercept = sumY / len - gradient * sumX / len;\n          var result = [];\n          for (var j = 0; j < predata.length; j++) {\n            var rawItem = predata[j];\n            var resultItem = rawItem.slice();\n            resultItem[xDimIdx] = rawItem[xDimIdx];\n            resultItem[yDimIdx] = gradient * rawItem[xDimIdx] + intercept;\n            result.push(resultItem);\n          }\n          var expression = 'y = ' + Math.round(gradient * 100) / 100 + 'x + ' + Math.round(intercept * 100) / 100;\n          return {\n            points: result,\n            parameter: {\n              gradient: gradient,\n              intercept: intercept\n            },\n            expression: expression\n          };\n        },\n        /**\n         * If the raw data include [0,0] point, we should choose linearThroughOrigin\n         *   instead of linear.\n         */\n        linearThroughOrigin: function (predata, opt) {\n          var xDimIdx = opt.dimensions[0];\n          var yDimIdx = opt.dimensions[1];\n          var sumXX = 0;\n          var sumXY = 0;\n          for (var i = 0; i < predata.length; i++) {\n            var rawItem = predata[i];\n            sumXX += rawItem[xDimIdx] * rawItem[xDimIdx];\n            sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n          }\n          var gradient = sumXY / sumXX;\n          var result = [];\n          for (var j = 0; j < predata.length; j++) {\n            var rawItem = predata[j];\n            var resultItem = rawItem.slice();\n            resultItem[xDimIdx] = rawItem[xDimIdx];\n            resultItem[yDimIdx] = rawItem[xDimIdx] * gradient;\n            result.push(resultItem);\n          }\n          var expression = 'y = ' + Math.round(gradient * 100) / 100 + 'x';\n          return {\n            points: result,\n            parameter: {\n              gradient: gradient\n            },\n            expression: expression\n          };\n        },\n        /**\n         * Exponential regression\n         */\n        exponential: function (predata, opt) {\n          var xDimIdx = opt.dimensions[0];\n          var yDimIdx = opt.dimensions[1];\n          var sumX = 0;\n          var sumY = 0;\n          var sumXXY = 0;\n          var sumYlny = 0;\n          var sumXYlny = 0;\n          var sumXY = 0;\n          for (var i = 0; i < predata.length; i++) {\n            var rawItem = predata[i];\n            sumX += rawItem[xDimIdx];\n            sumY += rawItem[yDimIdx];\n            sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n            sumXXY += rawItem[xDimIdx] * rawItem[xDimIdx] * rawItem[yDimIdx];\n            sumYlny += rawItem[yDimIdx] * Math.log(rawItem[yDimIdx]);\n            sumXYlny += rawItem[xDimIdx] * rawItem[yDimIdx] * Math.log(rawItem[yDimIdx]);\n          }\n          var denominator = sumY * sumXXY - sumXY * sumXY;\n          var coefficient = Math.pow(Math.E, (sumXXY * sumYlny - sumXY * sumXYlny) / denominator);\n          var index = (sumY * sumXYlny - sumXY * sumYlny) / denominator;\n          var result = [];\n          for (var j = 0; j < predata.length; j++) {\n            var rawItem = predata[j];\n            var resultItem = rawItem.slice();\n            resultItem[xDimIdx] = rawItem[xDimIdx];\n            resultItem[yDimIdx] = coefficient * Math.pow(Math.E, index * rawItem[xDimIdx]);\n            result.push(resultItem);\n          }\n          var expression = 'y = ' + Math.round(coefficient * 100) / 100 + 'e^(' + Math.round(index * 100) / 100 + 'x)';\n          return {\n            points: result,\n            parameter: {\n              coefficient: coefficient,\n              index: index\n            },\n            expression: expression\n          };\n        },\n        /**\n         * Logarithmic regression\n         */\n        logarithmic: function (predata, opt) {\n          var xDimIdx = opt.dimensions[0];\n          var yDimIdx = opt.dimensions[1];\n          var sumlnx = 0;\n          var sumYlnx = 0;\n          var sumY = 0;\n          var sumlnxlnx = 0;\n          for (var i = 0; i < predata.length; i++) {\n            var rawItem = predata[i];\n            sumlnx += Math.log(rawItem[xDimIdx]);\n            sumYlnx += rawItem[yDimIdx] * Math.log(rawItem[xDimIdx]);\n            sumY += rawItem[yDimIdx];\n            sumlnxlnx += Math.pow(Math.log(rawItem[xDimIdx]), 2);\n          }\n          var gradient = (i * sumYlnx - sumY * sumlnx) / (i * sumlnxlnx - sumlnx * sumlnx);\n          var intercept = (sumY - gradient * sumlnx) / i;\n          var result = [];\n          for (var j = 0; j < predata.length; j++) {\n            var rawItem = predata[j];\n            var resultItem = rawItem.slice();\n            resultItem[xDimIdx] = rawItem[xDimIdx];\n            resultItem[yDimIdx] = gradient * Math.log(rawItem[xDimIdx]) + intercept;\n            result.push(resultItem);\n          }\n          var expression = 'y = ' + Math.round(intercept * 100) / 100 + ' + ' + Math.round(gradient * 100) / 100 + 'ln(x)';\n          return {\n            points: result,\n            parameter: {\n              gradient: gradient,\n              intercept: intercept\n            },\n            expression: expression\n          };\n        },\n        /**\n         * Polynomial regression\n         */\n        polynomial: function (predata, opt) {\n          var xDimIdx = opt.dimensions[0];\n          var yDimIdx = opt.dimensions[1];\n          var order = opt.order;\n          if (order == null) {\n            order = 2;\n          }\n          //coefficient matrix\n          var coeMatrix = [];\n          var lhs = [];\n          var k = order + 1;\n          for (var i = 0; i < k; i++) {\n            var sumA = 0;\n            for (var n = 0; n < predata.length; n++) {\n              var rawItem = predata[n];\n              sumA += rawItem[yDimIdx] * Math.pow(rawItem[xDimIdx], i);\n            }\n            lhs.push(sumA);\n            var temp = [];\n            for (var j = 0; j < k; j++) {\n              var sumB = 0;\n              for (var m = 0; m < predata.length; m++) {\n                sumB += Math.pow(predata[m][xDimIdx], i + j);\n              }\n              temp.push(sumB);\n            }\n            coeMatrix.push(temp);\n          }\n          coeMatrix.push(lhs);\n          var coeArray = gaussianElimination(coeMatrix, k);\n          var result = [];\n          for (var i = 0; i < predata.length; i++) {\n            var value = 0;\n            var rawItem = predata[i];\n            for (var n = 0; n < coeArray.length; n++) {\n              value += coeArray[n] * Math.pow(rawItem[xDimIdx], n);\n            }\n            var resultItem = rawItem.slice();\n            resultItem[xDimIdx] = rawItem[xDimIdx];\n            resultItem[yDimIdx] = value;\n            result.push(resultItem);\n          }\n          var expression = 'y = ';\n          for (var i = coeArray.length - 1; i >= 0; i--) {\n            if (i > 1) {\n              expression += Math.round(coeArray[i] * Math.pow(10, i + 1)) / Math.pow(10, i + 1) + 'x^' + i + ' + ';\n            } else if (i === 1) {\n              expression += Math.round(coeArray[i] * 100) / 100 + 'x' + ' + ';\n            } else {\n              expression += Math.round(coeArray[i] * 100) / 100;\n            }\n          }\n          return {\n            points: result,\n            parameter: coeArray,\n            expression: expression\n          };\n        }\n      };\n\n      /**\n       * Gaussian elimination\n       * @param  {Array.<Array.<number>>} matrix   two-dimensional number array\n       * @param  {number} number\n       * @return {Array}\n       */\n      function gaussianElimination(matrix, number) {\n        for (var i = 0; i < matrix.length - 1; i++) {\n          var maxColumn = i;\n          for (var j = i + 1; j < matrix.length - 1; j++) {\n            if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxColumn])) {\n              maxColumn = j;\n            }\n          }\n          // the matrix here is the transpose of the common Augmented matrix.\n          //  so the can perform the primary column transform, in fact, equivalent\n          //  to the primary line changes\n          for (var k = i; k < matrix.length; k++) {\n            var temp = matrix[k][i];\n            matrix[k][i] = matrix[k][maxColumn];\n            matrix[k][maxColumn] = temp;\n          }\n          for (var n = i + 1; n < matrix.length - 1; n++) {\n            for (var m = matrix.length - 1; m >= i; m--) {\n              matrix[m][n] -= matrix[m][i] / matrix[i][i] * matrix[i][n];\n            }\n          }\n        }\n        var data = new Array(number);\n        var len = matrix.length - 1;\n        for (var j = matrix.length - 2; j >= 0; j--) {\n          var temp = 0;\n          for (var i = j + 1; i < matrix.length - 1; i++) {\n            temp += matrix[i][j] * data[i];\n          }\n          data[j] = (matrix[len][j] - temp) / matrix[j][j];\n        }\n        return data;\n      }\n\n      /**\n       * @param  {string} regreMethod\n       * @param  {Array.<Array.<number>>} data   two-dimensional number array\n       * @param  {Object|number} [optOrOrder]  opt or order\n       * @param  {number} [optOrOrder.order]  order of polynomials\n       * @param  {Array.<number>|number} [optOrOrder.dimensions=[0, 1]]  Target dimensions to calculate the regression.\n       *         By defualt: use [0, 1] as [x, y].\n       * @return {Array}\n       */\n      var regression = function (regreMethod, data, optOrOrder) {\n        var opt = typeof optOrOrder === 'number' ? {\n          order: optOrOrder\n        } : optOrOrder || {};\n        var dimensions = normalizeDimensions(opt.dimensions, [0, 1]);\n        var predata = dataPreprocess(data, {\n          dimensions: dimensions\n        });\n        var result = regreMethods[regreMethod](predata, {\n          order: opt.order,\n          dimensions: dimensions\n        });\n\n        // Sort for line chart.\n        var xDimIdx = dimensions[0];\n        result.points.sort(function (itemA, itemB) {\n          return itemA[xDimIdx] - itemB[xDimIdx];\n        });\n        return result;\n      };\n      return regression;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 6 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var statistics = {};\n      statistics.max = __webpack_require__(7);\n      statistics.deviation = __webpack_require__(8);\n      statistics.mean = __webpack_require__(10);\n      statistics.median = __webpack_require__(12);\n      statistics.min = __webpack_require__(14);\n      statistics.quantile = __webpack_require__(13);\n      statistics.sampleVariance = __webpack_require__(9);\n      statistics.sum = __webpack_require__(11);\n      return statistics;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 7 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var number = __webpack_require__(4);\n      var isNumber = number.isNumber;\n\n      /**\n       * Is a method for computing the max value of a list of numbers,\n       * which will filter other data types.\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function max(data) {\n        var maxData = -Infinity;\n        for (var i = 0; i < data.length; i++) {\n          if (isNumber(data[i]) && data[i] > maxData) {\n            maxData = data[i];\n          }\n        }\n        return maxData;\n      }\n      return max;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 8 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var variance = __webpack_require__(9);\n\n      /**\n       * Computing the deviation\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      return function (data) {\n        var squaredDeviation = variance(data);\n        return squaredDeviation ? Math.sqrt(squaredDeviation) : squaredDeviation;\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 9 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var number = __webpack_require__(4);\n      var isNumber = number.isNumber;\n      var mean = __webpack_require__(10);\n\n      /**\n       * Computing the variance of list of sample\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function sampleVariance(data) {\n        var len = data.length;\n        if (!len || len < 2) {\n          return 0;\n        }\n        if (data.length >= 2) {\n          var meanValue = mean(data);\n          var sum = 0;\n          var temple;\n          for (var i = 0; i < data.length; i++) {\n            if (isNumber(data[i])) {\n              temple = data[i] - meanValue;\n              sum += temple * temple;\n            }\n          }\n          return sum / (data.length - 1);\n        }\n      }\n      return sampleVariance;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 10 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var sum = __webpack_require__(11);\n\n      /**\n       * Is a method for computing the mean value of a list of numbers,\n       * which will filter other data types.\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function mean(data) {\n        var len = data.length;\n        if (!len) {\n          return 0;\n        }\n        return sum(data) / data.length;\n      }\n      return mean;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 11 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var number = __webpack_require__(4);\n      var isNumber = number.isNumber;\n\n      /**\n       * Is a method for computing the sum of a list of numbers,\n       * which will filter other data types.\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function sum(data) {\n        var len = data.length;\n        if (!len) {\n          return 0;\n        }\n        var sumData = 0;\n        for (var i = 0; i < len; i++) {\n          if (isNumber(data[i])) {\n            sumData += data[i];\n          }\n        }\n        return sumData;\n      }\n      return sum;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 12 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var quantile = __webpack_require__(13);\n\n      /**\n       * Is a method for computing the median value of a sorted array of numbers\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function median(data) {\n        return quantile(data, 0.5);\n      }\n      return median;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 13 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      /**\n       * Estimating quantiles from a sorted sample of numbers\n       * @see https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample\n       * R-7 method\n       * @param  {Array.<number>} data  sorted array\n       * @param  {number} p\n       */\n      return function (data, p) {\n        var len = data.length;\n        if (!len) {\n          return 0;\n        }\n        if (p <= 0 || len < 2) {\n          return data[0];\n        }\n        if (p >= 1) {\n          return data[len - 1];\n        }\n        // in the wikipedia's R-7 method h = (N - 1)p + 1, but here array index start from 0\n        var h = (len - 1) * p;\n        var i = Math.floor(h);\n        var a = data[i];\n        var b = data[i + 1];\n        return a + (b - a) * (h - i);\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 14 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var number = __webpack_require__(4);\n      var isNumber = number.isNumber;\n\n      /**\n       * Is a method for computing the min value of a list of numbers,\n       * which will filter other data types.\n       * @param  {Array.<number>} data\n       * @return {number}\n       */\n      function min(data) {\n        var minData = Infinity;\n        for (var i = 0; i < data.length; i++) {\n          if (isNumber(data[i]) && data[i] < minData) {\n            minData = data[i];\n          }\n        }\n        return minData;\n      }\n      return min;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 15 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var max = __webpack_require__(7);\n      var min = __webpack_require__(14);\n      var quantile = __webpack_require__(13);\n      var deviation = __webpack_require__(8);\n      var dataProcess = __webpack_require__(2);\n      var dataPreprocess = dataProcess.dataPreprocess;\n      var normalizeDimensions = dataProcess.normalizeDimensions;\n      var array = __webpack_require__(3);\n      var ascending = array.ascending;\n      var map = array.map;\n      var range = __webpack_require__(16);\n      var bisect = array.bisect;\n      var tickStep = __webpack_require__(17);\n\n      /**\n       * Compute bins for histogram\n       * @param  {Array.<number>} data\n       * @param  {Object|string} optOrMethod Optional settings or `method`.\n       * @param  {Object|string} optOrMethod.method 'squareRoot' | 'scott' | 'freedmanDiaconis' | 'sturges'\n       * @param  {Array.<number>|number} optOrMethod.dimensions If data is a 2-d array,\n       *         which dimension will be used to calculate histogram.\n       * @return {Object}\n       */\n      function computeBins(data, optOrMethod) {\n        var opt = typeof optOrMethod === 'string' ? {\n          method: optOrMethod\n        } : optOrMethod || {};\n        var threshold = opt.method == null ? thresholdMethod.squareRoot : thresholdMethod[opt.method];\n        var dimensions = normalizeDimensions(opt.dimensions);\n        var values = dataPreprocess(data, {\n          dimensions: dimensions,\n          toOneDimensionArray: true\n        });\n        var maxValue = max(values);\n        var minValue = min(values);\n        var binsNumber = threshold(values, minValue, maxValue);\n        var tickStepResult = tickStep(minValue, maxValue, binsNumber);\n        var step = tickStepResult.step;\n        var toFixedPrecision = tickStepResult.toFixedPrecision;\n\n        // return the xAxis coordinate for each bins, except the end point of the value\n        var rangeArray = range(\n        // use function toFixed() to avoid data like '0.700000001'\n        +(Math.ceil(minValue / step) * step).toFixed(toFixedPrecision), +(Math.floor(maxValue / step) * step).toFixed(toFixedPrecision), step, toFixedPrecision);\n        var len = rangeArray.length;\n        var bins = new Array(len + 1);\n        for (var i = 0; i <= len; i++) {\n          bins[i] = {};\n          bins[i].sample = [];\n          bins[i].x0 = i > 0 ? rangeArray[i - 1] : rangeArray[i] - minValue === step ? minValue : rangeArray[i] - step;\n          bins[i].x1 = i < len ? rangeArray[i] : maxValue - rangeArray[i - 1] === step ? maxValue : rangeArray[i - 1] + step;\n        }\n        for (var i = 0; i < values.length; i++) {\n          if (minValue <= values[i] && values[i] <= maxValue) {\n            bins[bisect(rangeArray, values[i], 0, len)].sample.push(values[i]);\n          }\n        }\n        var data = map(bins, function (bin) {\n          // use function toFixed() to avoid data like '6.5666638489'\n          return [+((bin.x0 + bin.x1) / 2).toFixed(toFixedPrecision), bin.sample.length, bin.x0, bin.x1, bin.x0 + ' - ' + bin.x1];\n        });\n        var customData = map(bins, function (bin) {\n          return [bin.x0, bin.x1, bin.sample.length];\n        });\n        return {\n          bins: bins,\n          data: data,\n          customData: customData\n        };\n      }\n\n      /**\n       * Four kinds of threshold methods used to\n       * compute how much bins the histogram should be divided\n       * @see  https://en.wikipedia.org/wiki/Histogram\n       * @type {Object}\n       */\n      var thresholdMethod = {\n        squareRoot: function (data) {\n          var bins = Math.ceil(Math.sqrt(data.length));\n          return bins > 50 ? 50 : bins;\n        },\n        scott: function (data, min, max) {\n          return Math.ceil((max - min) / (3.5 * deviation(data) * Math.pow(data.length, -1 / 3)));\n        },\n        freedmanDiaconis: function (data, min, max) {\n          data.sort(ascending);\n          return Math.ceil((max - min) / (2 * (quantile(data, 0.75) - quantile(data, 0.25)) * Math.pow(data.length, -1 / 3)));\n        },\n        sturges: function (data) {\n          return Math.ceil(Math.log(data.length) / Math.LN2) + 1;\n        }\n      };\n      return computeBins;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 16 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var dataProcess = __webpack_require__(2);\n      var getPrecision = dataProcess.getPrecision;\n\n      /**\n       * Computing range array.\n       * Adding param precision to fix range value, avoiding range[i] = 0.7000000001.\n       * @param  {number} start\n       * @param  {number} end\n       * @param  {number} step\n       * @param  {number} precision\n       * @return {Array.<number>}\n       */\n      return function (start, end, step, precision) {\n        var len = arguments.length;\n        if (len < 2) {\n          end = start;\n          start = 0;\n          step = 1;\n        } else if (len < 3) {\n          step = 1;\n        } else if (len < 4) {\n          step = +step;\n          precision = getPrecision(step);\n        } else {\n          precision = +precision;\n        }\n        var n = Math.ceil(((end - start) / step).toFixed(precision));\n        var range = new Array(n + 1);\n        for (var i = 0; i < n + 1; i++) {\n          range[i] = +(start + i * step).toFixed(precision);\n        }\n        return range;\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 17 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var numberUtil = __webpack_require__(4);\n\n      /**\n       * Computing the length of step\n       * @see  https://github.com/d3/d3-array/blob/master/src/ticks.js\n       * @param {number} start\n       * @param {number} stop\n       * @param {number} count\n       */\n      return function (start, stop, count) {\n        var step0 = Math.abs(stop - start) / count;\n        var precision = numberUtil.quantityExponent(step0);\n        var step1 = Math.pow(10, precision);\n        var error = step0 / step1;\n        if (error >= Math.sqrt(50)) {\n          step1 *= 10;\n        } else if (error >= Math.sqrt(10)) {\n          step1 *= 5;\n        } else if (error >= Math.sqrt(2)) {\n          step1 *= 2;\n        }\n        var toFixedPrecision = precision < 0 ? -precision : 0;\n        var resultStep = +(stop >= start ? step1 : -step1).toFixed(toFixedPrecision);\n        return {\n          step: resultStep,\n          toFixedPrecision: toFixedPrecision\n        };\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 18 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var regression = __webpack_require__(5);\n      var transformHelper = __webpack_require__(19);\n      var FORMULA_DIMENSION = 2;\n      return {\n        type: 'ecStat:regression',\n        /**\n         * @param {Paramter<typeof regression>[0]} [params.config.method='linear'] 'linear' by default\n         * @param {Paramter<typeof regression>[2]} [params.config.order=2] Only work when method is `polynomial`.\n         * @param {DimensionLoose[]|DimensionLoose} [params.config.dimensions=[0, 1]] dimensions that used to calculate regression.\n         *        By default [0, 1].\n         * @param {'start' | 'end' | 'all'} params.config.formulaOn Include formula on the last (third) dimension of the:\n         *        'start': first data item.\n         *        'end': last data item (by default).\n         *        'all': all data items.\n         *        'none': no data item.\n         */\n        transform: function transform(params) {\n          var upstream = params.upstream;\n          var config = params.config || {};\n          var method = config.method || 'linear';\n          var result = regression(method, upstream.cloneRawData(), {\n            order: config.order,\n            dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions)\n          });\n          var points = result.points;\n          var formulaOn = config.formulaOn;\n          if (formulaOn == null) {\n            formulaOn = 'end';\n          }\n          var dimensions;\n          if (formulaOn !== 'none') {\n            for (var i = 0; i < points.length; i++) {\n              points[i][FORMULA_DIMENSION] = formulaOn === 'start' && i === 0 || formulaOn === 'all' || formulaOn === 'end' && i === points.length - 1 ? result.expression : '';\n            }\n            dimensions = upstream.cloneAllDimensionInfo();\n            dimensions[FORMULA_DIMENSION] = {};\n          }\n          return [{\n            dimensions: dimensions,\n            data: points\n          }];\n        }\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 19 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var arrayUtil = __webpack_require__(3);\n      var numberUtil = __webpack_require__(4);\n      var objectUtil = __webpack_require__(20);\n\n      /**\n       * type DimensionLoose = DimensionIndex | DimensionName;\n       * type DimensionIndex = number;\n       * type DimensionName = string;\n       *\n       * @param {object} transformParams The parameter of echarts transfrom.\n       * @param {DimensionLoose | DimensionLoose[]} dimensionsConfig\n       * @return {DimensionIndex | DimensionIndex[]}\n       */\n      function normalizeExistingDimensions(transformParams, dimensionsConfig) {\n        if (dimensionsConfig == null) {\n          return;\n        }\n        var upstream = transformParams.upstream;\n        if (arrayUtil.isArray(dimensionsConfig)) {\n          var result = [];\n          for (var i = 0; i < dimensionsConfig.length; i++) {\n            var dimInfo = upstream.getDimensionInfo(dimensionsConfig[i]);\n            validateDimensionExists(dimInfo, dimensionsConfig[i]);\n            result[i] = dimInfo.index;\n          }\n          return result;\n        } else {\n          var dimInfo = upstream.getDimensionInfo(dimensionsConfig);\n          validateDimensionExists(dimInfo, dimensionsConfig);\n          return dimInfo.index;\n        }\n        function validateDimensionExists(dimInfo, dimConfig) {\n          if (!dimInfo) {\n            throw new Error('Can not find dimension by ' + dimConfig);\n          }\n        }\n      }\n\n      /**\n       * @param {object} transformParams The parameter of echarts transfrom.\n       * @param {(DimensionIndex | {name: DimensionName, index: DimensionIndex})[]} dimensionsConfig\n       * @param {{name: DimensionName | DimensionName[], index: DimensionIndex | DimensionIndex[]}}\n       */\n      function normalizeNewDimensions(dimensionsConfig) {\n        if (arrayUtil.isArray(dimensionsConfig)) {\n          var names = [];\n          var indices = [];\n          for (var i = 0; i < dimensionsConfig.length; i++) {\n            var item = parseDimensionNewItem(dimensionsConfig[i]);\n            names.push(item.name);\n            indices.push(item.index);\n          }\n          return {\n            name: names,\n            index: indices\n          };\n        } else if (dimensionsConfig != null) {\n          return parseDimensionNewItem(dimensionsConfig);\n        }\n        function parseDimensionNewItem(dimConfig) {\n          if (numberUtil.isNumber(dimConfig)) {\n            return {\n              index: dimConfig\n            };\n          } else if (objectUtil.isObject(dimConfig) && numberUtil.isNumber(dimConfig.index)) {\n            return dimConfig;\n          }\n          throw new Error('Illegle new dimensions config. Expect `{ name: string, index: number }`.');\n        }\n      }\n      return {\n        normalizeExistingDimensions: normalizeExistingDimensions,\n        normalizeNewDimensions: normalizeNewDimensions\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 20 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      function extend(target, source) {\n        if (Object.assign) {\n          Object.assign(target, source);\n        } else {\n          for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      }\n      function isObject(value) {\n        const type = typeof value;\n        return type === 'function' || !!value && type === 'object';\n      }\n      return {\n        extend: extend,\n        isObject: isObject\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 21 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var histogram = __webpack_require__(15);\n      var transformHelper = __webpack_require__(19);\n      return {\n        type: 'ecStat:histogram',\n        /**\n         * @param {'squareRoot' | 'scott' | 'freedmanDiaconis' | 'sturges'} [params.config.method='squareRoot']\n         * @param {DimnensionLoose[]} [params.config.dimensions=[0, 1]] dimensions that used to calculate histogram.\n         *        By default [0].\n         */\n        transform: function transform(params) {\n          var upstream = params.upstream;\n          var config = params.config || {};\n          var result = histogram(upstream.cloneRawData(), {\n            method: config.method,\n            dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions)\n          });\n          return [{\n            dimensions: ['MeanOfV0V1', 'VCount', 'V0', 'V1', 'DisplayableName'],\n            data: result.data\n          }, {\n            data: result.customData\n          }];\n        }\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }), (/* 22 */\n  /***/function (module, exports, __webpack_require__) {\n    var __WEBPACK_AMD_DEFINE_RESULT__;\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n      var clustering = __webpack_require__(1);\n      var numberUtil = __webpack_require__(4);\n      var transformHelper = __webpack_require__(19);\n      var isNumber = numberUtil.isNumber;\n      return {\n        type: 'ecStat:clustering',\n        /**\n         * @param {number} params.config.clusterCount Mandatory.\n         *        The number of clusters in a dataset. It has to be greater than 1.\n         * @param {(DimensionName | DimensionIndex)[]} [params.config.dimensions] Optional.\n         *        Target dimensions to calculate the regression.\n         *        By default: use all of the data.\n         * @param {(DimensionIndex | {name?: DimensionName, index: DimensionIndex})} [params.config.outputClusterIndexDimension] Mandatory.\n         * @param {(DimensionIndex | {name?: DimensionName, index: DimensionIndex})[]} [params.config.outputCentroidDimensions] Optional.\n         *        If specified, the centroid will be set to those dimensions of the result data one by one.\n         *        By default not set centroid to result.\n         */\n        transform: function transform(params) {\n          var upstream = params.upstream;\n          var config = params.config || {};\n          var clusterCount = config.clusterCount;\n          if (!isNumber(clusterCount) || clusterCount <= 0) {\n            throw new Error('config param \"clusterCount\" need to be specified as an interger greater than 1.');\n          }\n          if (clusterCount === 1) {\n            return [{}, {\n              data: []\n            }];\n          }\n          var outputClusterIndexDimension = transformHelper.normalizeNewDimensions(config.outputClusterIndexDimension);\n          var outputCentroidDimensions = transformHelper.normalizeNewDimensions(config.outputCentroidDimensions);\n          if (outputClusterIndexDimension == null) {\n            throw new Error('outputClusterIndexDimension is required as a number.');\n          }\n          var result = clustering.hierarchicalKMeans(upstream.cloneRawData(), {\n            clusterCount: clusterCount,\n            stepByStep: false,\n            dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions),\n            outputType: clustering.OutputType.SINGLE,\n            outputClusterIndexDimension: outputClusterIndexDimension.index,\n            outputCentroidDimensions: (outputCentroidDimensions || {}).index\n          });\n          var sourceDimAll = upstream.cloneAllDimensionInfo();\n          var resultDimsDef = [];\n          for (var i = 0; i < sourceDimAll.length; i++) {\n            var sourceDimItem = sourceDimAll[i];\n            resultDimsDef.push(sourceDimItem.name);\n          }\n\n          // Always set to dims def even if name not exists, because the resultDimsDef.length\n          // need to be enlarged to tell echarts that there is \"cluster index dimension\" and \"dist dimension\".\n          resultDimsDef[outputClusterIndexDimension.index] = outputClusterIndexDimension.name;\n          if (outputCentroidDimensions) {\n            for (var i = 0; i < outputCentroidDimensions.index.length; i++) {\n              if (outputCentroidDimensions.name[i] != null) {\n                resultDimsDef[outputCentroidDimensions.index[i]] = outputCentroidDimensions.name[i];\n              }\n            }\n          }\n          return [{\n            dimensions: resultDimsDef,\n            data: result.data\n          }, {\n            data: result.centroids\n          }];\n        }\n      };\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /***/\n  }\n  /******/)]);\n});\n;","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","installedModules","__webpack_require__","moduleId","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","require","clustering","regression","statistics","histogram","transform","undefined","dataProcess","dataPreprocess","normalizeDimensions","arrayUtil","numberUtil","arraySize","size","sumOfColumn","arraySum","sum","zeros","isNumber","mathPow","Math","pow","OutputType","SINGLE","MULTIPLE","kMeans","data","k","dataMeta","clusterAssigned","length","centroids","createRandCent","calcExtents","dimensions","clusterChanged","minDist","minIndex","distIJ","ptsInClust","i","Infinity","j","distEuclid","push","meanInColumns","clusterWithKmeans","dataList","meanArray","mean","dimIdx","hierarchicalKMeans","clusterCountOrConfig","stepByStep","config","clusterCount","parseDataMeta","isOutputTypeSingle","outputType","dataSet","clusterAssment","outputSingleData","setClusterIndex","getClusterIndex","setDistance","dataIndex","dist","getDistance","outputClusterIndexDimension","clusterIndex","slice","centroid0","centList","lowestSSE","ptsNotClust","clusterInfo","sseSplit","sseNotSplit","index","result","isEnd","oneStep","centSplit","newCentroid","newClusterAss","pointInClust","pointsInCluster","next","setCentroidToResultData","outputCentroidDimensions","line","centroid","dimLen","min","extents","extentItem","span","random","dataItem","powerSum","rawExtents","Error","colCount","defaultDimensions","max","val","array","isArray","number","opt","numberDimensionMap","targetOneDim","toOneDimensionArray","shouldBeNumberDimension","hasOwnProperty","predata","item","isCorrect","getPrecision","str","toString","dotIndex","indexOf","objToString","Object","prototype","arrayProto","Array","nativeMap","map","s","value","n","zeroArray","vector","ascending","a","b","NaN","bisect","start","end","mid","floor","compare","obj","cb","context","len","isNaN","isInteger","isFinite","round","quantityExponent","exp","log","LN10","regreMethods","linear","xDimIdx","yDimIdx","sumX","sumY","sumXY","sumXX","rawItem","gradient","intercept","resultItem","expression","points","parameter","linearThroughOrigin","exponential","sumXXY","sumYlny","sumXYlny","denominator","coefficient","E","logarithmic","sumlnx","sumYlnx","sumlnxlnx","polynomial","order","coeMatrix","lhs","sumA","temp","sumB","coeArray","gaussianElimination","matrix","maxColumn","abs","regreMethod","optOrOrder","sort","itemA","itemB","deviation","median","quantile","sampleVariance","maxData","variance","squaredDeviation","sqrt","meanValue","temple","sumData","h","minData","range","tickStep","computeBins","optOrMethod","method","threshold","thresholdMethod","squareRoot","values","maxValue","minValue","binsNumber","tickStepResult","step","toFixedPrecision","rangeArray","ceil","toFixed","bins","sample","x0","x1","bin","customData","scott","freedmanDiaconis","sturges","LN2","precision","arguments","stop","count","step0","step1","error","resultStep","transformHelper","FORMULA_DIMENSION","type","params","upstream","cloneRawData","normalizeExistingDimensions","formulaOn","cloneAllDimensionInfo","objectUtil","transformParams","dimensionsConfig","dimInfo","getDimensionInfo","validateDimensionExists","dimConfig","normalizeNewDimensions","names","indices","parseDimensionNewItem","name","isObject","extend","target","source","assign","key","sourceDimAll","resultDimsDef","sourceDimItem"],"sources":["D:/Learning Material/Git/Fuck-Charts/node_modules/echarts-stat/dist/ecStat.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ecStat\"] = factory();\n\telse\n\t\troot[\"ecStat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    return {\n\n\t        clustering: __webpack_require__(1),\n\t        regression: __webpack_require__(5),\n\t        statistics: __webpack_require__(6),\n\t        histogram: __webpack_require__(15),\n\n\t        transform: {\n\t            regression: __webpack_require__(18),\n\t            histogram: __webpack_require__(21),\n\t            clustering: __webpack_require__(22)\n\t        }\n\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var dataProcess = __webpack_require__(2);\n\t    var dataPreprocess = dataProcess.dataPreprocess;\n\t    var normalizeDimensions = dataProcess.normalizeDimensions;\n\t    var arrayUtil = __webpack_require__(3);\n\t    var numberUtil = __webpack_require__(4);\n\t    var arraySize = arrayUtil.size;\n\t    var sumOfColumn = arrayUtil.sumOfColumn;\n\t    var arraySum = arrayUtil.sum;\n\t    var zeros = arrayUtil.zeros;\n\t    // var isArray = arrayUtil.isArray;\n\t    var numberUtil = __webpack_require__(4);\n\t    var isNumber = numberUtil.isNumber;\n\t    var mathPow = Math.pow;\n\n\t    var OutputType = {\n\t        /**\n\t         * Data are all in one. Cluster info are added as an attribute of data.\n\t         * ```ts\n\t         * type OutputDataSingle = {\n\t         *     // Each index of `data` is the index of the input data.\n\t         *     data: OutputDataItem[];\n\t         *     // The index of `centroids` is the cluster index.\n\t         *     centroids: [ValueOnX, ValueOnY][];\n\t         * };\n\t         * type InputDataItem = (ValueOnX | ValueOnY | OtherValue)[];\n\t         * type OutputDataItem = (...InputDataItem | ClusterIndex | SquareDistanceToCentroid)[];\n\t         * ```\n\t         */\n\t        SINGLE: 'single',\n\t        /**\n\t         * Data are separated by cluster. Suitable for retrieving data form each cluster.\n\t         * ```ts\n\t         * type OutputDataMultiple = {\n\t         *     // Each index of `clusterAssment` is the index of the input data.\n\t         *     clusterAssment: [ClusterIndex, SquareDistanceToCentroid][];\n\t         *     // The index of `centroids` is the cluster index.\n\t         *     centroids: [ValueOnX, ValueOnY][];\n\t         *     // The index of `pointsInCluster` is the cluster index.\n\t         *     pointsInCluster: DataItemListInOneCluster[];\n\t         * }\n\t         * type DataItemListInOneCluster = InputDataItem[];\n\t         * type InputDataItem = (ValueOnX | ValueOnY | OtherValue)[];\n\t         * type SquareDistanceToCentroid = number;\n\t         * type ClusterIndex = number;\n\t         * type ValueOnX = number;\n\t         * type ValueOnY = number;\n\t         * type OtherValue = unknown;\n\t         * ```\n\t         */\n\t        MULTIPLE: 'multiple'\n\t    }\n\n\t    /**\n\t     * KMeans of clustering algorithm.\n\t     * @param {Array.<Array.<number>>} data two-dimension array\n\t     * @param {number} k the number of clusters in a dataset\n\t     * @return {Object}\n\t     */\n\t    function kMeans(data, k, dataMeta) {\n\n\t        // create array to assign data points to centroids, also holds SE of each point\n\t        var clusterAssigned = zeros(data.length, 2);\n\t        var centroids = createRandCent(k, calcExtents(data, dataMeta.dimensions));\n\t        var clusterChanged = true;\n\t        var minDist;\n\t        var minIndex;\n\t        var distIJ;\n\t        var ptsInClust;\n\n\t        while (clusterChanged) {\n\t            clusterChanged = false;\n\t            for (var i = 0; i < data.length; i++) {\n\t                minDist = Infinity;\n\t                minIndex = -1;\n\t                for (var j = 0; j < k; j++) {\n\t                    distIJ = distEuclid(data[i], centroids[j], dataMeta);\n\t                    if (distIJ < minDist) {\n\t                        minDist = distIJ;\n\t                        minIndex = j;\n\t                    }\n\t                }\n\t                if (clusterAssigned[i][0] !== minIndex) {\n\t                    clusterChanged = true;\n\t                }\n\t                clusterAssigned[i][0] = minIndex;\n\t                clusterAssigned[i][1] = minDist;\n\t            }\n\t            //recalculate centroids\n\t            for (var i = 0; i < k; i++) {\n\t                ptsInClust = [];\n\t                for (var j = 0; j < clusterAssigned.length; j++) {\n\t                    if (clusterAssigned[j][0] === i) {\n\t                        ptsInClust.push(data[j]);\n\t                    }\n\t                }\n\t                centroids[i] = meanInColumns(ptsInClust, dataMeta);\n\t            }\n\t        }\n\n\t        var clusterWithKmeans = {\n\t            centroids: centroids,\n\t            clusterAssigned: clusterAssigned\n\t        };\n\t        return clusterWithKmeans;\n\t    }\n\n\t    /**\n\t     * Calculate the average of each column in a two-dimensional array\n\t     * and returns the values as an array.\n\t     */\n\t    function meanInColumns(dataList, dataMeta) {\n\t        var meanArray = [];\n\t        var sum;\n\t        var mean;\n\t        for (var j = 0; j < dataMeta.dimensions.length; j++) {\n\t            var dimIdx = dataMeta.dimensions[j];\n\t            sum = 0;\n\t            for (var i = 0; i < dataList.length; i++) {\n\t                sum += dataList[i][dimIdx];\n\t            }\n\t            mean = sum / dataList.length;\n\t            meanArray.push(mean);\n\t        }\n\t        return meanArray;\n\t    }\n\n\t    /**\n\t     * The combine of hierarchical clustering and k-means.\n\t     * @param {Array} data two-dimension array.\n\t     * @param {Object|number} [clusterCountOrConfig] config or clusterCountOrConfig.\n\t     * @param {number} clusterCountOrConfig.clusterCount Mandatory.\n\t     *        The number of clusters in a dataset. It has to be greater than 1.\n\t     * @param {boolean} [clusterCountOrConfig.stepByStep=false] Optional.\n\t     * @param {OutputType} [clusterCountOrConfig.outputType='multiple'] Optional.\n\t     *        See `OutputType`.\n\t     * @param {number} [clusterCountOrConfig.outputClusterIndexDimension] Mandatory.\n\t     *        Only work in `OutputType.SINGLE`.\n\t     * @param {number} [clusterCountOrConfig.outputCentroidDimensions] Optional.\n\t     *        If specified, the centroid will be set to those dimensions of the result data one by one.\n\t     *        By default not set centroid to result.\n\t     *        Only work in `OutputType.SINGLE`.\n\t     * @param {Array.<number>} [clusterCountOrConfig.dimensions] Optional.\n\t     *        Target dimensions to calculate the regression.\n\t     *        By default: use all of the data.\n\t     * @return {Array} See `OutputType`.\n\t     */\n\t    function hierarchicalKMeans(data, clusterCountOrConfig, stepByStep) {\n\t        var config = (\n\t            isNumber(clusterCountOrConfig)\n\t                ? {clusterCount: clusterCountOrConfig, stepByStep: stepByStep}\n\t                : clusterCountOrConfig\n\t        ) || {clusterCount: 2};\n\n\t        var k = config.clusterCount;\n\n\t        if (k < 2) {\n\t            return;\n\t        }\n\n\t        var dataMeta = parseDataMeta(data, config);\n\t        var isOutputTypeSingle = dataMeta.outputType === OutputType.SINGLE;\n\n\t        var dataSet = dataPreprocess(data, {dimensions: dataMeta.dimensions});\n\n\t        var clusterAssment = zeros(dataSet.length, 2);\n\t        var outputSingleData;\n\t        var setClusterIndex;\n\t        var getClusterIndex;\n\n\t        function setDistance(dataIndex, dist) {\n\t            clusterAssment[dataIndex][1] = dist;\n\t        }\n\t        function getDistance(dataIndex) {\n\t            return clusterAssment[dataIndex][1];\n\t        };\n\n\t        if (isOutputTypeSingle) {\n\t            outputSingleData = [];\n\t            var outputClusterIndexDimension = dataMeta.outputClusterIndexDimension;\n\n\t            setClusterIndex = function (dataIndex, clusterIndex) {\n\t                outputSingleData[dataIndex][outputClusterIndexDimension] = clusterIndex;\n\t            };\n\t            getClusterIndex = function (dataIndex) {\n\t                return outputSingleData[dataIndex][outputClusterIndexDimension];\n\t            };\n\n\t            for (var i = 0; i < dataSet.length; i++) {\n\t                outputSingleData.push(dataSet[i].slice());\n\t                setDistance(i, 0);\n\t                setClusterIndex(i, 0);\n\t            }\n\t        }\n\t        else {\n\t            setClusterIndex = function (dataIndex, clusterIndex) {\n\t                clusterAssment[dataIndex][0] = clusterIndex;\n\t            };\n\t            getClusterIndex = function (dataIndex) {\n\t                return clusterAssment[dataIndex][0];\n\t            };\n\t        }\n\n\t        // initial center point.\n\t        var centroid0 = meanInColumns(dataSet, dataMeta);\n\t        var centList = [centroid0];\n\t        for (var i = 0; i < dataSet.length; i++) {\n\t            var dist = distEuclid(dataSet[i], centroid0, dataMeta);\n\t            setDistance(i, dist);\n\t        }\n\n\t        var lowestSSE;\n\t        var ptsInClust;\n\t        var ptsNotClust;\n\t        var clusterInfo;\n\t        var sseSplit;\n\t        var sseNotSplit;\n\t        var index = 1;\n\t        var result = {\n\t            data: outputSingleData,\n\t            centroids: centList,\n\t            isEnd: false\n\t        };\n\t        if (!isOutputTypeSingle) {\n\t            // Only for backward compat.\n\t            result.clusterAssment = clusterAssment;\n\t        }\n\n\t        function oneStep() {\n\t            //the existing clusters are continuously divided\n\t            //until the number of clusters is k\n\t            if (index < k) {\n\t                lowestSSE = Infinity;\n\t                var centSplit;\n\t                var newCentroid;\n\t                var newClusterAss;\n\n\t                for (var j = 0; j < centList.length; j++) {\n\t                    ptsInClust = [];\n\t                    ptsNotClust = [];\n\t                    for (var i = 0; i < dataSet.length; i++) {\n\t                        if (getClusterIndex(i) === j) {\n\t                            ptsInClust.push(dataSet[i]);\n\t                        }\n\t                        else {\n\t                            ptsNotClust.push(getDistance(i));\n\t                        }\n\t                    }\n\t                    clusterInfo = kMeans(ptsInClust, 2, dataMeta);\n\t                    sseSplit = sumOfColumn(clusterInfo.clusterAssigned, 1);\n\t                    sseNotSplit = arraySum(ptsNotClust);\n\t                    if (sseSplit + sseNotSplit < lowestSSE) {\n\t                        lowestSSE = sseNotSplit + sseSplit;\n\t                        centSplit = j;\n\t                        newCentroid = clusterInfo.centroids;\n\t                        newClusterAss = clusterInfo.clusterAssigned;\n\t                    }\n\t                }\n\n\t                for (var i = 0; i < newClusterAss.length; i++) {\n\t                    if (newClusterAss[i][0] === 0) {\n\t                        newClusterAss[i][0] = centSplit;\n\t                    }\n\t                    else if (newClusterAss[i][0] === 1) {\n\t                        newClusterAss[i][0] = centList.length;\n\t                    }\n\t                }\n\n\t                centList[centSplit] = newCentroid[0];\n\t                centList.push(newCentroid[1]);\n\t                for (var i = 0, j = 0; i < dataSet.length && j < newClusterAss.length; i++) {\n\t                    if (getClusterIndex(i) === centSplit) {\n\t                        setClusterIndex(i, newClusterAss[j][0]);\n\t                        setDistance(i, newClusterAss[j++][1]);\n\t                    }\n\t                }\n\n\t                var pointInClust = [];\n\t                if (!isOutputTypeSingle) {\n\t                    for (var i = 0; i < centList.length; i++) {\n\t                        pointInClust[i] = [];\n\t                        for (var j = 0; j < dataSet.length; j++) {\n\t                            if (getClusterIndex(j) === i) {\n\t                                pointInClust[i].push(dataSet[j]);\n\t                            }\n\t                        }\n\t                    }\n\t                    result.pointsInCluster = pointInClust;\n\t                }\n\n\t                index++;\n\t            }\n\t            else {\n\t                result.isEnd = true;\n\t            }\n\t        }\n\n\t        if (!config.stepByStep) {\n\t            while (oneStep(), !result.isEnd);\n\t        }\n\t        else {\n\t            result.next = function () {\n\t                oneStep();\n\t                setCentroidToResultData(result, dataMeta);\n\t                return result;\n\t            };\n\t        }\n\t        setCentroidToResultData(result, dataMeta);\n\t        return result;\n\t    }\n\n\t    function setCentroidToResultData(result, dataMeta) {\n\t        var outputCentroidDimensions = dataMeta.outputCentroidDimensions;\n\t        if (dataMeta.outputType !== OutputType.SINGLE || outputCentroidDimensions == null) {\n\t            return;\n\t        }\n\t        var outputSingleData = result.data;\n\t        var centroids = result.centroids;\n\n\t        for (var i = 0; i < outputSingleData.length; i++) {\n\t            var line = outputSingleData[i];\n\t            var clusterIndex = line[dataMeta.outputClusterIndexDimension];\n\t            var centroid = centroids[clusterIndex];\n\t            var dimLen = Math.min(centroid.length, outputCentroidDimensions.length);\n\t            for (var j = 0; j < dimLen; j++) {\n\t                line[outputCentroidDimensions[j]] = centroid[j];\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Create random centroid of kmeans.\n\t     */\n\t    function createRandCent(k, extents) {\n\t        //constructs a two-dimensional array with all values 0\n\t        var centroids = zeros(k, extents.length);\n\t        //create random cluster centers, within bounds of each dimension\n\t        for (var j = 0; j < extents.length; j++) {\n\t            var extentItem = extents[j];\n\t            for (var i = 0; i < k; i++) {\n\t                centroids[i][j] = extentItem.min + extentItem.span * Math.random();\n\t            }\n\t        }\n\t        return centroids;\n\t    }\n\n\t    /**\n\t     * Distance method for calculating similarity\n\t     */\n\t    function distEuclid(dataItem, centroid, dataMeta) {\n\t        // The distance should be normalized between different dimensions,\n\t        // otherwise they may provide different weight in the final distance.\n\t        // The greater weight offers more effect in the cluster determination.\n\n\t        var powerSum = 0;\n\t        var dimensions = dataMeta.dimensions;\n\t        var extents = dataMeta.rawExtents;\n\t        //subtract the corresponding elements in the vectors\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var span = extents[i].span;\n\t            // If span is 0, do not count.\n\t            if (span) {\n\t                var dimIdx = dimensions[i];\n\t                var dist = (dataItem[dimIdx] - centroid[i]) / span;\n\t                powerSum += mathPow(dist, 2);\n\t            }\n\t        }\n\n\t        return powerSum;\n\t    }\n\n\t    function parseDataMeta(dataSet, config) {\n\t        var size = arraySize(dataSet);\n\t        if (size.length < 1) {\n\t            throw new Error('The input data of clustering should be two-dimension array.');\n\t        }\n\t        var colCount = size[1];\n\t        var defaultDimensions = [];\n\t        for (var i = 0; i < colCount; i++) {\n\t            defaultDimensions.push(i);\n\t        }\n\t        var dimensions = normalizeDimensions(config.dimensions, defaultDimensions);\n\t        var outputType = config.outputType || OutputType.MULTIPLE;\n\n\t        var outputClusterIndexDimension = config.outputClusterIndexDimension;\n\t        if (outputType === OutputType.SINGLE && !numberUtil.isNumber(outputClusterIndexDimension)) {\n\t            throw new Error('outputClusterIndexDimension is required as a number.');\n\t        }\n\t        var extents = calcExtents(dataSet, dimensions);\n\n\t        return {\n\t            dimensions: dimensions,\n\t            rawExtents: extents,\n\t            outputType: outputType,\n\t            outputClusterIndexDimension: outputClusterIndexDimension,\n\t            outputCentroidDimensions: config.outputCentroidDimensions,\n\t        };\n\t    }\n\n\t    function calcExtents(dataSet, dimensions) {\n\t        var extents = [];\n\t        var dimLen = dimensions.length;\n\t        for (var i = 0; i < dimLen; i++) {\n\t            extents.push({ min: Infinity, max: -Infinity });\n\t        }\n\t        for (var i = 0; i < dataSet.length; i++) {\n\t            var line = dataSet[i];\n\t            for (var j = 0; j < dimLen; j++) {\n\t                var extentItem = extents[j];\n\t                var val = line[dimensions[j]];\n\t                extentItem.min > val && (extentItem.min = val);\n\t                extentItem.max < val && (extentItem.max = val);\n\t            }\n\t        }\n\t        for (var i = 0; i < dimLen; i++) {\n\t            extents[i].span = extents[i].max - extents[i].min;\n\t        }\n\t        return extents;\n\t    }\n\n\t    return {\n\t        OutputType: OutputType,\n\t        hierarchicalKMeans: hierarchicalKMeans\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var array = __webpack_require__(3);\n\t    var isArray = array.isArray;\n\t    var size = array.size;\n\t    var number = __webpack_require__(4);\n\t    var isNumber = number.isNumber;\n\n\t    /**\n\t     * @param  {Array.<number>|number} dimensions like `[2, 4]` or `4`\n\t     * @param  {Array.<number>} [defaultDimensions=undefined] By default `undefined`.\n\t     * @return {Array.<number>} number like `4` is normalized to `[4]`,\n\t     *         `null`/`undefined` is normalized to `defaultDimensions`.\n\t     */\n\t    function normalizeDimensions(dimensions, defaultDimensions) {\n\t        return typeof dimensions === 'number'\n\t            ? [dimensions]\n\t            : dimensions == null\n\t            ? defaultDimensions\n\t            : dimensions;\n\t    }\n\n\t    /**\n\t     * Data preprocessing, filter the wrong data object.\n\t     *  for example [12,] --- missing y value\n\t     *              [,12] --- missing x value\n\t     *              [12, b] --- incorrect y value\n\t     *              ['a', 12] --- incorrect x value\n\t     * @param  {Array.<Array>} data\n\t     * @param  {Object?} [opt]\n\t     * @param  {Array.<number>} [opt.dimensions] Optional. Like [2, 4],\n\t     *         means that dimension index 2 and dimension index 4 need to be number.\n\t     *         If null/undefined (by default), all dimensions need to be number.\n\t     * @param  {boolean} [opt.toOneDimensionArray] Convert to one dimension array.\n\t     *         Each value is from `opt.dimensions[0]` or dimension 0.\n\t     * @return {Array.<Array.<number>>}\n\t     */\n\t    function dataPreprocess(data, opt) {\n\t        opt = opt || {};\n\t        var dimensions = opt.dimensions;\n\t        var numberDimensionMap = {};\n\t        if (dimensions != null) {\n\t            for (var i = 0; i < dimensions.length; i++) {\n\t                numberDimensionMap[dimensions[i]] = true;\n\t            }\n\t        }\n\t        var targetOneDim = opt.toOneDimensionArray\n\t            ? (dimensions ? dimensions[0] : 0)\n\t            : null;\n\n\t        function shouldBeNumberDimension(dimIdx) {\n\t            return !dimensions || numberDimensionMap.hasOwnProperty(dimIdx);\n\t        }\n\n\t        if (!isArray(data)) {\n\t            throw new Error('Invalid data type, you should input an array');\n\t        }\n\t        var predata = [];\n\t        var arraySize = size(data);\n\n\t        if (arraySize.length === 1) {\n\t            for (var i = 0; i < arraySize[0]; i++) {\n\t                var item = data[i];\n\t                if (isNumber(item)) {\n\t                    predata.push(item);\n\t                }\n\t            }\n\t        }\n\t        else if (arraySize.length === 2) {\n\t            for (var i = 0; i < arraySize[0]; i++) {\n\t                var isCorrect = true;\n\t                var item = data[i];\n\t                for (var j = 0; j < arraySize[1]; j++) {\n\t                    if (shouldBeNumberDimension(j) && !isNumber(item[j])) {\n\t                        isCorrect = false;\n\t                    }\n\t                }\n\t                if (isCorrect) {\n\t                    predata.push(\n\t                        targetOneDim != null\n\t                            ? item[targetOneDim]\n\t                            : item\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        return predata;\n\t    }\n\n\t    /**\n\t     * @param {string|number} val\n\t     * @return {number}\n\t     */\n\t    function getPrecision(val) {\n\t        var str = val.toString();\n\t        // scientific notation is not considered\n\t        var dotIndex = str.indexOf('.');\n\t        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n\t    }\n\n\t    return {\n\t        normalizeDimensions: normalizeDimensions,\n\t        dataPreprocess: dataPreprocess,\n\t        getPrecision: getPrecision\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var objToString = Object.prototype.toString;\n\t    var arrayProto = Array.prototype;\n\t    var nativeMap = arrayProto.map;\n\n\t    /**\n\t     * Get the size of a array\n\t     * @param  {Array} data\n\t     * @return {Array}\n\t     */\n\t    function size(data) {\n\t        var s = [];\n\t        while (isArray(data)) {\n\t            s.push(data.length);\n\t            data = data[0];\n\t        }\n\t        return s;\n\t    }\n\n\t    /**\n\t     * @param {*}  value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\n\t    /**\n\t     * constructs a (m x n) array with all values 0\n\t     * @param  {number} m  the row\n\t     * @param  {number} n  the column\n\t     * @return {Array}\n\t     */\n\t    function zeros(m, n) {\n\t        var zeroArray = [];\n\t        for (var i = 0; i < m ; i++) {\n\t            zeroArray[i] = [];\n\t            for (var j = 0; j < n; j++) {\n\t                zeroArray[i][j] = 0;\n\t            }\n\t        }\n\t        return zeroArray;\n\t    }\n\n\t    /**\n\t     * Sums each element in the array.\n\t     * Internal use, for performance considerations, to avoid\n\t     * unnecessary judgments and calculations.\n\t     * @param  {Array} vector\n\t     * @return {number}\n\t     */\n\t    function sum(vector) {\n\t        var sum = 0;\n\t        for (var i = 0; i < vector.length; i++) {\n\t            sum += vector[i];\n\t        }\n\t        return sum;\n\t    }\n\n\t    /**\n\t     * Computes the sum of the specified column elements in a two-dimensional array\n\t     * @param  {Array.<Array>} dataList  two-dimensional array\n\t     * @param  {number} n  the specified column, zero-based\n\t     * @return {number}\n\t     */\n\t    function sumOfColumn(dataList, n) {\n\t        var sum = 0;\n\t        for (var i = 0; i < dataList.length; i++) {\n\t            sum += dataList[i][n];\n\t        }\n\t        return sum;\n\t    }\n\n\n\t    function ascending(a, b) {\n\n\t        return a > b ? 1 : a < b ? -1 : a === b ? 0 : NaN;\n\n\t    }\n\n\t    /**\n\t     * Binary search algorithm --- this bisector is specidfied to histogram, which every bin like that [a, b),\n\t     * so the return value use to add 1.\n\t     * @param  {Array.<number>} array\n\t     * @param  {number} value\n\t     * @param  {number} start\n\t     * @param  {number} end\n\t     * @return {number}\n\t     */\n\t    function bisect(array, value, start, end) { //移出去\n\n\t        if (start == null) {\n\t            start = 0;\n\t        }\n\t        if (end == null) {\n\t            end = array.length;\n\t        }\n\t        while (start < end) {\n\t            var mid = Math.floor((start + end) / 2);\n\t            var compare = ascending(array[mid], value);\n\t            if (compare > 0) {\n\t                end = mid;\n\t            }\n\t            else if (compare < 0) {\n\t                start = mid + 1;\n\t            }\n\t            else {\n\t                return mid + 1;\n\t            }\n\t        }\n\t        return start;\n\t    }\n\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\n\t    return {\n\t        size: size,\n\t        isArray: isArray,\n\t        zeros: zeros,\n\t        sum: sum,\n\t        sumOfColumn: sumOfColumn,\n\t        ascending: ascending,\n\t        bisect: bisect,\n\t        map: map\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    /**\n\t     * Test whether value is a number.\n\t     * @param  {*}  value\n\t     * @return {boolean}\n\t     */\n\t    function isNumber(value) {\n\n\t        value = value === null ? NaN : +value;\n\t        return typeof value === 'number' && !isNaN(value);\n\t    }\n\n\t    /**\n\t     * Test if a number is integer.\n\t     * @param  {number}  value\n\t     * @return {boolean}\n\t     */\n\t    function isInteger(value) {\n\t        return isFinite(value) && value === Math.round(value);\n\t    }\n\n\t    function quantityExponent(val) {\n\t        if (val === 0) {\n\t            return 0;\n\t        }\n\t        var exp = Math.floor(Math.log(val) / Math.LN10);\n\t        // Fix pricision loss.\n\t        if (val / Math.pow(10, exp) >= 10) {\n\t            exp++;\n\t        }\n\t        return exp;\n\t    }\n\n\t    return {\n\t        isNumber: isNumber,\n\t        isInteger: isInteger,\n\t        quantityExponent: quantityExponent\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var dataProcess = __webpack_require__(2);\n\t    var dataPreprocess = dataProcess.dataPreprocess;\n\t    var normalizeDimensions = dataProcess.normalizeDimensions;\n\n\t    var regreMethods = {\n\n\t        /**\n\t         * Common linear regression algorithm\n\t         */\n\t        linear: function (predata, opt) {\n\n\t            var xDimIdx = opt.dimensions[0];\n\t            var yDimIdx = opt.dimensions[1];\n\t            var sumX = 0;\n\t            var sumY = 0;\n\t            var sumXY = 0;\n\t            var sumXX = 0;\n\t            var len = predata.length;\n\n\t            for (var i = 0; i < len; i++) {\n\t                var rawItem = predata[i];\n\t                sumX += rawItem[xDimIdx];\n\t                sumY += rawItem[yDimIdx];\n\t                sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n\t                sumXX += rawItem[xDimIdx] * rawItem[xDimIdx];\n\t            }\n\n\t            var gradient = ((len * sumXY) - (sumX * sumY)) / ((len * sumXX) - (sumX * sumX));\n\t            var intercept = (sumY / len) - ((gradient * sumX) / len);\n\n\t            var result = [];\n\t            for (var j = 0; j < predata.length; j++) {\n\t                var rawItem = predata[j];\n\t                var resultItem = rawItem.slice();\n\t                resultItem[xDimIdx] = rawItem[xDimIdx];\n\t                resultItem[yDimIdx] = gradient * rawItem[xDimIdx] + intercept;\n\t                result.push(resultItem);\n\t            }\n\n\t            var expression = 'y = ' + Math.round(gradient * 100) / 100 + 'x + ' + Math.round(intercept * 100) / 100;\n\n\t            return {\n\t                points: result,\n\t                parameter: {\n\t                    gradient: gradient,\n\t                    intercept: intercept\n\t                },\n\t                expression: expression\n\t            };\n\t        },\n\n\t        /**\n\t         * If the raw data include [0,0] point, we should choose linearThroughOrigin\n\t         *   instead of linear.\n\t         */\n\t        linearThroughOrigin: function (predata, opt) {\n\n\t            var xDimIdx = opt.dimensions[0];\n\t            var yDimIdx = opt.dimensions[1];\n\t            var sumXX = 0;\n\t            var sumXY = 0;\n\n\t            for (var i = 0; i < predata.length; i++) {\n\t                var rawItem = predata[i];\n\t                sumXX += rawItem[xDimIdx] * rawItem[xDimIdx];\n\t                sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n\t            }\n\n\t            var gradient = sumXY / sumXX;\n\t            var result = [];\n\n\t            for (var j = 0; j < predata.length; j++) {\n\t                var rawItem = predata[j];\n\t                var resultItem = rawItem.slice();\n\t                resultItem[xDimIdx] = rawItem[xDimIdx];\n\t                resultItem[yDimIdx] = rawItem[xDimIdx] * gradient;\n\t                result.push(resultItem);\n\t            }\n\n\t            var expression = 'y = ' + Math.round(gradient * 100) / 100 + 'x';\n\n\t            return {\n\t                points: result,\n\t                parameter: {\n\t                    gradient: gradient\n\t                },\n\t                expression: expression\n\t            };\n\t        },\n\n\t        /**\n\t         * Exponential regression\n\t         */\n\t        exponential: function (predata, opt) {\n\n\t            var xDimIdx = opt.dimensions[0];\n\t            var yDimIdx = opt.dimensions[1];\n\t            var sumX = 0;\n\t            var sumY = 0;\n\t            var sumXXY = 0;\n\t            var sumYlny = 0;\n\t            var sumXYlny = 0;\n\t            var sumXY = 0;\n\n\t            for (var i = 0; i < predata.length; i++) {\n\t                var rawItem = predata[i];\n\t                sumX += rawItem[xDimIdx];\n\t                sumY += rawItem[yDimIdx];\n\t                sumXY += rawItem[xDimIdx] * rawItem[yDimIdx];\n\t                sumXXY += rawItem[xDimIdx] * rawItem[xDimIdx] * rawItem[yDimIdx];\n\t                sumYlny += rawItem[yDimIdx] * Math.log(rawItem[yDimIdx]);\n\t                sumXYlny += rawItem[xDimIdx] * rawItem[yDimIdx] * Math.log(rawItem[yDimIdx]);\n\t            }\n\n\t            var denominator = (sumY * sumXXY) - (sumXY * sumXY);\n\t            var coefficient = Math.pow(Math.E, (sumXXY * sumYlny - sumXY * sumXYlny) / denominator);\n\t            var index = (sumY * sumXYlny - sumXY * sumYlny) / denominator;\n\t            var result = [];\n\n\t            for (var j = 0; j < predata.length; j++) {\n\t                var rawItem = predata[j];\n\t                var resultItem = rawItem.slice();\n\t                resultItem[xDimIdx] = rawItem[xDimIdx];\n\t                resultItem[yDimIdx] = coefficient * Math.pow(Math.E, index * rawItem[xDimIdx]);\n\t                result.push(resultItem);\n\t            }\n\n\t            var expression = 'y = ' + Math.round(coefficient * 100) / 100 + 'e^(' + Math.round(index * 100) / 100 + 'x)';\n\n\t            return {\n\t                points: result,\n\t                parameter: {\n\t                    coefficient: coefficient,\n\t                    index: index\n\t                },\n\t                expression: expression\n\t            };\n\n\t        },\n\n\t        /**\n\t         * Logarithmic regression\n\t         */\n\t        logarithmic: function (predata, opt) {\n\n\t            var xDimIdx = opt.dimensions[0];\n\t            var yDimIdx = opt.dimensions[1];\n\t            var sumlnx = 0;\n\t            var sumYlnx = 0;\n\t            var sumY = 0;\n\t            var sumlnxlnx = 0;\n\n\t            for (var i = 0; i < predata.length; i++) {\n\t                var rawItem = predata[i];\n\t                sumlnx += Math.log(rawItem[xDimIdx]);\n\t                sumYlnx += rawItem[yDimIdx] * Math.log(rawItem[xDimIdx]);\n\t                sumY += rawItem[yDimIdx];\n\t                sumlnxlnx += Math.pow(Math.log(rawItem[xDimIdx]), 2);\n\t            }\n\n\t            var gradient = (i * sumYlnx - sumY * sumlnx) / (i * sumlnxlnx - sumlnx * sumlnx);\n\t            var intercept = (sumY - gradient * sumlnx) / i;\n\t            var result = [];\n\n\t            for (var j = 0; j < predata.length; j++) {\n\t                var rawItem = predata[j];\n\t                var resultItem = rawItem.slice();\n\t                resultItem[xDimIdx] = rawItem[xDimIdx];\n\t                resultItem[yDimIdx] = gradient * Math.log(rawItem[xDimIdx]) + intercept;\n\t                result.push(resultItem);\n\t            }\n\n\t            var expression =\n\t                'y = '\n\t                + Math.round(intercept * 100) / 100\n\t                + ' + '\n\t                + Math.round(gradient * 100) / 100 + 'ln(x)';\n\n\t            return {\n\t                points: result,\n\t                parameter: {\n\t                    gradient: gradient,\n\t                    intercept: intercept\n\t                },\n\t                expression: expression\n\t            };\n\n\t        },\n\n\t        /**\n\t         * Polynomial regression\n\t         */\n\t        polynomial: function (predata, opt) {\n\n\t            var xDimIdx = opt.dimensions[0];\n\t            var yDimIdx = opt.dimensions[1];\n\t            var order = opt.order;\n\n\t            if (order == null) {\n\t                order = 2;\n\t            }\n\t            //coefficient matrix\n\t            var coeMatrix = [];\n\t            var lhs = [];\n\t            var k = order + 1;\n\n\t            for (var i = 0; i < k; i++) {\n\t                var sumA = 0;\n\t                for (var n = 0; n < predata.length; n++) {\n\t                    var rawItem = predata[n];\n\t                    sumA += rawItem[yDimIdx] * Math.pow(rawItem[xDimIdx], i);\n\t                }\n\t                lhs.push(sumA);\n\n\t                var temp = [];\n\t                for (var j = 0; j < k; j++) {\n\t                    var sumB = 0;\n\t                    for (var m = 0; m < predata.length; m++) {\n\t                        sumB += Math.pow(predata[m][xDimIdx], i + j);\n\t                    }\n\t                    temp.push(sumB);\n\t                }\n\t                coeMatrix.push(temp);\n\t            }\n\t            coeMatrix.push(lhs);\n\n\t            var coeArray = gaussianElimination(coeMatrix, k);\n\n\t            var result = [];\n\n\t            for (var i = 0; i < predata.length; i++) {\n\t                var value = 0;\n\t                var rawItem = predata[i];\n\t                for (var n = 0; n < coeArray.length; n++) {\n\t                    value += coeArray[n] * Math.pow(rawItem[xDimIdx], n);\n\t                }\n\t                var resultItem = rawItem.slice();\n\t                resultItem[xDimIdx] = rawItem[xDimIdx];\n\t                resultItem[yDimIdx] = value;\n\t                result.push(resultItem);\n\t            }\n\n\t            var expression = 'y = ';\n\t            for (var i = coeArray.length - 1; i >= 0; i--) {\n\t                if (i > 1) {\n\t                    expression += Math.round(coeArray[i] * Math.pow(10, i + 1)) / Math.pow(10, i + 1) + 'x^' + i + ' + ';\n\t                }\n\t                else if (i === 1) {\n\t                    expression += Math.round(coeArray[i] * 100) / 100 + 'x' + ' + ';\n\t                }\n\t                else {\n\t                    expression += Math.round(coeArray[i] * 100) / 100;\n\t                }\n\t            }\n\n\t            return {\n\t                points: result,\n\t                parameter: coeArray,\n\t                expression: expression\n\t            };\n\n\t        }\n\n\t    };\n\n\t    /**\n\t     * Gaussian elimination\n\t     * @param  {Array.<Array.<number>>} matrix   two-dimensional number array\n\t     * @param  {number} number\n\t     * @return {Array}\n\t     */\n\t    function gaussianElimination(matrix, number) {\n\n\t        for (var i = 0; i < matrix.length - 1; i++) {\n\t            var maxColumn = i;\n\t            for (var j = i + 1; j < matrix.length - 1; j++) {\n\t                if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxColumn])) {\n\t                    maxColumn = j;\n\t                }\n\t            }\n\t            // the matrix here is the transpose of the common Augmented matrix.\n\t            //  so the can perform the primary column transform, in fact, equivalent\n\t            //  to the primary line changes\n\t            for (var k = i; k < matrix.length; k++) {\n\t                var temp = matrix[k][i];\n\t                matrix[k][i] = matrix[k][maxColumn];\n\t                matrix[k][maxColumn] = temp;\n\t            }\n\t            for (var n = i + 1; n < matrix.length - 1; n++) {\n\t                for (var m = matrix.length - 1; m >= i; m--) {\n\t                    matrix[m][n] -= matrix[m][i] / matrix[i][i] * matrix[i][n];\n\t                }\n\t            }\n\t        }\n\n\t        var data = new Array(number);\n\t        var len = matrix.length - 1;\n\t        for (var j = matrix.length - 2; j >= 0; j--) {\n\t            var temp = 0;\n\t            for (var i = j + 1; i < matrix.length - 1; i++) {\n\t                temp += matrix[i][j] * data[i];\n\t            }\n\t            data[j] = (matrix[len][j] - temp) / matrix[j][j];\n\n\t        }\n\n\t        return data;\n\t    }\n\n\t    /**\n\t     * @param  {string} regreMethod\n\t     * @param  {Array.<Array.<number>>} data   two-dimensional number array\n\t     * @param  {Object|number} [optOrOrder]  opt or order\n\t     * @param  {number} [optOrOrder.order]  order of polynomials\n\t     * @param  {Array.<number>|number} [optOrOrder.dimensions=[0, 1]]  Target dimensions to calculate the regression.\n\t     *         By defualt: use [0, 1] as [x, y].\n\t     * @return {Array}\n\t     */\n\t    var regression = function (regreMethod, data, optOrOrder) {\n\t        var opt = typeof optOrOrder === 'number'\n\t            ? { order: optOrOrder }\n\t            : (optOrOrder || {});\n\n\t        var dimensions = normalizeDimensions(opt.dimensions, [0, 1]);\n\n\t        var predata = dataPreprocess(data, { dimensions: dimensions });\n\t        var result = regreMethods[regreMethod](predata, {\n\t            order: opt.order,\n\t            dimensions: dimensions\n\t        });\n\n\t        // Sort for line chart.\n\t        var xDimIdx = dimensions[0];\n\t        result.points.sort(function (itemA, itemB) {\n\t            return itemA[xDimIdx] - itemB[xDimIdx];\n\t        });\n\n\t        return result;\n\t    };\n\n\t    return regression;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var statistics = {};\n\n\t    statistics.max = __webpack_require__(7);\n\t    statistics.deviation = __webpack_require__(8);\n\t    statistics.mean = __webpack_require__(10);\n\t    statistics.median = __webpack_require__(12);\n\t    statistics.min = __webpack_require__(14);\n\t    statistics.quantile = __webpack_require__(13);\n\t    statistics.sampleVariance = __webpack_require__(9);\n\t    statistics.sum = __webpack_require__(11);\n\n\t    return statistics;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var number = __webpack_require__(4);\n\t    var isNumber = number.isNumber;\n\n\t    /**\n\t     * Is a method for computing the max value of a list of numbers,\n\t     * which will filter other data types.\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function max(data) {\n\n\t        var maxData = -Infinity;\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (isNumber(data[i]) && data[i] > maxData) {\n\t                maxData = data[i];\n\t            }\n\t        }\n\t        return maxData;\n\t    }\n\n\t    return max;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var variance = __webpack_require__(9);\n\n\t    /**\n\t     * Computing the deviation\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    return function (data) {\n\n\t        var squaredDeviation = variance(data);\n\n\t        return squaredDeviation ? Math.sqrt(squaredDeviation) : squaredDeviation;\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var number = __webpack_require__(4);\n\t    var isNumber = number.isNumber;\n\t    var mean = __webpack_require__(10);\n\n\t    /**\n\t     * Computing the variance of list of sample\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function sampleVariance(data) {\n\n\t        var len = data.length;\n\t        if (!len || len < 2) {\n\t            return 0;\n\t        }\n\t        if (data.length >= 2) {\n\n\t            var meanValue = mean(data);\n\t            var sum = 0;\n\t            var temple;\n\n\t            for (var i = 0; i < data.length; i++) {\n\t                if (isNumber(data[i])) {\n\t                    temple = data[i] - meanValue;\n\t                    sum += temple * temple;\n\t                }\n\t            }\n\t            return sum / (data.length - 1);\n\t        }\n\t    }\n\n\t    return sampleVariance;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var sum = __webpack_require__(11);\n\n\t    /**\n\t     * Is a method for computing the mean value of a list of numbers,\n\t     * which will filter other data types.\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function mean(data) {\n\n\t        var len = data.length;\n\n\t        if (!len) {\n\t            return 0;\n\t        }\n\n\t        return sum(data) / data.length;\n\n\t    }\n\n\t    return mean;\n\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var number = __webpack_require__(4);\n\t    var isNumber = number.isNumber;\n\n\t    /**\n\t     * Is a method for computing the sum of a list of numbers,\n\t     * which will filter other data types.\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function sum(data) {\n\n\t        var len = data.length;\n\n\t        if (!len) {\n\t            return 0;\n\t        }\n\t        var sumData = 0;\n\t        for (var i = 0; i < len; i++) {\n\t            if (isNumber(data[i])) {\n\t                sumData += data[i];\n\t            }\n\t        }\n\t        return sumData;\n\t    }\n\n\t    return sum;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var quantile = __webpack_require__(13);\n\n\t    /**\n\t     * Is a method for computing the median value of a sorted array of numbers\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function median(data) {\n\n\t        return quantile(data, 0.5);\n\t    }\n\n\t    return median;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    /**\n\t     * Estimating quantiles from a sorted sample of numbers\n\t     * @see https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample\n\t     * R-7 method\n\t     * @param  {Array.<number>} data  sorted array\n\t     * @param  {number} p\n\t     */\n\t    return function (data, p) {\n\n\t        var len = data.length;\n\n\t        if (!len) {\n\t            return 0;\n\t        }\n\t        if (p <= 0 || len < 2) {\n\t            return data[0];\n\t        }\n\t        if (p >= 1) {\n\t            return data[len -1];\n\t        }\n\t        // in the wikipedia's R-7 method h = (N - 1)p + 1, but here array index start from 0\n\t        var h = (len - 1) * p;\n\t        var i = Math.floor(h);\n\t        var a = data[i];\n\t        var b = data[i + 1];\n\t        return a + (b - a) * (h - i);\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var number = __webpack_require__(4);\n\t    var isNumber = number.isNumber;\n\n\t    /**\n\t     * Is a method for computing the min value of a list of numbers,\n\t     * which will filter other data types.\n\t     * @param  {Array.<number>} data\n\t     * @return {number}\n\t     */\n\t    function min(data) {\n\n\t        var minData = Infinity;\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (isNumber(data[i]) && data[i] < minData) {\n\t                minData = data[i];\n\t            }\n\t        }\n\t        return minData;\n\t    }\n\n\t    return min;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var max = __webpack_require__(7);\n\t    var min = __webpack_require__(14);\n\t    var quantile = __webpack_require__(13);\n\t    var deviation = __webpack_require__(8);\n\t    var dataProcess = __webpack_require__(2);\n\t    var dataPreprocess = dataProcess.dataPreprocess;\n\t    var normalizeDimensions = dataProcess.normalizeDimensions;\n\t    var array = __webpack_require__(3);\n\t    var ascending = array.ascending;\n\t    var map = array.map;\n\t    var range = __webpack_require__(16);\n\t    var bisect = array.bisect;\n\t    var tickStep = __webpack_require__(17);\n\n\t    /**\n\t     * Compute bins for histogram\n\t     * @param  {Array.<number>} data\n\t     * @param  {Object|string} optOrMethod Optional settings or `method`.\n\t     * @param  {Object|string} optOrMethod.method 'squareRoot' | 'scott' | 'freedmanDiaconis' | 'sturges'\n\t     * @param  {Array.<number>|number} optOrMethod.dimensions If data is a 2-d array,\n\t     *         which dimension will be used to calculate histogram.\n\t     * @return {Object}\n\t     */\n\t    function computeBins(data, optOrMethod) {\n\t        var opt = typeof optOrMethod === 'string'\n\t            ? { method: optOrMethod }\n\t            : (optOrMethod || {});\n\n\t        var threshold = opt.method == null\n\t            ? thresholdMethod.squareRoot\n\t            : thresholdMethod[opt.method];\n\t        var dimensions = normalizeDimensions(opt.dimensions);\n\n\t        var values = dataPreprocess(data, {\n\t            dimensions: dimensions,\n\t            toOneDimensionArray: true\n\t        });\n\t        var maxValue = max(values);\n\t        var minValue = min(values);\n\t        var binsNumber = threshold(values, minValue, maxValue);\n\t        var tickStepResult = tickStep(minValue, maxValue, binsNumber);\n\t        var step = tickStepResult.step;\n\t        var toFixedPrecision = tickStepResult.toFixedPrecision;\n\n\t        // return the xAxis coordinate for each bins, except the end point of the value\n\t        var rangeArray = range(\n\t            // use function toFixed() to avoid data like '0.700000001'\n\t            +((Math.ceil(minValue / step) * step).toFixed(toFixedPrecision)),\n\t            +((Math.floor(maxValue / step) * step).toFixed(toFixedPrecision)),\n\t            step,\n\t            toFixedPrecision\n\t        );\n\n\t        var len = rangeArray.length;\n\n\t        var bins = new Array(len + 1);\n\n\t        for (var i = 0; i <= len; i++) {\n\t            bins[i] = {};\n\t            bins[i].sample = [];\n\t            bins[i].x0 = i > 0\n\t                ? rangeArray[i - 1]\n\t                : (rangeArray[i] - minValue) === step\n\t                ? minValue\n\t                : (rangeArray[i] - step);\n\t            bins[i].x1 = i < len\n\t                ? rangeArray[i]\n\t                : (maxValue - rangeArray[i-1]) === step\n\t                ? maxValue\n\t                : rangeArray[i - 1] + step;\n\t        }\n\n\t        for (var i = 0; i < values.length; i++) {\n\t            if (minValue <= values[i] && values[i] <= maxValue) {\n\t                bins[bisect(rangeArray, values[i], 0, len)].sample.push(values[i]);\n\t            }\n\t        }\n\n\t        var data = map(bins, function (bin) {\n\t            // use function toFixed() to avoid data like '6.5666638489'\n\t            return [\n\t                +((bin.x0 + bin.x1) / 2).toFixed(toFixedPrecision),\n\t                bin.sample.length,\n\t                bin.x0,\n\t                bin.x1,\n\t                bin.x0 + ' - ' + bin.x1\n\t            ];\n\t        });\n\n\t        var customData = map(bins, function (bin) {\n\t            return [bin.x0, bin.x1, bin.sample.length];\n\t        });\n\n\t        return {\n\t            bins: bins,\n\t            data: data,\n\t            customData: customData\n\t        };\n\t    }\n\n\t    /**\n\t     * Four kinds of threshold methods used to\n\t     * compute how much bins the histogram should be divided\n\t     * @see  https://en.wikipedia.org/wiki/Histogram\n\t     * @type {Object}\n\t     */\n\t    var thresholdMethod = {\n\n\t        squareRoot: function (data) {\n\n\t            var bins = Math.ceil(Math.sqrt(data.length));\n\n\t            return bins > 50 ? 50 : bins;\n\t        },\n\n\t        scott: function (data, min, max) {\n\n\t            return Math.ceil((max - min) / (3.5 * deviation(data) * Math.pow(data.length, -1 / 3)));\n\t        },\n\n\t        freedmanDiaconis: function (data, min, max) {\n\n\t            data.sort(ascending);\n\n\t            return Math.ceil(\n\t                (max - min) / (2 * (quantile(data, 0.75) - quantile(data, 0.25)) * Math.pow(data.length, -1 / 3))\n\t            );\n\t        },\n\n\t        sturges: function (data) {\n\n\t            return Math.ceil(Math.log(data.length) / Math.LN2) + 1;\n\n\t        }\n\t    };\n\n\t    return computeBins;\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var dataProcess = __webpack_require__(2);\n\t    var getPrecision = dataProcess.getPrecision;\n\n\t    /**\n\t     * Computing range array.\n\t     * Adding param precision to fix range value, avoiding range[i] = 0.7000000001.\n\t     * @param  {number} start\n\t     * @param  {number} end\n\t     * @param  {number} step\n\t     * @param  {number} precision\n\t     * @return {Array.<number>}\n\t     */\n\t    return function (start, end, step, precision) {\n\n\t        var len = arguments.length;\n\n\t        if (len < 2) {\n\t            end = start;\n\t            start = 0;\n\t            step = 1;\n\t        }\n\t        else if (len < 3) {\n\t            step = 1;\n\t        }\n\t        else if (len < 4) {\n\t            step = +step;\n\t            precision = getPrecision(step);\n\t        }\n\t        else {\n\t            precision = +precision;\n\t        }\n\n\t        var n = Math.ceil(((end - start) / step).toFixed(precision));\n\t        var range = new Array(n + 1);\n\t        for (var i = 0; i < n + 1; i++) {\n\t            range[i] = +(start + i * step).toFixed(precision);\n\t        }\n\t        return range;\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var numberUtil = __webpack_require__(4);\n\n\t    /**\n\t     * Computing the length of step\n\t     * @see  https://github.com/d3/d3-array/blob/master/src/ticks.js\n\t     * @param {number} start\n\t     * @param {number} stop\n\t     * @param {number} count\n\t     */\n\t    return function (start, stop, count) {\n\n\t        var step0 = Math.abs(stop - start) / count;\n\t        var precision = numberUtil.quantityExponent(step0);\n\n\t        var step1 = Math.pow(10, precision);\n\t        var error = step0 / step1;\n\n\t        if (error >= Math.sqrt(50)) {\n\t            step1 *= 10;\n\t        }\n\t        else if (error >= Math.sqrt(10)) {\n\t            step1 *= 5;\n\t        }\n\t        else if(error >= Math.sqrt(2)) {\n\t            step1 *= 2;\n\t        }\n\n\t        var toFixedPrecision = precision < 0 ? -precision : 0;\n\t        var resultStep = +(\n\t            (stop >= start ? step1 : -step1).toFixed(toFixedPrecision)\n\t        );\n\n\t        return {\n\t            step: resultStep,\n\t            toFixedPrecision: toFixedPrecision\n\t        };\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var regression = __webpack_require__(5);\n\t    var transformHelper = __webpack_require__(19);\n\t    var FORMULA_DIMENSION = 2;\n\n\t    return {\n\n\t        type: 'ecStat:regression',\n\n\t        /**\n\t         * @param {Paramter<typeof regression>[0]} [params.config.method='linear'] 'linear' by default\n\t         * @param {Paramter<typeof regression>[2]} [params.config.order=2] Only work when method is `polynomial`.\n\t         * @param {DimensionLoose[]|DimensionLoose} [params.config.dimensions=[0, 1]] dimensions that used to calculate regression.\n\t         *        By default [0, 1].\n\t         * @param {'start' | 'end' | 'all'} params.config.formulaOn Include formula on the last (third) dimension of the:\n\t         *        'start': first data item.\n\t         *        'end': last data item (by default).\n\t         *        'all': all data items.\n\t         *        'none': no data item.\n\t         */\n\t        transform: function transform(params) {\n\t            var upstream = params.upstream;\n\t            var config = params.config || {};\n\t            var method = config.method || 'linear';\n\n\t            var result = regression(method, upstream.cloneRawData(), {\n\t                order: config.order,\n\t                dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions)\n\t            });\n\t            var points = result.points;\n\n\t            var formulaOn = config.formulaOn;\n\t            if (formulaOn == null) {\n\t                formulaOn = 'end';\n\t            }\n\n\t            var dimensions;\n\t            if (formulaOn !== 'none') {\n\t                for (var i = 0; i < points.length; i++) {\n\t                    points[i][FORMULA_DIMENSION] =\n\t                    (\n\t                        (formulaOn === 'start' && i === 0)\n\t                        || (formulaOn === 'all')\n\t                        || (formulaOn === 'end' && i === points.length - 1)\n\t                    ) ? result.expression : '';\n\t                }\n\t                dimensions = upstream.cloneAllDimensionInfo();\n\t                dimensions[FORMULA_DIMENSION] = {};\n\t            }\n\n\t            return [{\n\t                dimensions: dimensions,\n\t                data: points\n\t            }];\n\t        }\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var arrayUtil = __webpack_require__(3);\n\t    var numberUtil = __webpack_require__(4);\n\t    var objectUtil = __webpack_require__(20);\n\n\t    /**\n\t     * type DimensionLoose = DimensionIndex | DimensionName;\n\t     * type DimensionIndex = number;\n\t     * type DimensionName = string;\n\t     *\n\t     * @param {object} transformParams The parameter of echarts transfrom.\n\t     * @param {DimensionLoose | DimensionLoose[]} dimensionsConfig\n\t     * @return {DimensionIndex | DimensionIndex[]}\n\t     */\n\t    function normalizeExistingDimensions(transformParams, dimensionsConfig) {\n\t        if (dimensionsConfig == null) {\n\t            return;\n\t        }\n\t        var upstream = transformParams.upstream;\n\n\t        if (arrayUtil.isArray(dimensionsConfig)) {\n\t            var result = [];\n\t            for (var i = 0; i < dimensionsConfig.length; i++) {\n\t                var dimInfo = upstream.getDimensionInfo(dimensionsConfig[i]);\n\t                validateDimensionExists(dimInfo, dimensionsConfig[i]);\n\t                result[i] = dimInfo.index;\n\t            }\n\t            return result;\n\t        }\n\t        else {\n\t            var dimInfo = upstream.getDimensionInfo(dimensionsConfig);\n\t            validateDimensionExists(dimInfo, dimensionsConfig);\n\t            return dimInfo.index;\n\t        }\n\n\t        function validateDimensionExists(dimInfo, dimConfig) {\n\t            if (!dimInfo) {\n\t                throw new Error('Can not find dimension by ' + dimConfig);\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * @param {object} transformParams The parameter of echarts transfrom.\n\t     * @param {(DimensionIndex | {name: DimensionName, index: DimensionIndex})[]} dimensionsConfig\n\t     * @param {{name: DimensionName | DimensionName[], index: DimensionIndex | DimensionIndex[]}}\n\t     */\n\t    function normalizeNewDimensions(dimensionsConfig) {\n\t        if (arrayUtil.isArray(dimensionsConfig)) {\n\t            var names = [];\n\t            var indices = [];\n\t            for (var i = 0; i < dimensionsConfig.length; i++) {\n\t                var item = parseDimensionNewItem(dimensionsConfig[i]);\n\t                names.push(item.name);\n\t                indices.push(item.index);\n\t            }\n\t            return {name: names, index: indices};\n\t        }\n\t        else if (dimensionsConfig != null) {\n\t            return parseDimensionNewItem(dimensionsConfig);\n\t        }\n\n\t        function parseDimensionNewItem(dimConfig) {\n\t            if (numberUtil.isNumber(dimConfig)) {\n\t                return { index: dimConfig };\n\t            }\n\t            else if (objectUtil.isObject(dimConfig) && numberUtil.isNumber(dimConfig.index)) {\n\t                return dimConfig;\n\t            }\n\t            throw new Error('Illegle new dimensions config. Expect `{ name: string, index: number }`.');\n\t        }\n\t    }\n\n\t    return {\n\t        normalizeExistingDimensions: normalizeExistingDimensions,\n\t        normalizeNewDimensions: normalizeNewDimensions\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    function extend(target, source) {\n\t        if (Object.assign) {\n\t            Object.assign(target, source);\n\t        }\n\t        else {\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    target[key] = source[key];\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\n\t    function isObject(value) {\n\t        const type = typeof value;\n\t        return type === 'function' || (!!value && type === 'object');\n\t    }\n\n\t    return {\n\t        extend: extend,\n\t        isObject: isObject\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var histogram = __webpack_require__(15);\n\t    var transformHelper = __webpack_require__(19);\n\n\t    return {\n\n\t        type: 'ecStat:histogram',\n\n\t        /**\n\t         * @param {'squareRoot' | 'scott' | 'freedmanDiaconis' | 'sturges'} [params.config.method='squareRoot']\n\t         * @param {DimnensionLoose[]} [params.config.dimensions=[0, 1]] dimensions that used to calculate histogram.\n\t         *        By default [0].\n\t         */\n\t        transform: function transform(params) {\n\t            var upstream = params.upstream;\n\t            var config = params.config || {};\n\n\t            var result = histogram(upstream.cloneRawData(), {\n\t                method: config.method,\n\t                dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions)\n\t            });\n\n\t            return [{\n\t                dimensions: ['MeanOfV0V1', 'VCount', 'V0', 'V1', 'DisplayableName'],\n\t                data: result.data\n\t            }, {\n\t                data: result.customData\n\t            }];\n\t        }\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n\t    var clustering = __webpack_require__(1);\n\t    var numberUtil = __webpack_require__(4);\n\t    var transformHelper = __webpack_require__(19);\n\n\t    var isNumber = numberUtil.isNumber;\n\n\t    return {\n\n\t        type: 'ecStat:clustering',\n\n\t        /**\n\t         * @param {number} params.config.clusterCount Mandatory.\n\t         *        The number of clusters in a dataset. It has to be greater than 1.\n\t         * @param {(DimensionName | DimensionIndex)[]} [params.config.dimensions] Optional.\n\t         *        Target dimensions to calculate the regression.\n\t         *        By default: use all of the data.\n\t         * @param {(DimensionIndex | {name?: DimensionName, index: DimensionIndex})} [params.config.outputClusterIndexDimension] Mandatory.\n\t         * @param {(DimensionIndex | {name?: DimensionName, index: DimensionIndex})[]} [params.config.outputCentroidDimensions] Optional.\n\t         *        If specified, the centroid will be set to those dimensions of the result data one by one.\n\t         *        By default not set centroid to result.\n\t         */\n\t        transform: function transform(params) {\n\t            var upstream = params.upstream;\n\t            var config = params.config || {};\n\t            var clusterCount = config.clusterCount;\n\n\t            if (!isNumber(clusterCount) || clusterCount <= 0) {\n\t                throw new Error('config param \"clusterCount\" need to be specified as an interger greater than 1.');\n\t            }\n\n\t            if (clusterCount === 1) {\n\t                return [{\n\t                }, {\n\t                    data: []\n\t                }];\n\t            }\n\n\t            var outputClusterIndexDimension = transformHelper.normalizeNewDimensions(\n\t                config.outputClusterIndexDimension\n\t            );\n\t            var outputCentroidDimensions = transformHelper.normalizeNewDimensions(\n\t                config.outputCentroidDimensions\n\t            );\n\n\t            if (outputClusterIndexDimension == null) {\n\t                throw new Error('outputClusterIndexDimension is required as a number.');\n\t            }\n\n\t            var result = clustering.hierarchicalKMeans(upstream.cloneRawData(), {\n\t                clusterCount: clusterCount,\n\t                stepByStep: false,\n\t                dimensions: transformHelper.normalizeExistingDimensions(params, config.dimensions),\n\t                outputType: clustering.OutputType.SINGLE,\n\t                outputClusterIndexDimension: outputClusterIndexDimension.index,\n\t                outputCentroidDimensions: (outputCentroidDimensions || {}).index\n\t            });\n\n\t            var sourceDimAll = upstream.cloneAllDimensionInfo();\n\t            var resultDimsDef = [];\n\t            for (var i = 0; i < sourceDimAll.length; i++) {\n\t                var sourceDimItem = sourceDimAll[i];\n\t                resultDimsDef.push(sourceDimItem.name);\n\t            }\n\n\t            // Always set to dims def even if name not exists, because the resultDimsDef.length\n\t            // need to be enlarged to tell echarts that there is \"cluster index dimension\" and \"dist dimension\".\n\t            resultDimsDef[outputClusterIndexDimension.index] = outputClusterIndexDimension.name;\n\n\t            if (outputCentroidDimensions) {\n\t                for (var i = 0; i < outputCentroidDimensions.index.length; i++) {\n\t                    if (outputCentroidDimensions.name[i] != null) {\n\t                        resultDimsDef[outputCentroidDimensions.index[i]] = outputCentroidDimensions.name[i];\n\t                    }\n\t                }\n\t            }\n\n\t            return [{\n\t                dimensions: resultDimsDef,\n\t                data: result.data\n\t            }, {\n\t                data: result.centroids\n\t            }];\n\t        }\n\t    };\n\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ })\n/******/ ])\n});\n;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}