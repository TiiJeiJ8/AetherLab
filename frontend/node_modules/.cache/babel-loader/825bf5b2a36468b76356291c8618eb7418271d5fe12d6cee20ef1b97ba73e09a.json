{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n  return data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 前向查找\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      // 后向查找\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 距离更近的邻居\n        result[i] = i - prev <= next - i ? result[prev] : result[next];\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 找前一个和后一个非空\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 线性插值\n        result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n  // 首先构造自然三次样条的求解函数\n  function cubicSplineCoefficients(x, y) {\n    const n = x.length;\n    const a = y.slice();\n    const h = new Array(n - 1);\n    const alpha = new Array(n - 1);\n    for (let i = 0; i < n - 1; i++) {\n      h[i] = x[i + 1] - x[i];\n      if (h[i] <= 0) {\n        throw new Error('x values must be strictly increasing');\n      }\n      alpha[i] = 3 / h[i] * (a[i + 1] - a[i]) - 3 / h[i - 1 || 1] * (a[i] - a[i - 1 || 0]);\n    }\n    const l = [1],\n      mu = [0],\n      z = [0];\n    for (let i = 1; i < n - 1; i++) {\n      l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n      mu[i] = h[i] / l[i];\n      z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n    }\n    l[n - 1] = 1;\n    z[n - 1] = 0;\n    const c = Array(n).fill(0);\n    const b = Array(n - 1);\n    const d = Array(n - 1);\n    for (let j = n - 2; j >= 0; j--) {\n      c[j] = z[j] - mu[j] * c[j + 1];\n      b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n      d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n    }\n    return {\n      a,\n      b,\n      c,\n      d,\n      x\n    };\n  }\n\n  // 然后构造样条插值函数\n  function cubicSplineInterpolate(xi, coefs) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      x\n    } = coefs;\n    let i = x.length - 2;\n    for (let j = 0; j < x.length - 1; j++) {\n      if (xi >= x[j] && xi <= x[j + 1]) {\n        i = j;\n        break;\n      }\n    }\n    const dx = xi - x[i];\n    return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n  }\n  console.log('[fillCubicSpline] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  if (valid.length < 3) {\n    console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n    return result;\n  }\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const coefs = cubicSplineCoefficients(x, y);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      result[i] = cubicSplineInterpolate(i, coefs);\n    }\n  }\n  return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n  console.log('[fillPolynomial] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  function lagrange(x) {\n    let y = 0;\n    for (let i = 0; i < n; i++) {\n      let term = valid[i].y;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n        }\n      }\n      y += term;\n    }\n    return y;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lagrange(i);\n    }\n  }\n  return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n  console.log('[fillStepBefore] method is working');\n  const result = [...data];\n  const lastVal = null;\n  for (let i = 1; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n  console.log('[fillStepAfter] method is working');\n  const result = [...data];\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n  console.log('[fillBasis] method is working');\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n  console.log('[fillCardinal] method is working');\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n  console.log('[fillMonotone] method is working');\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n  console.log('[fillAkima] method is working');\n}","map":{"version":3,"names":["getValidPoints","data","map","y","x","filter","p","isNaN","ignoreNull","console","log","fillZero","v","undefined","Number","fillNearest","result","i","length","prev","next","linearInterpolate","fillCubicSpline","cubicSplineCoefficients","n","a","slice","h","Array","alpha","Error","l","mu","z","c","fill","b","d","j","cubicSplineInterpolate","xi","coefs","dx","valid","warn","fillPolynomial","lagrange","term","fillStepBefore","lastVal","fillStepAfter","fillBasis","fillCardinal","fillMonotone","fillAkima"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n    return data.map((y, x) => ({ x, y })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 前向查找\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            // 后向查找\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 距离更近的邻居\n                result[i] = (i - prev <= next - i) ? result[prev] : result[next];\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 找前一个和后一个非空\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 线性插值\n                result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n    // 首先构造自然三次样条的求解函数\n    function cubicSplineCoefficients(x, y) {\n        const n = x.length;\n        const a = y.slice();\n        const h = new Array(n - 1);\n        const alpha = new Array(n - 1);\n\n        for (let i = 0; i < n - 1; i++) {\n            h[i] = x[i + 1] - x[i];\n            if (h[i] <= 0) {\n                throw new Error('x values must be strictly increasing');\n            }\n            alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1 || 1]) * (a[i] - a[i - 1 || 0]);\n        }\n\n        const l = [1], mu = [0], z = [0];\n        for (let i = 1; i < n - 1; i++) {\n            l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n            mu[i] = h[i] / l[i];\n            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n        }\n        l[n - 1] = 1;\n        z[n - 1] = 0;\n\n        const c = Array(n).fill(0);\n        const b = Array(n - 1);\n        const d = Array(n - 1);\n\n        for (let j = n - 2; j >= 0; j--) {\n            c[j] = z[j] - mu[j] * c[j + 1];\n            b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n            d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n        }\n        return { a, b, c, d, x };\n    }\n\n    // 然后构造样条插值函数\n    function cubicSplineInterpolate(xi, coefs) {\n        const { a, b, c, d, x } = coefs;\n        let i = x.length - 2;\n\n        for (let j = 0; j < x.length - 1; j++) {\n            if (xi >= x[j] && xi <= x[j + 1]) {\n                i = j;\n                break;\n            }\n        }\n\n        const dx = xi - x[i];\n        return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n    }\n\n    console.log('[fillCubicSpline] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n\n    if (valid.length < 3) {\n        console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n        return result;\n    }\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const coefs = cubicSplineCoefficients(x, y);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            result[i] = cubicSplineInterpolate(i, coefs);\n        }\n    }\n\n    return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n    console.log('[fillPolynomial] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n    function lagrange(x) {\n        let y = 0;\n        for (let i = 0; i < n; i++) {\n            let term = valid[i].y;\n            for (let j = 0; j < n; j++) {\n                if (i !== j) {\n                    term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n                }\n            }\n            y += term;\n        }\n        return y;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lagrange(i);\n        }\n    }\n    return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n    console.log('[fillStepBefore] method is working');\n    const result = [...data];\n    const lastVal = null;\n    for (let i = 1; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n    console.log('[fillStepAfter] method is working');\n    const result = [...data];\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n    console.log('[fillBasis] method is working');\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n    console.log('[fillCardinal] method is working');\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n    console.log('[fillMonotone] method is working');\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n    console.log('[fillAkima] method is working');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}