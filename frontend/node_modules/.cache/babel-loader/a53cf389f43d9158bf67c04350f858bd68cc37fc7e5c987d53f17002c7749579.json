{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/**\n * 数据类型定义和验证\n * 这个文件定义了数据字段的类型和验证规则\n */\n\n// 数据类型枚举\nexport const DATA_TYPES = {\n  // 基础数据类型\n  CATEGORY: 'category',\n  // 分类数据（字符串）\n  NUMERIC: 'numeric',\n  // 数值数据\n  TEMPORAL: 'temporal',\n  // 时间数据\n  BOOLEAN: 'boolean',\n  // 布尔数据\n\n  // 扩展数据类型\n  DIMENSION: 'dimension',\n  // 维度数据（用于分组）\n  MEASURE: 'measure',\n  // 度量数据（用于计算）\n  IDENTIFIER: 'identifier',\n  // 标识符数据\n  GEOSPATIAL: 'geospatial',\n  // 地理空间数据\n\n  // 复合数据类型\n  MULTI_CATEGORY: 'multi_category',\n  // 多分类数据\n  HIERARCHICAL: 'hierarchical',\n  // 层级数据\n  NETWORK: 'network',\n  // 网络数据\n  TIME_SERIES: 'time_series' // 时间序列数据\n};\n\n// 数据字段角色\nexport const FIELD_ROLES = {\n  X_AXIS: 'x_axis',\n  Y_AXIS: 'y_axis',\n  VALUE: 'value',\n  DIMENSION: 'dimension',\n  MEASURE: 'measure',\n  SIZE: 'size',\n  COLOR: 'color',\n  LABEL: 'label',\n  TOOLTIP: 'tooltip',\n  FACET: 'facet',\n  SERIES: 'series',\n  PARENT: 'parent',\n  CHILD: 'child',\n  SOURCE: 'source',\n  TARGET: 'target',\n  WEIGHT: 'weight',\n  START_TIME: 'start_time',\n  END_TIME: 'end_time',\n  LONGITUDE: 'longitude',\n  LATITUDE: 'latitude',\n  REGION: 'region'\n};\n\n// 数据类型检测规则\nexport const DATA_TYPE_PATTERNS = {\n  [DATA_TYPES.NUMERIC]: {\n    patterns: [/^-?\\d+(\\.\\d+)?$/, /^-?\\d+[eE][+-]?\\d+$/],\n    validators: [value => !isNaN(parseFloat(value)) && isFinite(value)]\n  },\n  [DATA_TYPES.TEMPORAL]: {\n    patterns: [/^\\d{4}-\\d{2}-\\d{2}$/,\n    // YYYY-MM-DD\n    /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/,\n    // ISO 8601\n    /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n    // MM/DD/YYYY\n    /^\\d{1,2}-\\d{1,2}-\\d{4}$/ // MM-DD-YYYY\n    ],\n    validators: [value => !isNaN(Date.parse(value))]\n  },\n  [DATA_TYPES.BOOLEAN]: {\n    patterns: [/^(true|false)$/i, /^(yes|no)$/i, /^(1|0)$/],\n    validators: [value => ['true', 'false', 'yes', 'no', '1', '0'].includes(value.toLowerCase())]\n  },\n  [DATA_TYPES.GEOSPATIAL]: {\n    patterns: [/^-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?$/,\n    // lat,lng\n    /^POINT\\s*\\(/i,\n    // WKT Point\n    /^POLYGON\\s*\\(/i // WKT Polygon\n    ],\n    validators: [value => {\n      const coords = value.split(',');\n      return coords.length === 2 && !isNaN(parseFloat(coords[0])) && !isNaN(parseFloat(coords[1]));\n    }]\n  }\n};\n\n// 数据类型推断\nexport function inferDataType(values) {\n  if (!values || values.length === 0) return DATA_TYPES.CATEGORY;\n\n  // 过滤掉空值\n  const nonNullValues = values.filter(v => v !== null && v !== undefined && v !== '');\n  if (nonNullValues.length === 0) return DATA_TYPES.CATEGORY;\n  const sampleSize = Math.min(nonNullValues.length, 100);\n  const sample = nonNullValues.slice(0, sampleSize);\n\n  // 检查数值类型\n  const numericCount = sample.filter(v => DATA_TYPE_PATTERNS[DATA_TYPES.NUMERIC].validators.some(validator => validator(v))).length;\n  if (numericCount / sample.length > 0.8) {\n    return DATA_TYPES.NUMERIC;\n  }\n\n  // 检查时间类型\n  const temporalCount = sample.filter(v => DATA_TYPE_PATTERNS[DATA_TYPES.TEMPORAL].validators.some(validator => validator(v))).length;\n  if (temporalCount / sample.length > 0.8) {\n    return DATA_TYPES.TEMPORAL;\n  }\n\n  // 检查布尔类型\n  const booleanCount = sample.filter(v => DATA_TYPE_PATTERNS[DATA_TYPES.BOOLEAN].validators.some(validator => validator(v))).length;\n  if (booleanCount / sample.length > 0.8) {\n    return DATA_TYPES.BOOLEAN;\n  }\n\n  // 检查地理空间类型\n  const geospatialCount = sample.filter(v => DATA_TYPE_PATTERNS[DATA_TYPES.GEOSPATIAL].validators.some(validator => validator(v))).length;\n  if (geospatialCount / sample.length > 0.8) {\n    return DATA_TYPES.GEOSPATIAL;\n  }\n\n  // 检查是否为标识符（高唯一性）\n  const uniqueValues = new Set(sample);\n  if (uniqueValues.size / sample.length > 0.9) {\n    return DATA_TYPES.IDENTIFIER;\n  }\n\n  // 默认为分类数据\n  return DATA_TYPES.CATEGORY;\n}\n\n// 数据类型兼容性检查\nexport function isDataTypeCompatible(sourceType, targetType) {\n  const compatibilityMatrix = {\n    [DATA_TYPES.CATEGORY]: [DATA_TYPES.CATEGORY, DATA_TYPES.DIMENSION],\n    [DATA_TYPES.NUMERIC]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [DATA_TYPES.TEMPORAL]: [DATA_TYPES.TEMPORAL, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.BOOLEAN]: [DATA_TYPES.BOOLEAN, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.DIMENSION]: [DATA_TYPES.DIMENSION, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.MEASURE]: [DATA_TYPES.MEASURE, DATA_TYPES.NUMERIC],\n    [DATA_TYPES.IDENTIFIER]: [DATA_TYPES.IDENTIFIER, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.GEOSPATIAL]: [DATA_TYPES.GEOSPATIAL]\n  };\n  return compatibilityMatrix[sourceType]?.includes(targetType) || false;\n}\n\n// 字段角色验证\nexport function validateFieldRole(dataType, fieldRole) {\n  const roleCompatibility = {\n    [FIELD_ROLES.X_AXIS]: [DATA_TYPES.CATEGORY, DATA_TYPES.TEMPORAL, DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.Y_AXIS]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.VALUE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.DIMENSION]: [DATA_TYPES.CATEGORY, DATA_TYPES.DIMENSION],\n    [FIELD_ROLES.MEASURE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.SIZE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.COLOR]: [DATA_TYPES.CATEGORY, DATA_TYPES.NUMERIC, DATA_TYPES.DIMENSION],\n    [FIELD_ROLES.LABEL]: [DATA_TYPES.CATEGORY, DATA_TYPES.IDENTIFIER],\n    [FIELD_ROLES.TOOLTIP]: [DATA_TYPES.CATEGORY, DATA_TYPES.NUMERIC, DATA_TYPES.TEMPORAL],\n    [FIELD_ROLES.LONGITUDE]: [DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.LATITUDE]: [DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.REGION]: [DATA_TYPES.CATEGORY, DATA_TYPES.GEOSPATIAL]\n  };\n  return roleCompatibility[fieldRole]?.includes(dataType) || false;\n}\n\n// 数据类型转换建议\nexport function suggestDataTypeConversion(sourceType, targetType) {\n  const conversionMap = {\n    [`${DATA_TYPES.CATEGORY}_${DATA_TYPES.NUMERIC}`]: {\n      possible: false,\n      reason: '分类数据无法直接转换为数值'\n    },\n    [`${DATA_TYPES.NUMERIC}_${DATA_TYPES.CATEGORY}`]: {\n      possible: true,\n      method: 'toString',\n      reason: '数值可以转换为分类标签'\n    },\n    [`${DATA_TYPES.TEMPORAL}_${DATA_TYPES.NUMERIC}`]: {\n      possible: true,\n      method: 'timestamp',\n      reason: '时间可以转换为时间戳'\n    },\n    [`${DATA_TYPES.BOOLEAN}_${DATA_TYPES.NUMERIC}`]: {\n      possible: true,\n      method: 'booleanToNumber',\n      reason: '布尔值可以转换为 0/1'\n    }\n  };\n  const key = `${sourceType}_${targetType}`;\n  return conversionMap[key] || {\n    possible: false,\n    reason: '不支持的数据类型转换'\n  };\n}\n\n// 数据质量检查\nexport function checkDataQuality(values, dataType) {\n  const quality = {\n    total: values.length,\n    valid: 0,\n    invalid: 0,\n    missing: 0,\n    unique: 0,\n    duplicates: 0,\n    issues: []\n  };\n  const uniqueValues = new Set();\n  const validators = DATA_TYPE_PATTERNS[dataType]?.validators || [];\n  values.forEach(value => {\n    if (value === null || value === undefined || value === '') {\n      quality.missing++;\n      return;\n    }\n    if (uniqueValues.has(value)) {\n      quality.duplicates++;\n    } else {\n      uniqueValues.add(value);\n      quality.unique++;\n    }\n    if (validators.length === 0 || validators.some(validator => validator(value))) {\n      quality.valid++;\n    } else {\n      quality.invalid++;\n      quality.issues.push(`Invalid value: ${value}`);\n    }\n  });\n\n  // 计算质量指标\n  quality.completeness = (quality.total - quality.missing) / quality.total;\n  quality.validity = quality.valid / (quality.total - quality.missing);\n  quality.uniqueness = quality.unique / (quality.total - quality.missing);\n  return quality;\n}","map":{"version":3,"names":["DATA_TYPES","CATEGORY","NUMERIC","TEMPORAL","BOOLEAN","DIMENSION","MEASURE","IDENTIFIER","GEOSPATIAL","MULTI_CATEGORY","HIERARCHICAL","NETWORK","TIME_SERIES","FIELD_ROLES","X_AXIS","Y_AXIS","VALUE","SIZE","COLOR","LABEL","TOOLTIP","FACET","SERIES","PARENT","CHILD","SOURCE","TARGET","WEIGHT","START_TIME","END_TIME","LONGITUDE","LATITUDE","REGION","DATA_TYPE_PATTERNS","patterns","validators","value","isNaN","parseFloat","isFinite","Date","parse","includes","toLowerCase","coords","split","length","inferDataType","values","nonNullValues","filter","v","undefined","sampleSize","Math","min","sample","slice","numericCount","some","validator","temporalCount","booleanCount","geospatialCount","uniqueValues","Set","size","isDataTypeCompatible","sourceType","targetType","compatibilityMatrix","validateFieldRole","dataType","fieldRole","roleCompatibility","suggestDataTypeConversion","conversionMap","possible","reason","method","key","checkDataQuality","quality","total","valid","invalid","missing","unique","duplicates","issues","forEach","has","add","push","completeness","validity","uniqueness"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/configs/dataTypes.js"],"sourcesContent":["/**\n * 数据类型定义和验证\n * 这个文件定义了数据字段的类型和验证规则\n */\n\n// 数据类型枚举\nexport const DATA_TYPES = {\n  // 基础数据类型\n  CATEGORY: 'category', // 分类数据（字符串）\n  NUMERIC: 'numeric', // 数值数据\n  TEMPORAL: 'temporal', // 时间数据\n  BOOLEAN: 'boolean', // 布尔数据\n\n  // 扩展数据类型\n  DIMENSION: 'dimension', // 维度数据（用于分组）\n  MEASURE: 'measure', // 度量数据（用于计算）\n  IDENTIFIER: 'identifier', // 标识符数据\n  GEOSPATIAL: 'geospatial', // 地理空间数据\n\n  // 复合数据类型\n  MULTI_CATEGORY: 'multi_category', // 多分类数据\n  HIERARCHICAL: 'hierarchical', // 层级数据\n  NETWORK: 'network', // 网络数据\n  TIME_SERIES: 'time_series' // 时间序列数据\n}\n\n// 数据字段角色\nexport const FIELD_ROLES = {\n  X_AXIS: 'x_axis',\n  Y_AXIS: 'y_axis',\n  VALUE: 'value',\n  DIMENSION: 'dimension',\n  MEASURE: 'measure',\n  SIZE: 'size',\n  COLOR: 'color',\n  LABEL: 'label',\n  TOOLTIP: 'tooltip',\n  FACET: 'facet',\n  SERIES: 'series',\n  PARENT: 'parent',\n  CHILD: 'child',\n  SOURCE: 'source',\n  TARGET: 'target',\n  WEIGHT: 'weight',\n  START_TIME: 'start_time',\n  END_TIME: 'end_time',\n  LONGITUDE: 'longitude',\n  LATITUDE: 'latitude',\n  REGION: 'region'\n}\n\n// 数据类型检测规则\nexport const DATA_TYPE_PATTERNS = {\n  [DATA_TYPES.NUMERIC]: {\n    patterns: [/^-?\\d+(\\.\\d+)?$/, /^-?\\d+[eE][+-]?\\d+$/],\n    validators: [\n      (value) => !isNaN(parseFloat(value)) && isFinite(value)\n    ]\n  },\n\n  [DATA_TYPES.TEMPORAL]: {\n    patterns: [\n      /^\\d{4}-\\d{2}-\\d{2}$/, // YYYY-MM-DD\n      /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/, // ISO 8601\n      /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/, // MM/DD/YYYY\n      /^\\d{1,2}-\\d{1,2}-\\d{4}$/ // MM-DD-YYYY\n    ],\n    validators: [\n      (value) => !isNaN(Date.parse(value))\n    ]\n  },\n\n  [DATA_TYPES.BOOLEAN]: {\n    patterns: [/^(true|false)$/i, /^(yes|no)$/i, /^(1|0)$/],\n    validators: [\n      (value) => ['true', 'false', 'yes', 'no', '1', '0'].includes(value.toLowerCase())\n    ]\n  },\n\n  [DATA_TYPES.GEOSPATIAL]: {\n    patterns: [\n      /^-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?$/, // lat,lng\n      /^POINT\\s*\\(/i, // WKT Point\n      /^POLYGON\\s*\\(/i // WKT Polygon\n    ],\n    validators: [\n      (value) => {\n        const coords = value.split(',')\n        return coords.length === 2 &&\n               !isNaN(parseFloat(coords[0])) &&\n               !isNaN(parseFloat(coords[1]))\n      }\n    ]\n  }\n}\n\n// 数据类型推断\nexport function inferDataType (values) {\n  if (!values || values.length === 0) return DATA_TYPES.CATEGORY\n\n  // 过滤掉空值\n  const nonNullValues = values.filter(v => v !== null && v !== undefined && v !== '')\n  if (nonNullValues.length === 0) return DATA_TYPES.CATEGORY\n\n  const sampleSize = Math.min(nonNullValues.length, 100)\n  const sample = nonNullValues.slice(0, sampleSize)\n\n  // 检查数值类型\n  const numericCount = sample.filter(v =>\n    DATA_TYPE_PATTERNS[DATA_TYPES.NUMERIC].validators.some(validator => validator(v))\n  ).length\n\n  if (numericCount / sample.length > 0.8) {\n    return DATA_TYPES.NUMERIC\n  }\n\n  // 检查时间类型\n  const temporalCount = sample.filter(v =>\n    DATA_TYPE_PATTERNS[DATA_TYPES.TEMPORAL].validators.some(validator => validator(v))\n  ).length\n\n  if (temporalCount / sample.length > 0.8) {\n    return DATA_TYPES.TEMPORAL\n  }\n\n  // 检查布尔类型\n  const booleanCount = sample.filter(v =>\n    DATA_TYPE_PATTERNS[DATA_TYPES.BOOLEAN].validators.some(validator => validator(v))\n  ).length\n\n  if (booleanCount / sample.length > 0.8) {\n    return DATA_TYPES.BOOLEAN\n  }\n\n  // 检查地理空间类型\n  const geospatialCount = sample.filter(v =>\n    DATA_TYPE_PATTERNS[DATA_TYPES.GEOSPATIAL].validators.some(validator => validator(v))\n  ).length\n\n  if (geospatialCount / sample.length > 0.8) {\n    return DATA_TYPES.GEOSPATIAL\n  }\n\n  // 检查是否为标识符（高唯一性）\n  const uniqueValues = new Set(sample)\n  if (uniqueValues.size / sample.length > 0.9) {\n    return DATA_TYPES.IDENTIFIER\n  }\n\n  // 默认为分类数据\n  return DATA_TYPES.CATEGORY\n}\n\n// 数据类型兼容性检查\nexport function isDataTypeCompatible (sourceType, targetType) {\n  const compatibilityMatrix = {\n    [DATA_TYPES.CATEGORY]: [DATA_TYPES.CATEGORY, DATA_TYPES.DIMENSION],\n    [DATA_TYPES.NUMERIC]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [DATA_TYPES.TEMPORAL]: [DATA_TYPES.TEMPORAL, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.BOOLEAN]: [DATA_TYPES.BOOLEAN, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.DIMENSION]: [DATA_TYPES.DIMENSION, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.MEASURE]: [DATA_TYPES.MEASURE, DATA_TYPES.NUMERIC],\n    [DATA_TYPES.IDENTIFIER]: [DATA_TYPES.IDENTIFIER, DATA_TYPES.CATEGORY],\n    [DATA_TYPES.GEOSPATIAL]: [DATA_TYPES.GEOSPATIAL]\n  }\n\n  return compatibilityMatrix[sourceType]?.includes(targetType) || false\n}\n\n// 字段角色验证\nexport function validateFieldRole (dataType, fieldRole) {\n  const roleCompatibility = {\n    [FIELD_ROLES.X_AXIS]: [DATA_TYPES.CATEGORY, DATA_TYPES.TEMPORAL, DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.Y_AXIS]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.VALUE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.DIMENSION]: [DATA_TYPES.CATEGORY, DATA_TYPES.DIMENSION],\n    [FIELD_ROLES.MEASURE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.SIZE]: [DATA_TYPES.NUMERIC, DATA_TYPES.MEASURE],\n    [FIELD_ROLES.COLOR]: [DATA_TYPES.CATEGORY, DATA_TYPES.NUMERIC, DATA_TYPES.DIMENSION],\n    [FIELD_ROLES.LABEL]: [DATA_TYPES.CATEGORY, DATA_TYPES.IDENTIFIER],\n    [FIELD_ROLES.TOOLTIP]: [DATA_TYPES.CATEGORY, DATA_TYPES.NUMERIC, DATA_TYPES.TEMPORAL],\n    [FIELD_ROLES.LONGITUDE]: [DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.LATITUDE]: [DATA_TYPES.NUMERIC],\n    [FIELD_ROLES.REGION]: [DATA_TYPES.CATEGORY, DATA_TYPES.GEOSPATIAL]\n  }\n\n  return roleCompatibility[fieldRole]?.includes(dataType) || false\n}\n\n// 数据类型转换建议\nexport function suggestDataTypeConversion (sourceType, targetType) {\n  const conversionMap = {\n    [`${DATA_TYPES.CATEGORY}_${DATA_TYPES.NUMERIC}`]: {\n      possible: false,\n      reason: '分类数据无法直接转换为数值'\n    },\n    [`${DATA_TYPES.NUMERIC}_${DATA_TYPES.CATEGORY}`]: {\n      possible: true,\n      method: 'toString',\n      reason: '数值可以转换为分类标签'\n    },\n    [`${DATA_TYPES.TEMPORAL}_${DATA_TYPES.NUMERIC}`]: {\n      possible: true,\n      method: 'timestamp',\n      reason: '时间可以转换为时间戳'\n    },\n    [`${DATA_TYPES.BOOLEAN}_${DATA_TYPES.NUMERIC}`]: {\n      possible: true,\n      method: 'booleanToNumber',\n      reason: '布尔值可以转换为 0/1'\n    }\n  }\n\n  const key = `${sourceType}_${targetType}`\n  return conversionMap[key] || {\n    possible: false,\n    reason: '不支持的数据类型转换'\n  }\n}\n\n// 数据质量检查\nexport function checkDataQuality (values, dataType) {\n  const quality = {\n    total: values.length,\n    valid: 0,\n    invalid: 0,\n    missing: 0,\n    unique: 0,\n    duplicates: 0,\n    issues: []\n  }\n\n  const uniqueValues = new Set()\n  const validators = DATA_TYPE_PATTERNS[dataType]?.validators || []\n\n  values.forEach(value => {\n    if (value === null || value === undefined || value === '') {\n      quality.missing++\n      return\n    }\n\n    if (uniqueValues.has(value)) {\n      quality.duplicates++\n    } else {\n      uniqueValues.add(value)\n      quality.unique++\n    }\n\n    if (validators.length === 0 || validators.some(validator => validator(value))) {\n      quality.valid++\n    } else {\n      quality.invalid++\n      quality.issues.push(`Invalid value: ${value}`)\n    }\n  })\n\n  // 计算质量指标\n  quality.completeness = (quality.total - quality.missing) / quality.total\n  quality.validity = quality.valid / (quality.total - quality.missing)\n  quality.uniqueness = quality.unique / (quality.total - quality.missing)\n\n  return quality\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}