{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref } from 'vue';\nexport function useFileStructure() {\n  const isAnalyzing = ref(false);\n\n  // 分析文件结构\n  async function analyzeFileStructure(file) {\n    isAnalyzing.value = true;\n    try {\n      // 模拟文件分析过程\n      const fileContent = await readFileContent(file);\n      const structure = await parseFileStructure(fileContent, file.type);\n\n      // 更新文件对象\n      file.columns = structure.columns;\n      file.rowCount = structure.rowCount;\n      file.previewData = structure.previewData;\n      return structure;\n    } catch (error) {\n      console.error('Failed to analyze file structure:', error);\n      throw error;\n    } finally {\n      isAnalyzing.value = false;\n    }\n  }\n\n  // 读取文件内容\n  async function readFileContent(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = e => {\n        resolve(e.target.result);\n      };\n      reader.onerror = e => {\n        reject(new Error('Failed to read file'));\n      };\n      reader.readAsText(file.file || file);\n    });\n  }\n\n  // 解析文件结构\n  async function parseFileStructure(content, fileType) {\n    const extension = fileType || 'csv';\n    switch (extension.toLowerCase()) {\n      case 'csv':\n        return parseCSV(content);\n      case 'json':\n        return parseJSON(content);\n      case 'xlsx':\n      case 'xls':\n        return parseExcel(content);\n      default:\n        return parseCSV(content);\n      // 默认按CSV处理\n    }\n  }\n\n  // 解析CSV文件\n  function parseCSV(content) {\n    const lines = content.split('\\n').filter(line => line.trim());\n    if (lines.length === 0) {\n      throw new Error('File is empty');\n    }\n\n    // 解析表头\n    const headers = parseCSVLine(lines[0]);\n\n    // 解析数据行\n    const rows = lines.slice(1).map(line => parseCSVLine(line));\n\n    // 分析列结构\n    const columns = headers.map((header, index) => {\n      const columnValues = rows.map(row => row[index]).filter(val => val !== '' && val !== null && val !== undefined);\n      return {\n        name: header,\n        type: detectColumnType(columnValues),\n        nonNullCount: columnValues.length,\n        uniqueCount: new Set(columnValues).size,\n        samples: columnValues.slice(0, 5)\n      };\n    });\n\n    // 转换为对象数组\n    const previewData = rows.slice(0, 100).map(row => {\n      const obj = {};\n      headers.forEach((header, index) => {\n        obj[header] = row[index];\n      });\n      return obj;\n    });\n    return {\n      columns,\n      rowCount: rows.length,\n      previewData\n    };\n  }\n\n  // 解析CSV行\n  function parseCSVLine(line) {\n    const result = [];\n    let current = '';\n    let inQuotes = false;\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n      if (char === '\"') {\n        inQuotes = !inQuotes;\n      } else if (char === ',' && !inQuotes) {\n        result.push(current.trim());\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n    result.push(current.trim());\n    return result;\n  }\n\n  // 解析JSON文件\n  function parseJSON(content) {\n    try {\n      const data = JSON.parse(content);\n      if (!Array.isArray(data)) {\n        throw new Error('JSON must be an array of objects');\n      }\n      if (data.length === 0) {\n        throw new Error('JSON array is empty');\n      }\n\n      // 获取所有可能的列名\n      const allKeys = new Set();\n      data.forEach(item => {\n        Object.keys(item).forEach(key => allKeys.add(key));\n      });\n      const columns = Array.from(allKeys).map(key => {\n        const columnValues = data.map(item => item[key]).filter(val => val !== null && val !== undefined);\n        return {\n          name: key,\n          type: detectColumnType(columnValues),\n          nonNullCount: columnValues.length,\n          uniqueCount: new Set(columnValues).size,\n          samples: columnValues.slice(0, 5)\n        };\n      });\n      return {\n        columns,\n        rowCount: data.length,\n        previewData: data.slice(0, 100)\n      };\n    } catch (error) {\n      throw new Error('Invalid JSON format: ' + error.message);\n    }\n  }\n\n  // 解析Excel文件（需要第三方库，这里提供接口）\n  async function parseExcel(content) {\n    // 这里需要使用xlsx库或类似的工具\n    // 由于是前端解析，需要额外的依赖\n    throw new Error('Excel parsing not implemented yet. Please convert to CSV or JSON.');\n  }\n\n  // 检测列数据类型\n  function detectColumnType(values) {\n    if (values.length === 0) return 'unknown';\n    const sampleSize = Math.min(values.length, 20);\n    const samples = values.slice(0, sampleSize);\n    let numberCount = 0;\n    let integerCount = 0;\n    let booleanCount = 0;\n    let dateCount = 0;\n    samples.forEach(value => {\n      const str = String(value).trim();\n\n      // 检查是否为数字\n      if (!isNaN(str) && str !== '') {\n        numberCount++;\n        if (Number.isInteger(parseFloat(str))) {\n          integerCount++;\n        }\n      }\n\n      // 检查是否为布尔值\n      if (str.toLowerCase() === 'true' || str.toLowerCase() === 'false') {\n        booleanCount++;\n      }\n\n      // 检查是否为日期\n      if (isValidDate(str)) {\n        dateCount++;\n      }\n    });\n    const threshold = sampleSize * 0.8;\n    if (booleanCount >= threshold) return 'boolean';\n    if (dateCount >= threshold) return 'date';\n    if (integerCount >= threshold) return 'integer';\n    if (numberCount >= threshold) return 'number';\n    return 'string';\n  }\n\n  // 检查是否为有效日期\n  function isValidDate(dateString) {\n    const date = new Date(dateString);\n    return !isNaN(date.getTime()) && dateString.length > 6;\n  }\n\n  // 格式化文件大小\n  function formatFileSize(bytes) {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // 导出文件结构\n  function exportStructure(file) {\n    const structure = {\n      fileName: file.name,\n      fileSize: file.size,\n      rowCount: file.rowCount,\n      columns: file.columns,\n      exportTime: new Date().toISOString()\n    };\n    const blob = new Blob([JSON.stringify(structure, null, 2)], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `${file.name}_structure.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n\n  // 合并多个文件的数据\n  function mergeFilesData(files, mappedColumns) {\n    const mergedData = [];\n\n    // 获取所有需要的列\n    const requiredColumns = new Set();\n    Object.values(mappedColumns).forEach(columnList => {\n      columnList.forEach(col => {\n        requiredColumns.add(`${col.fileId}_${col.columnName}`);\n      });\n    });\n\n    // 找到最大行数\n    const maxRows = Math.max(...files.map(file => file.previewData?.length || 0));\n\n    // 按行合并数据\n    for (let i = 0; i < maxRows; i++) {\n      const mergedRow = {};\n      files.forEach(file => {\n        if (file.previewData && file.previewData[i]) {\n          const row = file.previewData[i];\n          Object.keys(row).forEach(columnName => {\n            const key = `${file.id}_${columnName}`;\n            if (requiredColumns.has(key)) {\n              mergedRow[columnName] = row[columnName];\n            }\n          });\n        }\n      });\n\n      // 只有当行包含必需的数据时才添加\n      if (Object.keys(mergedRow).length > 0) {\n        mergedData.push(mergedRow);\n      }\n    }\n    return mergedData;\n  }\n\n  // 验证数据映射\n  function validateMapping(mappedColumns, files) {\n    const errors = [];\n    Object.entries(mappedColumns).forEach(([configKey, columnList]) => {\n      columnList.forEach(col => {\n        const file = files.find(f => f.id === col.fileId);\n        if (!file) {\n          errors.push(`File not found for column: ${col.columnName}`);\n          return;\n        }\n        const column = file.columns?.find(c => c.name === col.columnName);\n        if (!column) {\n          errors.push(`Column not found: ${col.columnName} in file ${file.name}`);\n        }\n      });\n    });\n    return errors;\n  }\n  return {\n    isAnalyzing,\n    analyzeFileStructure,\n    formatFileSize,\n    exportStructure,\n    mergeFilesData,\n    validateMapping,\n    detectColumnType\n  };\n}","map":{"version":3,"names":["ref","useFileStructure","isAnalyzing","analyzeFileStructure","file","value","fileContent","readFileContent","structure","parseFileStructure","type","columns","rowCount","previewData","error","console","Promise","resolve","reject","reader","FileReader","onload","e","target","result","onerror","Error","readAsText","content","fileType","extension","toLowerCase","parseCSV","parseJSON","parseExcel","lines","split","filter","line","trim","length","headers","parseCSVLine","rows","slice","map","header","index","columnValues","row","val","undefined","name","detectColumnType","nonNullCount","uniqueCount","Set","size","samples","obj","forEach","current","inQuotes","i","char","push","data","JSON","parse","Array","isArray","allKeys","item","Object","keys","key","add","from","message","values","sampleSize","Math","min","numberCount","integerCount","booleanCount","dateCount","str","String","isNaN","Number","isInteger","parseFloat","isValidDate","threshold","dateString","date","Date","getTime","formatFileSize","bytes","k","sizes","floor","log","pow","toFixed","exportStructure","fileName","fileSize","exportTime","toISOString","blob","Blob","stringify","url","URL","createObjectURL","a","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","mergeFilesData","files","mappedColumns","mergedData","requiredColumns","columnList","col","fileId","columnName","maxRows","max","mergedRow","id","has","validateMapping","errors","entries","configKey","find","f","column","c"],"sources":["D:/Learning Material/Git/Fuck-Charts/newArchitecture/frontend_vue_design/src/composables/useFileStructure.js"],"sourcesContent":["import { ref } from 'vue'\n\nexport function useFileStructure () {\n  const isAnalyzing = ref(false)\n\n  // 分析文件结构\n  async function analyzeFileStructure (file) {\n    isAnalyzing.value = true\n\n    try {\n      // 模拟文件分析过程\n      const fileContent = await readFileContent(file)\n      const structure = await parseFileStructure(fileContent, file.type)\n\n      // 更新文件对象\n      file.columns = structure.columns\n      file.rowCount = structure.rowCount\n      file.previewData = structure.previewData\n\n      return structure\n    } catch (error) {\n      console.error('Failed to analyze file structure:', error)\n      throw error\n    } finally {\n      isAnalyzing.value = false\n    }\n  }\n\n  // 读取文件内容\n  async function readFileContent (file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n\n      reader.onload = (e) => {\n        resolve(e.target.result)\n      }\n\n      reader.onerror = (e) => {\n        reject(new Error('Failed to read file'))\n      }\n\n      reader.readAsText(file.file || file)\n    })\n  }\n\n  // 解析文件结构\n  async function parseFileStructure (content, fileType) {\n    const extension = fileType || 'csv'\n\n    switch (extension.toLowerCase()) {\n      case 'csv':\n        return parseCSV(content)\n      case 'json':\n        return parseJSON(content)\n      case 'xlsx':\n      case 'xls':\n        return parseExcel(content)\n      default:\n        return parseCSV(content) // 默认按CSV处理\n    }\n  }\n\n  // 解析CSV文件\n  function parseCSV (content) {\n    const lines = content.split('\\n').filter(line => line.trim())\n    if (lines.length === 0) {\n      throw new Error('File is empty')\n    }\n\n    // 解析表头\n    const headers = parseCSVLine(lines[0])\n\n    // 解析数据行\n    const rows = lines.slice(1).map(line => parseCSVLine(line))\n\n    // 分析列结构\n    const columns = headers.map((header, index) => {\n      const columnValues = rows.map(row => row[index]).filter(val => val !== '' && val !== null && val !== undefined)\n\n      return {\n        name: header,\n        type: detectColumnType(columnValues),\n        nonNullCount: columnValues.length,\n        uniqueCount: new Set(columnValues).size,\n        samples: columnValues.slice(0, 5)\n      }\n    })\n\n    // 转换为对象数组\n    const previewData = rows.slice(0, 100).map(row => {\n      const obj = {}\n      headers.forEach((header, index) => {\n        obj[header] = row[index]\n      })\n      return obj\n    })\n\n    return {\n      columns,\n      rowCount: rows.length,\n      previewData\n    }\n  }\n\n  // 解析CSV行\n  function parseCSVLine (line) {\n    const result = []\n    let current = ''\n    let inQuotes = false\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i]\n\n      if (char === '\"') {\n        inQuotes = !inQuotes\n      } else if (char === ',' && !inQuotes) {\n        result.push(current.trim())\n        current = ''\n      } else {\n        current += char\n      }\n    }\n\n    result.push(current.trim())\n    return result\n  }\n\n  // 解析JSON文件\n  function parseJSON (content) {\n    try {\n      const data = JSON.parse(content)\n\n      if (!Array.isArray(data)) {\n        throw new Error('JSON must be an array of objects')\n      }\n\n      if (data.length === 0) {\n        throw new Error('JSON array is empty')\n      }\n\n      // 获取所有可能的列名\n      const allKeys = new Set()\n      data.forEach(item => {\n        Object.keys(item).forEach(key => allKeys.add(key))\n      })\n\n      const columns = Array.from(allKeys).map(key => {\n        const columnValues = data.map(item => item[key]).filter(val => val !== null && val !== undefined)\n\n        return {\n          name: key,\n          type: detectColumnType(columnValues),\n          nonNullCount: columnValues.length,\n          uniqueCount: new Set(columnValues).size,\n          samples: columnValues.slice(0, 5)\n        }\n      })\n\n      return {\n        columns,\n        rowCount: data.length,\n        previewData: data.slice(0, 100)\n      }\n    } catch (error) {\n      throw new Error('Invalid JSON format: ' + error.message)\n    }\n  }\n\n  // 解析Excel文件（需要第三方库，这里提供接口）\n  async function parseExcel (content) {\n    // 这里需要使用xlsx库或类似的工具\n    // 由于是前端解析，需要额外的依赖\n    throw new Error('Excel parsing not implemented yet. Please convert to CSV or JSON.')\n  }\n\n  // 检测列数据类型\n  function detectColumnType (values) {\n    if (values.length === 0) return 'unknown'\n\n    const sampleSize = Math.min(values.length, 20)\n    const samples = values.slice(0, sampleSize)\n\n    let numberCount = 0\n    let integerCount = 0\n    let booleanCount = 0\n    let dateCount = 0\n\n    samples.forEach(value => {\n      const str = String(value).trim()\n\n      // 检查是否为数字\n      if (!isNaN(str) && str !== '') {\n        numberCount++\n        if (Number.isInteger(parseFloat(str))) {\n          integerCount++\n        }\n      }\n\n      // 检查是否为布尔值\n      if (str.toLowerCase() === 'true' || str.toLowerCase() === 'false') {\n        booleanCount++\n      }\n\n      // 检查是否为日期\n      if (isValidDate(str)) {\n        dateCount++\n      }\n    })\n\n    const threshold = sampleSize * 0.8\n\n    if (booleanCount >= threshold) return 'boolean'\n    if (dateCount >= threshold) return 'date'\n    if (integerCount >= threshold) return 'integer'\n    if (numberCount >= threshold) return 'number'\n\n    return 'string'\n  }\n\n  // 检查是否为有效日期\n  function isValidDate (dateString) {\n    const date = new Date(dateString)\n    return !isNaN(date.getTime()) && dateString.length > 6\n  }\n\n  // 格式化文件大小\n  function formatFileSize (bytes) {\n    if (bytes === 0) return '0 B'\n\n    const k = 1024\n    const sizes = ['B', 'KB', 'MB', 'GB']\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n  }\n\n  // 导出文件结构\n  function exportStructure (file) {\n    const structure = {\n      fileName: file.name,\n      fileSize: file.size,\n      rowCount: file.rowCount,\n      columns: file.columns,\n      exportTime: new Date().toISOString()\n    }\n\n    const blob = new Blob([JSON.stringify(structure, null, 2)], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `${file.name}_structure.json`\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n  }\n\n  // 合并多个文件的数据\n  function mergeFilesData (files, mappedColumns) {\n    const mergedData = []\n\n    // 获取所有需要的列\n    const requiredColumns = new Set()\n    Object.values(mappedColumns).forEach(columnList => {\n      columnList.forEach(col => {\n        requiredColumns.add(`${col.fileId}_${col.columnName}`)\n      })\n    })\n\n    // 找到最大行数\n    const maxRows = Math.max(...files.map(file => file.previewData?.length || 0))\n\n    // 按行合并数据\n    for (let i = 0; i < maxRows; i++) {\n      const mergedRow = {}\n\n      files.forEach(file => {\n        if (file.previewData && file.previewData[i]) {\n          const row = file.previewData[i]\n          Object.keys(row).forEach(columnName => {\n            const key = `${file.id}_${columnName}`\n            if (requiredColumns.has(key)) {\n              mergedRow[columnName] = row[columnName]\n            }\n          })\n        }\n      })\n\n      // 只有当行包含必需的数据时才添加\n      if (Object.keys(mergedRow).length > 0) {\n        mergedData.push(mergedRow)\n      }\n    }\n\n    return mergedData\n  }\n\n  // 验证数据映射\n  function validateMapping (mappedColumns, files) {\n    const errors = []\n\n    Object.entries(mappedColumns).forEach(([configKey, columnList]) => {\n      columnList.forEach(col => {\n        const file = files.find(f => f.id === col.fileId)\n        if (!file) {\n          errors.push(`File not found for column: ${col.columnName}`)\n          return\n        }\n\n        const column = file.columns?.find(c => c.name === col.columnName)\n        if (!column) {\n          errors.push(`Column not found: ${col.columnName} in file ${file.name}`)\n        }\n      })\n    })\n\n    return errors\n  }\n\n  return {\n    isAnalyzing,\n    analyzeFileStructure,\n    formatFileSize,\n    exportStructure,\n    mergeFilesData,\n    validateMapping,\n    detectColumnType\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAAA,SAASA,GAAG,QAAQ,KAAK;AAEzB,OAAO,SAASC,gBAAgBA,CAAA,EAAI;EAClC,MAAMC,WAAW,GAAGF,GAAG,CAAC,KAAK,CAAC;;EAE9B;EACA,eAAeG,oBAAoBA,CAAEC,IAAI,EAAE;IACzCF,WAAW,CAACG,KAAK,GAAG,IAAI;IAExB,IAAI;MACF;MACA,MAAMC,WAAW,GAAG,MAAMC,eAAe,CAACH,IAAI,CAAC;MAC/C,MAAMI,SAAS,GAAG,MAAMC,kBAAkB,CAACH,WAAW,EAAEF,IAAI,CAACM,IAAI,CAAC;;MAElE;MACAN,IAAI,CAACO,OAAO,GAAGH,SAAS,CAACG,OAAO;MAChCP,IAAI,CAACQ,QAAQ,GAAGJ,SAAS,CAACI,QAAQ;MAClCR,IAAI,CAACS,WAAW,GAAGL,SAAS,CAACK,WAAW;MAExC,OAAOL,SAAS;IAClB,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,MAAMA,KAAK;IACb,CAAC,SAAS;MACRZ,WAAW,CAACG,KAAK,GAAG,KAAK;IAC3B;EACF;;EAEA;EACA,eAAeE,eAAeA,CAAEH,IAAI,EAAE;IACpC,OAAO,IAAIY,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAE/BD,MAAM,CAACE,MAAM,GAAIC,CAAC,IAAK;QACrBL,OAAO,CAACK,CAAC,CAACC,MAAM,CAACC,MAAM,CAAC;MAC1B,CAAC;MAEDL,MAAM,CAACM,OAAO,GAAIH,CAAC,IAAK;QACtBJ,MAAM,CAAC,IAAIQ,KAAK,CAAC,qBAAqB,CAAC,CAAC;MAC1C,CAAC;MAEDP,MAAM,CAACQ,UAAU,CAACvB,IAAI,CAACA,IAAI,IAAIA,IAAI,CAAC;IACtC,CAAC,CAAC;EACJ;;EAEA;EACA,eAAeK,kBAAkBA,CAAEmB,OAAO,EAAEC,QAAQ,EAAE;IACpD,MAAMC,SAAS,GAAGD,QAAQ,IAAI,KAAK;IAEnC,QAAQC,SAAS,CAACC,WAAW,CAAC,CAAC;MAC7B,KAAK,KAAK;QACR,OAAOC,QAAQ,CAACJ,OAAO,CAAC;MAC1B,KAAK,MAAM;QACT,OAAOK,SAAS,CAACL,OAAO,CAAC;MAC3B,KAAK,MAAM;MACX,KAAK,KAAK;QACR,OAAOM,UAAU,CAACN,OAAO,CAAC;MAC5B;QACE,OAAOI,QAAQ,CAACJ,OAAO,CAAC;MAAC;IAC7B;EACF;;EAEA;EACA,SAASI,QAAQA,CAAEJ,OAAO,EAAE;IAC1B,MAAMO,KAAK,GAAGP,OAAO,CAACQ,KAAK,CAAC,IAAI,CAAC,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAC7D,IAAIJ,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAId,KAAK,CAAC,eAAe,CAAC;IAClC;;IAEA;IACA,MAAMe,OAAO,GAAGC,YAAY,CAACP,KAAK,CAAC,CAAC,CAAC,CAAC;;IAEtC;IACA,MAAMQ,IAAI,GAAGR,KAAK,CAACS,KAAK,CAAC,CAAC,CAAC,CAACC,GAAG,CAACP,IAAI,IAAII,YAAY,CAACJ,IAAI,CAAC,CAAC;;IAE3D;IACA,MAAM3B,OAAO,GAAG8B,OAAO,CAACI,GAAG,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAK;MAC7C,MAAMC,YAAY,GAAGL,IAAI,CAACE,GAAG,CAACI,GAAG,IAAIA,GAAG,CAACF,KAAK,CAAC,CAAC,CAACV,MAAM,CAACa,GAAG,IAAIA,GAAG,KAAK,EAAE,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKC,SAAS,CAAC;MAE/G,OAAO;QACLC,IAAI,EAAEN,MAAM;QACZpC,IAAI,EAAE2C,gBAAgB,CAACL,YAAY,CAAC;QACpCM,YAAY,EAAEN,YAAY,CAACR,MAAM;QACjCe,WAAW,EAAE,IAAIC,GAAG,CAACR,YAAY,CAAC,CAACS,IAAI;QACvCC,OAAO,EAAEV,YAAY,CAACJ,KAAK,CAAC,CAAC,EAAE,CAAC;MAClC,CAAC;IACH,CAAC,CAAC;;IAEF;IACA,MAAM/B,WAAW,GAAG8B,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAACC,GAAG,CAACI,GAAG,IAAI;MAChD,MAAMU,GAAG,GAAG,CAAC,CAAC;MACdlB,OAAO,CAACmB,OAAO,CAAC,CAACd,MAAM,EAAEC,KAAK,KAAK;QACjCY,GAAG,CAACb,MAAM,CAAC,GAAGG,GAAG,CAACF,KAAK,CAAC;MAC1B,CAAC,CAAC;MACF,OAAOY,GAAG;IACZ,CAAC,CAAC;IAEF,OAAO;MACLhD,OAAO;MACPC,QAAQ,EAAE+B,IAAI,CAACH,MAAM;MACrB3B;IACF,CAAC;EACH;;EAEA;EACA,SAAS6B,YAAYA,CAAEJ,IAAI,EAAE;IAC3B,MAAMd,MAAM,GAAG,EAAE;IACjB,IAAIqC,OAAO,GAAG,EAAE;IAChB,IAAIC,QAAQ,GAAG,KAAK;IAEpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,IAAI,CAACE,MAAM,EAAEuB,CAAC,EAAE,EAAE;MACpC,MAAMC,IAAI,GAAG1B,IAAI,CAACyB,CAAC,CAAC;MAEpB,IAAIC,IAAI,KAAK,GAAG,EAAE;QAChBF,QAAQ,GAAG,CAACA,QAAQ;MACtB,CAAC,MAAM,IAAIE,IAAI,KAAK,GAAG,IAAI,CAACF,QAAQ,EAAE;QACpCtC,MAAM,CAACyC,IAAI,CAACJ,OAAO,CAACtB,IAAI,CAAC,CAAC,CAAC;QAC3BsB,OAAO,GAAG,EAAE;MACd,CAAC,MAAM;QACLA,OAAO,IAAIG,IAAI;MACjB;IACF;IAEAxC,MAAM,CAACyC,IAAI,CAACJ,OAAO,CAACtB,IAAI,CAAC,CAAC,CAAC;IAC3B,OAAOf,MAAM;EACf;;EAEA;EACA,SAASS,SAASA,CAAEL,OAAO,EAAE;IAC3B,IAAI;MACF,MAAMsC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACxC,OAAO,CAAC;MAEhC,IAAI,CAACyC,KAAK,CAACC,OAAO,CAACJ,IAAI,CAAC,EAAE;QACxB,MAAM,IAAIxC,KAAK,CAAC,kCAAkC,CAAC;MACrD;MAEA,IAAIwC,IAAI,CAAC1B,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAId,KAAK,CAAC,qBAAqB,CAAC;MACxC;;MAEA;MACA,MAAM6C,OAAO,GAAG,IAAIf,GAAG,CAAC,CAAC;MACzBU,IAAI,CAACN,OAAO,CAACY,IAAI,IAAI;QACnBC,MAAM,CAACC,IAAI,CAACF,IAAI,CAAC,CAACZ,OAAO,CAACe,GAAG,IAAIJ,OAAO,CAACK,GAAG,CAACD,GAAG,CAAC,CAAC;MACpD,CAAC,CAAC;MAEF,MAAMhE,OAAO,GAAG0D,KAAK,CAACQ,IAAI,CAACN,OAAO,CAAC,CAAC1B,GAAG,CAAC8B,GAAG,IAAI;QAC7C,MAAM3B,YAAY,GAAGkB,IAAI,CAACrB,GAAG,CAAC2B,IAAI,IAAIA,IAAI,CAACG,GAAG,CAAC,CAAC,CAACtC,MAAM,CAACa,GAAG,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKC,SAAS,CAAC;QAEjG,OAAO;UACLC,IAAI,EAAEuB,GAAG;UACTjE,IAAI,EAAE2C,gBAAgB,CAACL,YAAY,CAAC;UACpCM,YAAY,EAAEN,YAAY,CAACR,MAAM;UACjCe,WAAW,EAAE,IAAIC,GAAG,CAACR,YAAY,CAAC,CAACS,IAAI;UACvCC,OAAO,EAAEV,YAAY,CAACJ,KAAK,CAAC,CAAC,EAAE,CAAC;QAClC,CAAC;MACH,CAAC,CAAC;MAEF,OAAO;QACLjC,OAAO;QACPC,QAAQ,EAAEsD,IAAI,CAAC1B,MAAM;QACrB3B,WAAW,EAAEqD,IAAI,CAACtB,KAAK,CAAC,CAAC,EAAE,GAAG;MAChC,CAAC;IACH,CAAC,CAAC,OAAO9B,KAAK,EAAE;MACd,MAAM,IAAIY,KAAK,CAAC,uBAAuB,GAAGZ,KAAK,CAACgE,OAAO,CAAC;IAC1D;EACF;;EAEA;EACA,eAAe5C,UAAUA,CAAEN,OAAO,EAAE;IAClC;IACA;IACA,MAAM,IAAIF,KAAK,CAAC,mEAAmE,CAAC;EACtF;;EAEA;EACA,SAAS2B,gBAAgBA,CAAE0B,MAAM,EAAE;IACjC,IAAIA,MAAM,CAACvC,MAAM,KAAK,CAAC,EAAE,OAAO,SAAS;IAEzC,MAAMwC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACH,MAAM,CAACvC,MAAM,EAAE,EAAE,CAAC;IAC9C,MAAMkB,OAAO,GAAGqB,MAAM,CAACnC,KAAK,CAAC,CAAC,EAAEoC,UAAU,CAAC;IAE3C,IAAIG,WAAW,GAAG,CAAC;IACnB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,SAAS,GAAG,CAAC;IAEjB5B,OAAO,CAACE,OAAO,CAACvD,KAAK,IAAI;MACvB,MAAMkF,GAAG,GAAGC,MAAM,CAACnF,KAAK,CAAC,CAACkC,IAAI,CAAC,CAAC;;MAEhC;MACA,IAAI,CAACkD,KAAK,CAACF,GAAG,CAAC,IAAIA,GAAG,KAAK,EAAE,EAAE;QAC7BJ,WAAW,EAAE;QACb,IAAIO,MAAM,CAACC,SAAS,CAACC,UAAU,CAACL,GAAG,CAAC,CAAC,EAAE;UACrCH,YAAY,EAAE;QAChB;MACF;;MAEA;MACA,IAAIG,GAAG,CAACxD,WAAW,CAAC,CAAC,KAAK,MAAM,IAAIwD,GAAG,CAACxD,WAAW,CAAC,CAAC,KAAK,OAAO,EAAE;QACjEsD,YAAY,EAAE;MAChB;;MAEA;MACA,IAAIQ,WAAW,CAACN,GAAG,CAAC,EAAE;QACpBD,SAAS,EAAE;MACb;IACF,CAAC,CAAC;IAEF,MAAMQ,SAAS,GAAGd,UAAU,GAAG,GAAG;IAElC,IAAIK,YAAY,IAAIS,SAAS,EAAE,OAAO,SAAS;IAC/C,IAAIR,SAAS,IAAIQ,SAAS,EAAE,OAAO,MAAM;IACzC,IAAIV,YAAY,IAAIU,SAAS,EAAE,OAAO,SAAS;IAC/C,IAAIX,WAAW,IAAIW,SAAS,EAAE,OAAO,QAAQ;IAE7C,OAAO,QAAQ;EACjB;;EAEA;EACA,SAASD,WAAWA,CAAEE,UAAU,EAAE;IAChC,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACF,UAAU,CAAC;IACjC,OAAO,CAACN,KAAK,CAACO,IAAI,CAACE,OAAO,CAAC,CAAC,CAAC,IAAIH,UAAU,CAACvD,MAAM,GAAG,CAAC;EACxD;;EAEA;EACA,SAAS2D,cAAcA,CAAEC,KAAK,EAAE;IAC9B,IAAIA,KAAK,KAAK,CAAC,EAAE,OAAO,KAAK;IAE7B,MAAMC,CAAC,GAAG,IAAI;IACd,MAAMC,KAAK,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACrC,MAAMvC,CAAC,GAAGkB,IAAI,CAACsB,KAAK,CAACtB,IAAI,CAACuB,GAAG,CAACJ,KAAK,CAAC,GAAGnB,IAAI,CAACuB,GAAG,CAACH,CAAC,CAAC,CAAC;IAEnD,OAAOT,UAAU,CAAC,CAACQ,KAAK,GAAGnB,IAAI,CAACwB,GAAG,CAACJ,CAAC,EAAEtC,CAAC,CAAC,EAAE2C,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGJ,KAAK,CAACvC,CAAC,CAAC;EACzE;;EAEA;EACA,SAAS4C,eAAeA,CAAEvG,IAAI,EAAE;IAC9B,MAAMI,SAAS,GAAG;MAChBoG,QAAQ,EAAExG,IAAI,CAACgD,IAAI;MACnByD,QAAQ,EAAEzG,IAAI,CAACqD,IAAI;MACnB7C,QAAQ,EAAER,IAAI,CAACQ,QAAQ;MACvBD,OAAO,EAAEP,IAAI,CAACO,OAAO;MACrBmG,UAAU,EAAE,IAAIb,IAAI,CAAC,CAAC,CAACc,WAAW,CAAC;IACrC,CAAC;IAED,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC,CAAC9C,IAAI,CAAC+C,SAAS,CAAC1G,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;MAAEE,IAAI,EAAE;IAAmB,CAAC,CAAC;IACzF,MAAMyG,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;IAErC,MAAMM,CAAC,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;IACrCF,CAAC,CAACG,IAAI,GAAGN,GAAG;IACZG,CAAC,CAACI,QAAQ,GAAG,GAAGtH,IAAI,CAACgD,IAAI,iBAAiB;IAC1CmE,QAAQ,CAACI,IAAI,CAACC,WAAW,CAACN,CAAC,CAAC;IAC5BA,CAAC,CAACO,KAAK,CAAC,CAAC;IACTN,QAAQ,CAACI,IAAI,CAACG,WAAW,CAACR,CAAC,CAAC;IAC5BF,GAAG,CAACW,eAAe,CAACZ,GAAG,CAAC;EAC1B;;EAEA;EACA,SAASa,cAAcA,CAAEC,KAAK,EAAEC,aAAa,EAAE;IAC7C,MAAMC,UAAU,GAAG,EAAE;;IAErB;IACA,MAAMC,eAAe,GAAG,IAAI5E,GAAG,CAAC,CAAC;IACjCiB,MAAM,CAACM,MAAM,CAACmD,aAAa,CAAC,CAACtE,OAAO,CAACyE,UAAU,IAAI;MACjDA,UAAU,CAACzE,OAAO,CAAC0E,GAAG,IAAI;QACxBF,eAAe,CAACxD,GAAG,CAAC,GAAG0D,GAAG,CAACC,MAAM,IAAID,GAAG,CAACE,UAAU,EAAE,CAAC;MACxD,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACA,MAAMC,OAAO,GAAGxD,IAAI,CAACyD,GAAG,CAAC,GAAGT,KAAK,CAACpF,GAAG,CAACzC,IAAI,IAAIA,IAAI,CAACS,WAAW,EAAE2B,MAAM,IAAI,CAAC,CAAC,CAAC;;IAE7E;IACA,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0E,OAAO,EAAE1E,CAAC,EAAE,EAAE;MAChC,MAAM4E,SAAS,GAAG,CAAC,CAAC;MAEpBV,KAAK,CAACrE,OAAO,CAACxD,IAAI,IAAI;QACpB,IAAIA,IAAI,CAACS,WAAW,IAAIT,IAAI,CAACS,WAAW,CAACkD,CAAC,CAAC,EAAE;UAC3C,MAAMd,GAAG,GAAG7C,IAAI,CAACS,WAAW,CAACkD,CAAC,CAAC;UAC/BU,MAAM,CAACC,IAAI,CAACzB,GAAG,CAAC,CAACW,OAAO,CAAC4E,UAAU,IAAI;YACrC,MAAM7D,GAAG,GAAG,GAAGvE,IAAI,CAACwI,EAAE,IAAIJ,UAAU,EAAE;YACtC,IAAIJ,eAAe,CAACS,GAAG,CAAClE,GAAG,CAAC,EAAE;cAC5BgE,SAAS,CAACH,UAAU,CAAC,GAAGvF,GAAG,CAACuF,UAAU,CAAC;YACzC;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;;MAEF;MACA,IAAI/D,MAAM,CAACC,IAAI,CAACiE,SAAS,CAAC,CAACnG,MAAM,GAAG,CAAC,EAAE;QACrC2F,UAAU,CAAClE,IAAI,CAAC0E,SAAS,CAAC;MAC5B;IACF;IAEA,OAAOR,UAAU;EACnB;;EAEA;EACA,SAASW,eAAeA,CAAEZ,aAAa,EAAED,KAAK,EAAE;IAC9C,MAAMc,MAAM,GAAG,EAAE;IAEjBtE,MAAM,CAACuE,OAAO,CAACd,aAAa,CAAC,CAACtE,OAAO,CAAC,CAAC,CAACqF,SAAS,EAAEZ,UAAU,CAAC,KAAK;MACjEA,UAAU,CAACzE,OAAO,CAAC0E,GAAG,IAAI;QACxB,MAAMlI,IAAI,GAAG6H,KAAK,CAACiB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACP,EAAE,KAAKN,GAAG,CAACC,MAAM,CAAC;QACjD,IAAI,CAACnI,IAAI,EAAE;UACT2I,MAAM,CAAC9E,IAAI,CAAC,8BAA8BqE,GAAG,CAACE,UAAU,EAAE,CAAC;UAC3D;QACF;QAEA,MAAMY,MAAM,GAAGhJ,IAAI,CAACO,OAAO,EAAEuI,IAAI,CAACG,CAAC,IAAIA,CAAC,CAACjG,IAAI,KAAKkF,GAAG,CAACE,UAAU,CAAC;QACjE,IAAI,CAACY,MAAM,EAAE;UACXL,MAAM,CAAC9E,IAAI,CAAC,qBAAqBqE,GAAG,CAACE,UAAU,YAAYpI,IAAI,CAACgD,IAAI,EAAE,CAAC;QACzE;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO2F,MAAM;EACf;EAEA,OAAO;IACL7I,WAAW;IACXC,oBAAoB;IACpBgG,cAAc;IACdQ,eAAe;IACfqB,cAAc;IACdc,eAAe;IACfzF;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}