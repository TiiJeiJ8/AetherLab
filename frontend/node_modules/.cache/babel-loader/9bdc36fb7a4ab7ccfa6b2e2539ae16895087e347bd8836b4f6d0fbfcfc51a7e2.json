{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx';\nconst API_BASE_URL = '/api';\nconst CACHE_KEY = 'fuck_charts_files';\n\n// 分块上传配置\nconst CHUNK_SIZE = 2 * 1024 * 1024; // 2MB per chunk\nconst CHUNK_SIZE_THRESHOLD = 10 * 1024 * 1024; // 10MB threshold for chunked upload\nconst MAX_CONCURRENT_CHUNKS = 3; // 最大并发分块数\n\n// 后端连接状态\nlet isBackendConnected = false;\n\n/**\n * 后端连接检测（支持HTTP+WebSocket双协议检测）\n * @param {number} maxRetries - 最大重试次数(默认3次)\n * @returns {Promise<{status: boolean, protocol: string}>} \n */\nexport async function checkBackendConnection(maxRetries = 3) {\n  // 尝试HTTP检测\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 3000);\n      const response = await fetch(`${API_BASE_URL}/health`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Cache-Control': 'no-cache'\n        } // 避免缓存干扰检测\n      });\n      clearTimeout(timeoutId);\n      if (response.ok) {\n        return {\n          status: true,\n          protocol: 'http'\n        };\n      } else {\n        console.warn(`Backend service error HTTP${response.status}`);\n      }\n    } catch (error) {\n      console.log(`检测尝试 ${i + 1}/${maxRetries}:`, error.message);\n      if (i === maxRetries - 1) return tryWebSocketFallback(); // 最终失败尝试WebSocket\n      await new Promise(resolve => setTimeout(resolve, 1000)); // 1秒延迟重试\n    }\n  }\n}\n// WebSocket降级检测方案\nasync function tryWebSocketFallback() {\n  return new Promise(resolve => {\n    const ws = new WebSocket(`${WS_BASE_URL}/health`);\n    const timer = setTimeout(() => {\n      ws.close();\n      resolve({\n        status: false,\n        protocol: 'websocket'\n      });\n    }, 3000);\n    ws.onopen = () => {\n      clearTimeout(timer);\n      ws.close();\n      resolve({\n        status: true,\n        protocol: 'websocket'\n      });\n    };\n    ws.onerror = () => {\n      clearTimeout(timer);\n      resolve({\n        status: false,\n        protocol: 'websocket'\n      });\n    };\n  });\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n  return isBackendConnected;\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n  try {\n    const cached = localStorage.getItem(CACHE_KEY);\n    return cached ? JSON.parse(cached) : [];\n  } catch (error) {\n    console.error('读取缓存失败:', error);\n    return [];\n  }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n  try {\n    const cached = getCachedFiles();\n    cached.push(fileInfo);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(cached));\n  } catch (error) {\n    console.error('保存到缓存失败:', error);\n  }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n  try {\n    const cached = getCachedFiles();\n    const filtered = cached.filter(file => file.id !== fileId);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(filtered));\n  } catch (error) {\n    console.error('从缓存删除失败:', error);\n  }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = e.target.result;\n        let workbook, worksheet, jsonData;\n        if (file.name.toLowerCase().endsWith('.csv')) {\n          // CSV文件解析 - 支持中文字符\n          workbook = XLSX.read(data, {\n            type: 'string',\n            codepage: 65001 // UTF-8\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1,\n            defval: '',\n            blankrows: false\n          });\n        } else {\n          // Excel文件解析 - 支持中文字符\n          workbook = XLSX.read(data, {\n            type: 'array',\n            cellDates: true,\n            cellNF: false,\n            cellText: false\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1,\n            defval: '',\n            blankrows: false\n          });\n        }\n\n        // 过滤空行\n        jsonData = jsonData.filter(row => row.some(cell => cell !== null && cell !== ''));\n\n        // 限制预览行数\n        const previewData = jsonData.slice(0, 100);\n        resolve({\n          data: previewData,\n          totalRows: jsonData.length,\n          totalColumns: jsonData[0] ? jsonData[0].length : 0,\n          headers: jsonData[0] || []\n        });\n      } catch (error) {\n        console.error('文件解析失败:', error);\n        reject(new Error('文件解析失败：' + error.message));\n      }\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    if (file.name.toLowerCase().endsWith('.csv')) {\n      reader.readAsText(file, 'UTF-8');\n    } else {\n      reader.readAsArrayBuffer(file);\n    }\n  });\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * 支持分块上传大文件\n * @param {File} file - 要上传的文件对象\n * @param {Function} onProgress - 进度回调函数\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file, onProgress) {\n  try {\n    // 首先解析文件内容\n    console.log('开始解析文件:', file.name);\n    const parsedContent = await parseFileContent(file);\n    const fileInfo = {\n      id: Date.now() + Math.random().toString(36).substr(2, 9),\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      rows: parsedContent.totalRows,\n      columns: parsedContent.totalColumns,\n      headers: parsedContent.headers,\n      createdAt: new Date().toISOString(),\n      status: 'local',\n      data: parsedContent.data,\n      file: file // 保存原始文件对象用于后续上传\n    };\n\n    // 检查后端连接状态\n    const isConnected = await checkBackendConnection();\n    console.log('后端连接状态:', isConnected);\n    if (isConnected) {\n      // 后端连接时智能上传\n      try {\n        fileInfo.status = 'uploading';\n        console.log('正在上传到后端...');\n        let result;\n        // 判断是否需要分块上传\n        if (file.size > CHUNK_SIZE_THRESHOLD) {\n          console.log(`文件大小 ${(file.size / 1024 / 1024).toFixed(2)}MB 超过阈值，使用分块上传`);\n          result = await chunkUpload(file, onProgress, fileInfo.id);\n        } else {\n          console.log('使用普通上传');\n          result = await normalUpload(file, onProgress);\n        }\n        fileInfo.status = 'uploaded';\n        fileInfo.serverId = result.fileId;\n        console.log('上传成功:', result);\n\n        // 同时保存到缓存\n        saveToCache(fileInfo);\n        return fileInfo;\n      } catch (error) {\n        console.error('后端上传失败:', error);\n        fileInfo.status = 'local'; // 改为本地缓存而不是error\n        saveToCache(fileInfo);\n        console.log('已保存到本地缓存');\n        return fileInfo;\n      }\n    } else {\n      // 后端未连接时保存到本地缓存\n      console.log('后端未连接，保存到本地缓存');\n      fileInfo.status = 'local';\n      saveToCache(fileInfo);\n      return fileInfo;\n    }\n  } catch (error) {\n    console.error('文件处理失败:', error);\n    throw new Error('文件处理失败：' + error.message);\n  }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise} 文件预览数据\n */\nexport async function getFilePreview(fileId) {\n  // 先从缓存查找\n  const cachedFiles = getCachedFiles();\n  const cachedFile = cachedFiles.find(file => file.id === fileId);\n  if (cachedFile && cachedFile.data) {\n    return {\n      data: cachedFile.data,\n      totalRows: cachedFile.rows,\n      totalColumns: cachedFile.columns,\n      headers: cachedFile.headers\n    };\n  }\n\n  // 如果缓存中没有，且后端连接，则从后端获取\n  if (isBackendConnected) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/files/${fileId}/preview`);\n      if (!response.ok) {\n        throw new Error('Failed to get preview');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('获取文件预览失败:', error);\n      throw error;\n    }\n  }\n  throw new Error('文件预览不可用');\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo || !fileInfo.file) {\n    throw new Error('本地文件不存在');\n  }\n  if (!(await checkBackendConnection())) {\n    throw new Error('后端未连接');\n  }\n  try {\n    const formData = new FormData();\n    formData.append('file', fileInfo.file);\n    const response = await fetch(`${API_BASE_URL}/files/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error('同步失败');\n    }\n    const result = await response.json();\n\n    // 更新缓存中的文件状态\n    fileInfo.status = 'uploaded';\n    fileInfo.serverId = result.fileId;\n    const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n    return fileInfo;\n  } catch (error) {\n    console.error('同步文件失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n  const cachedFiles = getCachedFiles();\n  if (!(await checkBackendConnection())) {\n    return cachedFiles;\n  }\n  try {\n    const response = await fetch(`${API_BASE_URL}/files`);\n    if (!response.ok) {\n      return cachedFiles;\n    }\n    const remoteFiles = await response.json();\n\n    // 合并本地和远程文件，避免重复\n    const allFiles = [...cachedFiles];\n    remoteFiles.forEach(remoteFile => {\n      const existsInCache = cachedFiles.some(cached => cached.serverId === remoteFile.id);\n      if (!existsInCache) {\n        allFiles.push({\n          ...remoteFile,\n          id: remoteFile.id,\n          serverId: remoteFile.id,\n          status: 'uploaded'\n        });\n      }\n    });\n    return allFiles;\n  } catch (error) {\n    console.error('获取远程文件列表失败:', error);\n    return cachedFiles;\n  }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时从服务器删除\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n          method: 'DELETE'\n        });\n        if (!response.ok) {\n          console.warn('从服务器删除文件失败');\n        }\n      } catch (error) {\n        console.error('从服务器删除文件失败:', error);\n      }\n    }\n  }\n\n  // 从本地缓存删除\n  removeFromCache(fileId);\n  return {\n    success: true\n  };\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时更新服务器\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            name: newName\n          })\n        });\n        if (!response.ok) {\n          console.warn('服务器重命名失败');\n        }\n      } catch (error) {\n        console.error('服务器重命名失败:', error);\n      }\n    }\n  }\n\n  // 更新本地缓存\n  fileInfo.name = newName;\n  const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n  localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n  return {\n    success: true,\n    file: fileInfo\n  };\n}\n\n/**\n * 计算文件MD5哈希值\n * @param {File} file - 文件对象\n * @returns {Promise<string>} MD5哈希值\n */\nasync function calculateMD5(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const buffer = reader.result;\n      const hash = crypto.subtle.digest('MD5', buffer);\n      hash.then(hashArray => {\n        const hashHex = Array.from(new Uint8Array(hashArray)).map(b => b.toString(16).padStart(2, '0')).join('');\n        resolve(hashHex);\n      }).catch(reject);\n    };\n    reader.onerror = reject;\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n// 上传取消控制器映射\nconst uploadControllers = new Map();\n\n/**\n * 取消文件上传\n * @param {string} fileId - 文件ID\n * @returns {boolean} 是否成功取消\n */\nexport function cancelUpload(fileId) {\n  const controller = uploadControllers.get(fileId);\n  if (controller) {\n    controller.abort();\n    uploadControllers.delete(fileId);\n    console.log(`取消上传: ${fileId}`);\n    return true;\n  }\n  return false;\n}\n\n/**\n * 分块上传文件\n * @param {File} file - 文件对象\n * @param {Function} onProgress - 进度回调\n * @param {string} fileId - 文件ID（用于取消控制）\n * @returns {Promise<Object>} 上传结果\n */\nasync function chunkUpload(file, onProgress, fileId) {\n  const fileSize = file.size;\n  const chunks = Math.ceil(fileSize / CHUNK_SIZE);\n  const fileName = file.name;\n  const fileType = file.type;\n\n  // 创建取消控制器\n  const controller = new AbortController();\n  uploadControllers.set(fileId, controller);\n  try {\n    // 生成上传会话唯一标识\n    const uploadId = Date.now() + Math.random().toString(36).substr(2, 9);\n    console.log(`开始分块上传: ${fileName}, 大小: ${fileSize}, 分块数: ${chunks}`);\n\n    // 初始化上传会话\n    const initResponse = await fetch(`${API_BASE_URL}/files/chunk-upload/init`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        fileId: fileId,\n        fileName: fileName,\n        fileSize: fileSize,\n        fileType: fileType,\n        totalChunks: chunks,\n        uploadId: uploadId\n      }),\n      signal: controller.signal\n    });\n    if (!initResponse.ok) {\n      throw new Error('初始化分块上传失败');\n    }\n    const initResult = await initResponse.json();\n    const sessionUploadId = initResult.uploadId || uploadId;\n\n    // 上传分块\n    const uploadPromises = [];\n    let uploadedChunks = 0;\n    for (let i = 0; i < chunks; i++) {\n      const start = i * CHUNK_SIZE;\n      const end = Math.min(start + CHUNK_SIZE, fileSize);\n      const chunk = file.slice(start, end);\n      const uploadPromise = uploadChunk(sessionUploadId, i, chunk, chunks, controller.signal).then(() => {\n        uploadedChunks++;\n        if (onProgress) {\n          onProgress({\n            loaded: uploadedChunks * CHUNK_SIZE,\n            total: fileSize,\n            percentage: Math.round(uploadedChunks / chunks * 100)\n          });\n        }\n      });\n      uploadPromises.push(uploadPromise);\n\n      // 控制并发数\n      if (uploadPromises.length >= MAX_CONCURRENT_CHUNKS) {\n        await Promise.all(uploadPromises);\n        uploadPromises.length = 0;\n      }\n    }\n\n    // 等待所有分块上传完成\n    if (uploadPromises.length > 0) {\n      await Promise.all(uploadPromises);\n    }\n\n    // 完成上传\n    const completeResponse = await fetch(`${API_BASE_URL}/files/chunk-upload/complete`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        uploadId: sessionUploadId,\n        fileId: fileId\n      }),\n      signal: controller.signal\n    });\n    if (!completeResponse.ok) {\n      throw new Error('完成分块上传失败');\n    }\n    const result = await completeResponse.json();\n    console.log('分块上传完成:', result);\n    return result;\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.log('分块上传被取消');\n      throw new Error('上传被取消');\n    }\n    throw error;\n  } finally {\n    // 清理控制器\n    uploadControllers.delete(fileId);\n  }\n}\n\n/**\n * 上传单个分块\n * @param {string} uploadId - 上传会话ID\n * @param {number} chunkIndex - 分块索引\n * @param {Blob} chunk - 分块数据\n * @param {number} totalChunks - 总分块数\n * @param {AbortSignal} signal - 取消信号\n * @returns {Promise<void>}\n */\nasync function uploadChunk(uploadId, chunkIndex, chunk, totalChunks, signal) {\n  const formData = new FormData();\n  formData.append('uploadId', uploadId);\n  formData.append('chunkIndex', chunkIndex);\n  formData.append('chunk', chunk);\n  formData.append('totalChunks', totalChunks);\n  const response = await fetch(`${API_BASE_URL}/files/chunk-upload/chunk`, {\n    method: 'POST',\n    body: formData,\n    signal: signal\n  });\n  if (!response.ok) {\n    throw new Error(`上传分块 ${chunkIndex} 失败`);\n  }\n  console.log(`分块 ${chunkIndex + 1}/${totalChunks} 上传成功`);\n}\n\n/**\n * 普通上传文件\n * @param {File} file - 文件对象\n * @param {Function} onProgress - 进度回调\n * @returns {Promise<Object>} 上传结果\n */\nasync function normalUpload(file, onProgress) {\n  const formData = new FormData();\n  formData.append('file', file);\n  const xhr = new XMLHttpRequest();\n  return new Promise((resolve, reject) => {\n    xhr.upload.onprogress = event => {\n      if (event.lengthComputable && onProgress) {\n        onProgress({\n          loaded: event.loaded,\n          total: event.total,\n          percentage: Math.round(event.loaded / event.total * 100)\n        });\n      }\n    };\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        try {\n          const result = JSON.parse(xhr.responseText);\n          resolve(result);\n        } catch (error) {\n          reject(new Error('解析响应失败'));\n        }\n      } else {\n        reject(new Error(`上传失败: ${xhr.status} ${xhr.statusText}`));\n      }\n    };\n    xhr.onerror = () => {\n      reject(new Error('网络错误'));\n    };\n    xhr.open('POST', `${API_BASE_URL}/files/upload`);\n    xhr.send(formData);\n  });\n}","map":{"version":3,"names":["XLSX","API_BASE_URL","CACHE_KEY","CHUNK_SIZE","CHUNK_SIZE_THRESHOLD","MAX_CONCURRENT_CHUNKS","isBackendConnected","checkBackendConnection","maxRetries","i","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","signal","headers","clearTimeout","ok","status","protocol","console","warn","error","log","message","tryWebSocketFallback","Promise","resolve","ws","WebSocket","WS_BASE_URL","timer","close","onopen","onerror","getBackendStatus","getCachedFiles","cached","localStorage","getItem","JSON","parse","saveToCache","fileInfo","push","setItem","stringify","removeFromCache","fileId","filtered","filter","file","id","parseFileContent","reject","reader","FileReader","onload","e","data","target","result","workbook","worksheet","jsonData","name","toLowerCase","endsWith","read","type","codepage","Sheets","SheetNames","utils","sheet_to_json","header","defval","blankrows","cellDates","cellNF","cellText","row","some","cell","previewData","slice","totalRows","length","totalColumns","Error","readAsText","readAsArrayBuffer","uploadFile","onProgress","parsedContent","Date","now","Math","random","toString","substr","size","rows","columns","createdAt","toISOString","isConnected","toFixed","chunkUpload","normalUpload","serverId","getFilePreview","cachedFiles","cachedFile","find","json","syncFileToBackend","formData","FormData","append","body","updatedFiles","map","getAllFiles","remoteFiles","allFiles","forEach","remoteFile","existsInCache","deleteFile","success","renameFile","newName","calculateMD5","buffer","hash","crypto","subtle","digest","then","hashArray","hashHex","Array","from","Uint8Array","b","padStart","join","catch","uploadControllers","Map","cancelUpload","get","delete","fileSize","chunks","ceil","fileName","fileType","set","uploadId","initResponse","totalChunks","initResult","sessionUploadId","uploadPromises","uploadedChunks","start","end","min","chunk","uploadPromise","uploadChunk","loaded","total","percentage","round","all","completeResponse","chunkIndex","xhr","XMLHttpRequest","upload","onprogress","event","lengthComputable","responseText","statusText","open","send"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/services/FileServices.js"],"sourcesContent":["/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx'\n\nconst API_BASE_URL = '/api'\nconst CACHE_KEY = 'fuck_charts_files'\n\n// 分块上传配置\nconst CHUNK_SIZE = 2 * 1024 * 1024 // 2MB per chunk\nconst CHUNK_SIZE_THRESHOLD = 10 * 1024 * 1024 // 10MB threshold for chunked upload\nconst MAX_CONCURRENT_CHUNKS = 3 // 最大并发分块数\n\n// 后端连接状态\nlet isBackendConnected = false\n\n/**\n * 后端连接检测（支持HTTP+WebSocket双协议检测）\n * @param {number} maxRetries - 最大重试次数(默认3次)\n * @returns {Promise<{status: boolean, protocol: string}>} \n */\nexport async function checkBackendConnection(maxRetries = 3) {\n    // 尝试HTTP检测\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            const controller = new AbortController()\n            const timeoutId = setTimeout(() => controller.abort(), 3000)\n\n            const response = await fetch(`${API_BASE_URL}/health`, {\n                method: 'GET',\n                signal: controller.signal,\n                headers: { 'Cache-Control': 'no-cache' } // 避免缓存干扰检测\n            })\n\n            clearTimeout(timeoutId)\n\n            if (response.ok) {\n                return { status: true, protocol: 'http' }\n            } else {\n                console.warn(`Backend service error HTTP${response.status}`)\n            }\n        } catch (error) {\n            console.log(`检测尝试 ${i + 1}/${maxRetries}:`, error.message)\n            if (i === maxRetries - 1) return tryWebSocketFallback() // 最终失败尝试WebSocket\n            await new Promise(resolve => setTimeout(resolve, 1000)) // 1秒延迟重试\n        }\n    }\n}\n// WebSocket降级检测方案\nasync function tryWebSocketFallback() {\n    return new Promise((resolve) => {\n        const ws = new WebSocket(`${WS_BASE_URL}/health`)\n        const timer = setTimeout(() => {\n            ws.close()\n            resolve({ status: false, protocol: 'websocket' })\n        }, 3000)\n\n        ws.onopen = () => {\n            clearTimeout(timer)\n            ws.close()\n            resolve({ status: true, protocol: 'websocket' })\n        }\n\n        ws.onerror = () => {\n            clearTimeout(timer)\n            resolve({ status: false, protocol: 'websocket' })\n        }\n    })\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n    return isBackendConnected\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n    try {\n        const cached = localStorage.getItem(CACHE_KEY)\n        return cached ? JSON.parse(cached) : []\n    } catch (error) {\n        console.error('读取缓存失败:', error)\n        return []\n    }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n    try {\n        const cached = getCachedFiles()\n        cached.push(fileInfo)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(cached))\n    } catch (error) {\n        console.error('保存到缓存失败:', error)\n    }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n    try {\n        const cached = getCachedFiles()\n        const filtered = cached.filter(file => file.id !== fileId)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(filtered))\n    } catch (error) {\n        console.error('从缓存删除失败:', error)\n    }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n\n        reader.onload = (e) => {\n            try {\n                const data = e.target.result\n                let workbook, worksheet, jsonData\n\n                if (file.name.toLowerCase().endsWith('.csv')) {\n                    // CSV文件解析 - 支持中文字符\n                    workbook = XLSX.read(data, {\n                        type: 'string',\n                        codepage: 65001 // UTF-8\n                    })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                        header: 1,\n                        defval: '',\n                        blankrows: false\n                    })\n                } else {\n                    // Excel文件解析 - 支持中文字符\n                    workbook = XLSX.read(data, {\n                        type: 'array',\n                        cellDates: true,\n                        cellNF: false,\n                        cellText: false\n                    })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                        header: 1,\n                        defval: '',\n                        blankrows: false\n                    })\n                }\n\n                // 过滤空行\n                jsonData = jsonData.filter(row => row.some(cell => cell !== null && cell !== ''))\n\n                // 限制预览行数\n                const previewData = jsonData.slice(0, 100)\n\n                resolve({\n                    data: previewData,\n                    totalRows: jsonData.length,\n                    totalColumns: jsonData[0] ? jsonData[0].length : 0,\n                    headers: jsonData[0] || []\n                })\n            } catch (error) {\n                console.error('文件解析失败:', error)\n                reject(new Error('文件解析失败：' + error.message))\n            }\n        }\n\n        reader.onerror = () => reject(new Error('文件读取失败'))\n\n        if (file.name.toLowerCase().endsWith('.csv')) {\n            reader.readAsText(file, 'UTF-8')\n        } else {\n            reader.readAsArrayBuffer(file)\n        }\n    })\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * 支持分块上传大文件\n * @param {File} file - 要上传的文件对象\n * @param {Function} onProgress - 进度回调函数\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file, onProgress) {\n    try {\n        // 首先解析文件内容\n        console.log('开始解析文件:', file.name)\n        const parsedContent = await parseFileContent(file)\n\n        const fileInfo = {\n            id: Date.now() + Math.random().toString(36).substr(2, 9),\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            rows: parsedContent.totalRows,\n            columns: parsedContent.totalColumns,\n            headers: parsedContent.headers,\n            createdAt: new Date().toISOString(),\n            status: 'local',\n            data: parsedContent.data,\n            file: file // 保存原始文件对象用于后续上传\n        }\n\n        // 检查后端连接状态\n        const isConnected = await checkBackendConnection()\n        console.log('后端连接状态:', isConnected)\n\n        if (isConnected) {\n            // 后端连接时智能上传\n            try {\n                fileInfo.status = 'uploading'\n                console.log('正在上传到后端...')\n\n                let result\n                // 判断是否需要分块上传\n                if (file.size > CHUNK_SIZE_THRESHOLD) {\n                    console.log(`文件大小 ${(file.size / 1024 / 1024).toFixed(2)}MB 超过阈值，使用分块上传`)\n                    result = await chunkUpload(file, onProgress, fileInfo.id)\n                } else {\n                    console.log('使用普通上传')\n                    result = await normalUpload(file, onProgress)\n                }\n\n                fileInfo.status = 'uploaded'\n                fileInfo.serverId = result.fileId\n\n                console.log('上传成功:', result)\n\n                // 同时保存到缓存\n                saveToCache(fileInfo)\n\n                return fileInfo\n            } catch (error) {\n                console.error('后端上传失败:', error)\n                fileInfo.status = 'local' // 改为本地缓存而不是error\n                saveToCache(fileInfo)\n                console.log('已保存到本地缓存')\n                return fileInfo\n            }\n        } else {\n            // 后端未连接时保存到本地缓存\n            console.log('后端未连接，保存到本地缓存')\n            fileInfo.status = 'local'\n            saveToCache(fileInfo)\n            return fileInfo\n        }\n    } catch (error) {\n        console.error('文件处理失败:', error)\n        throw new Error('文件处理失败：' + error.message)\n    }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise} 文件预览数据\n */\nexport async function getFilePreview(fileId) {\n    // 先从缓存查找\n    const cachedFiles = getCachedFiles()\n    const cachedFile = cachedFiles.find(file => file.id === fileId)\n\n    if (cachedFile && cachedFile.data) {\n        return {\n            data: cachedFile.data,\n            totalRows: cachedFile.rows,\n            totalColumns: cachedFile.columns,\n            headers: cachedFile.headers\n        }\n    }\n\n    // 如果缓存中没有，且后端连接，则从后端获取\n    if (isBackendConnected) {\n        try {\n            const response = await fetch(`${API_BASE_URL}/files/${fileId}/preview`)\n            if (!response.ok) {\n                throw new Error('Failed to get preview')\n            }\n            return await response.json()\n        } catch (error) {\n            console.error('获取文件预览失败:', error)\n            throw error\n        }\n    }\n\n    throw new Error('文件预览不可用')\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo || !fileInfo.file) {\n        throw new Error('本地文件不存在')\n    }\n\n    if (!await checkBackendConnection()) {\n        throw new Error('后端未连接')\n    }\n\n    try {\n        const formData = new FormData()\n        formData.append('file', fileInfo.file)\n\n        const response = await fetch(`${API_BASE_URL}/files/upload`, {\n            method: 'POST',\n            body: formData\n        })\n\n        if (!response.ok) {\n            throw new Error('同步失败')\n        }\n\n        const result = await response.json()\n\n        // 更新缓存中的文件状态\n        fileInfo.status = 'uploaded'\n        fileInfo.serverId = result.fileId\n\n        const updatedFiles = cachedFiles.map(file =>\n            file.id === fileId ? fileInfo : file\n        )\n        localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n\n        return fileInfo\n    } catch (error) {\n        console.error('同步文件失败:', error)\n        throw error\n    }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n    const cachedFiles = getCachedFiles()\n\n    if (!await checkBackendConnection()) {\n        return cachedFiles\n    }\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/files`)\n        if (!response.ok) {\n            return cachedFiles\n        }\n\n        const remoteFiles = await response.json()\n\n        // 合并本地和远程文件，避免重复\n        const allFiles = [...cachedFiles]\n\n        remoteFiles.forEach(remoteFile => {\n            const existsInCache = cachedFiles.some(cached =>\n                cached.serverId === remoteFile.id\n            )\n\n            if (!existsInCache) {\n                allFiles.push({\n                    ...remoteFile,\n                    id: remoteFile.id,\n                    serverId: remoteFile.id,\n                    status: 'uploaded'\n                })\n            }\n        })\n\n        return allFiles\n    } catch (error) {\n        console.error('获取远程文件列表失败:', error)\n        return cachedFiles\n    }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n\n    // 如果文件已上传到服务器，同时从服务器删除\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n                    method: 'DELETE'\n                })\n                if (!response.ok) {\n                    console.warn('从服务器删除文件失败')\n                }\n            } catch (error) {\n                console.error('从服务器删除文件失败:', error)\n            }\n        }\n    }\n\n    // 从本地缓存删除\n    removeFromCache(fileId)\n\n    return { success: true }\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n\n    // 如果文件已上传到服务器，同时更新服务器\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ name: newName })\n                })\n                if (!response.ok) {\n                    console.warn('服务器重命名失败')\n                }\n            } catch (error) {\n                console.error('服务器重命名失败:', error)\n            }\n        }\n    }\n\n    // 更新本地缓存\n    fileInfo.name = newName\n    const updatedFiles = cachedFiles.map(file =>\n        file.id === fileId ? fileInfo : file\n    )\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n\n    return { success: true, file: fileInfo }\n}\n\n/**\n * 计算文件MD5哈希值\n * @param {File} file - 文件对象\n * @returns {Promise<string>} MD5哈希值\n */\nasync function calculateMD5(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = () => {\n            const buffer = reader.result\n            const hash = crypto.subtle.digest('MD5', buffer)\n            hash.then(hashArray => {\n                const hashHex = Array.from(new Uint8Array(hashArray))\n                    .map(b => b.toString(16).padStart(2, '0'))\n                    .join('')\n                resolve(hashHex)\n            }).catch(reject)\n        }\n        reader.onerror = reject\n        reader.readAsArrayBuffer(file)\n    })\n}\n\n// 上传取消控制器映射\nconst uploadControllers = new Map()\n\n/**\n * 取消文件上传\n * @param {string} fileId - 文件ID\n * @returns {boolean} 是否成功取消\n */\nexport function cancelUpload(fileId) {\n    const controller = uploadControllers.get(fileId)\n    if (controller) {\n        controller.abort()\n        uploadControllers.delete(fileId)\n        console.log(`取消上传: ${fileId}`)\n        return true\n    }\n    return false\n}\n\n/**\n * 分块上传文件\n * @param {File} file - 文件对象\n * @param {Function} onProgress - 进度回调\n * @param {string} fileId - 文件ID（用于取消控制）\n * @returns {Promise<Object>} 上传结果\n */\nasync function chunkUpload(file, onProgress, fileId) {\n    const fileSize = file.size\n    const chunks = Math.ceil(fileSize / CHUNK_SIZE)\n    const fileName = file.name\n    const fileType = file.type\n\n    // 创建取消控制器\n    const controller = new AbortController()\n    uploadControllers.set(fileId, controller)\n\n    try {\n        // 生成上传会话唯一标识\n        const uploadId = Date.now() + Math.random().toString(36).substr(2, 9)\n\n        console.log(`开始分块上传: ${fileName}, 大小: ${fileSize}, 分块数: ${chunks}`)\n\n        // 初始化上传会话\n        const initResponse = await fetch(`${API_BASE_URL}/files/chunk-upload/init`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                fileId: fileId,\n                fileName: fileName,\n                fileSize: fileSize,\n                fileType: fileType,\n                totalChunks: chunks,\n                uploadId: uploadId\n            }),\n            signal: controller.signal\n        })\n\n        if (!initResponse.ok) {\n            throw new Error('初始化分块上传失败')\n        }\n\n        const initResult = await initResponse.json()\n        const sessionUploadId = initResult.uploadId || uploadId\n\n        // 上传分块\n        const uploadPromises = []\n        let uploadedChunks = 0\n\n        for (let i = 0; i < chunks; i++) {\n            const start = i * CHUNK_SIZE\n            const end = Math.min(start + CHUNK_SIZE, fileSize)\n            const chunk = file.slice(start, end)\n\n            const uploadPromise = uploadChunk(sessionUploadId, i, chunk, chunks, controller.signal)\n                .then(() => {\n                    uploadedChunks++\n                    if (onProgress) {\n                        onProgress({\n                            loaded: uploadedChunks * CHUNK_SIZE,\n                            total: fileSize,\n                            percentage: Math.round((uploadedChunks / chunks) * 100)\n                        })\n                    }\n                })\n\n            uploadPromises.push(uploadPromise)\n\n            // 控制并发数\n            if (uploadPromises.length >= MAX_CONCURRENT_CHUNKS) {\n                await Promise.all(uploadPromises)\n                uploadPromises.length = 0\n            }\n        }\n\n        // 等待所有分块上传完成\n        if (uploadPromises.length > 0) {\n            await Promise.all(uploadPromises)\n        }\n\n        // 完成上传\n        const completeResponse = await fetch(`${API_BASE_URL}/files/chunk-upload/complete`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                uploadId: sessionUploadId,\n                fileId: fileId\n            }),\n            signal: controller.signal\n        })\n\n        if (!completeResponse.ok) {\n            throw new Error('完成分块上传失败')\n        }\n\n        const result = await completeResponse.json()\n        console.log('分块上传完成:', result)\n\n        return result\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.log('分块上传被取消')\n            throw new Error('上传被取消')\n        }\n        throw error\n    } finally {\n        // 清理控制器\n        uploadControllers.delete(fileId)\n    }\n}\n\n/**\n * 上传单个分块\n * @param {string} uploadId - 上传会话ID\n * @param {number} chunkIndex - 分块索引\n * @param {Blob} chunk - 分块数据\n * @param {number} totalChunks - 总分块数\n * @param {AbortSignal} signal - 取消信号\n * @returns {Promise<void>}\n */\nasync function uploadChunk(uploadId, chunkIndex, chunk, totalChunks, signal) {\n    const formData = new FormData()\n    formData.append('uploadId', uploadId)\n    formData.append('chunkIndex', chunkIndex)\n    formData.append('chunk', chunk)\n    formData.append('totalChunks', totalChunks)\n\n    const response = await fetch(`${API_BASE_URL}/files/chunk-upload/chunk`, {\n        method: 'POST',\n        body: formData,\n        signal: signal\n    })\n\n    if (!response.ok) {\n        throw new Error(`上传分块 ${chunkIndex} 失败`)\n    }\n\n    console.log(`分块 ${chunkIndex + 1}/${totalChunks} 上传成功`)\n}\n\n/**\n * 普通上传文件\n * @param {File} file - 文件对象\n * @param {Function} onProgress - 进度回调\n * @returns {Promise<Object>} 上传结果\n */\nasync function normalUpload(file, onProgress) {\n    const formData = new FormData()\n    formData.append('file', file)\n\n    const xhr = new XMLHttpRequest()\n\n    return new Promise((resolve, reject) => {\n        xhr.upload.onprogress = (event) => {\n            if (event.lengthComputable && onProgress) {\n                onProgress({\n                    loaded: event.loaded,\n                    total: event.total,\n                    percentage: Math.round((event.loaded / event.total) * 100)\n                })\n            }\n        }\n\n        xhr.onload = () => {\n            if (xhr.status === 200) {\n                try {\n                    const result = JSON.parse(xhr.responseText)\n                    resolve(result)\n                } catch (error) {\n                    reject(new Error('解析响应失败'))\n                }\n            } else {\n                reject(new Error(`上传失败: ${xhr.status} ${xhr.statusText}`))\n            }\n        }\n\n        xhr.onerror = () => {\n            reject(new Error('网络错误'))\n        }\n\n        xhr.open('POST', `${API_BASE_URL}/files/upload`)\n        xhr.send(formData)\n    })\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}