{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n  return data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// Hermite插值函数，供单调、Akima、Cardinal等插值方法调用\nfunction hermite(t, y0, y1, m0, m1) {\n  // t: [0,1]，y0/y1: 端点，m0/m1: 端点切线\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return (2 * t3 - 3 * t2 + 1) * y0 + (t3 - 2 * t2 + t) * m0 + (-2 * t3 + 3 * t2) * y1 + (t3 - t2) * m1;\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  return ecStat.missingValue.linearInterpolate;\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 找前一个和后一个非空\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 线性插值\n        result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n  // 首先构造自然三次样条的求解函数\n  function cubicSplineCoefficients(x, y) {\n    const n = x.length;\n    const a = y.slice();\n    const h = new Array(n - 1);\n    const alpha = new Array(n - 1);\n    for (let i = 0; i < n - 1; i++) {\n      h[i] = x[i + 1] - x[i];\n      if (h[i] <= 0) {\n        throw new Error('x values must be strictly increasing');\n      }\n    }\n    for (let i = 1; i < n - 1; i++) {\n      alpha[i] = 3 / h[i] * (a[i + 1] - a[i]) - 3 / h[i - 1] * (a[i] - a[i - 1]);\n    }\n    const l = [1],\n      mu = [0],\n      z = [0];\n    for (let i = 1; i < n - 1; i++) {\n      l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n      mu[i] = h[i] / l[i];\n      z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n    }\n    l[n - 1] = 1;\n    z[n - 1] = 0;\n    const c = Array(n).fill(0);\n    const b = Array(n - 1);\n    const d = Array(n - 1);\n    for (let j = n - 2; j >= 0; j--) {\n      c[j] = z[j] - mu[j] * c[j + 1];\n      b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n      d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n    }\n    return {\n      a,\n      b,\n      c,\n      d,\n      x\n    };\n  }\n\n  // 然后构造样条插值函数\n  function cubicSplineInterpolate(xi, coefs) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      x\n    } = coefs;\n    let i = x.length - 2;\n    for (let j = 0; j < x.length - 1; j++) {\n      if (xi >= x[j] && xi <= x[j + 1]) {\n        i = j;\n        break;\n      }\n    }\n    const dx = xi - x[i];\n    return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n  }\n\n  // 主函数\n  console.log('[fillCubicSpline] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  if (valid.length < 3) {\n    console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n    return result;\n  }\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const coefs = cubicSplineCoefficients(x, y);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      result[i] = cubicSplineInterpolate(i, coefs);\n    }\n  }\n  return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n  console.log('[fillPolynomial] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  function lagrange(x) {\n    let y = 0;\n    for (let i = 0; i < n; i++) {\n      let term = valid[i].y;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n        }\n      }\n      y += term;\n    }\n    return y;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lagrange(i);\n    }\n  }\n  return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n  console.log('[fillStepBefore] method is working');\n  const result = [...data];\n  let lastVal = null;\n  for (let i = 1; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n  console.log('[fillStepAfter] method is working');\n  const result = [...data];\n  let lastVal = null;\n  for (let i = result.length - 2; i >= 0; i--) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n  // 首先构造均匀节点向量(open uniform knot vector)\n  function createUniformKnotVector(n, degree) {\n    const m = n + degree + 1;\n    const knots = [];\n    for (let i = 0; i < m; i++) {\n      if (i < degree) knots.push(0);else if (i > n) knots.push(n - degree + 1);else knots.push(i - degree);\n    }\n    return knots;\n  }\n\n  // 然后递归 de Boor 算法计算 B 样条点\n  function deBoor(i, k, t, knots, ctrlPoints) {\n    if (k === 0) return ctrlPoints[i];\n    const alpha = (t - knots[i]) / (knots[i + k] - knots[i]);\n    const left = deBoor(i - 1, k - 1, t, knots, ctrlPoints);\n    const right = deBoor(i, k - 1, t, knots, ctrlPoints);\n    return (1 - alpha) * left + alpha * right;\n  }\n\n  // 主函数\n  console.log('[fillBasis] method is working');\n  const result = [...data];\n  const valid = data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n  const degree = 3;\n  const n = valid.length - 1;\n  if (n < degree) {\n    console.warn('[fillBasis] Not enough valid points for B-spline');\n    return result;\n  }\n  const ctrlX = valid.map(p => p.x);\n  const ctrlY = valid.map(p => p.y);\n  const knots = createUniformKnotVector(n, degree);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const t = i * (n - degree + 1) / (result.length - 1); // 归一化到 knot domain\n      // 找起始区间索引 i，使 knots[i] <= t < knots[i+1]\n      let j = degree;\n      while (j < knots.length - 1 && t >= knots[j + 1]) j++;\n\n      // de Boor 插值\n      result[i] = deBoor(j, degree, t, knots, ctrlY);\n    }\n  }\n  return result;\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n  console.log('[fillCardinal] method is working');\n  const result = [...data];\n  const valid = data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n  if (valid.length < 4) {\n    console.warn('[fillCardinal] Not enough points');\n    return result;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const p1Idx = valid.findIndex(p => p.x > i);\n      const p0Idx = p1Idx - 2;\n      if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n      const P0 = valid[p0Idx].y;\n      const P1 = valid[p0Idx + 1].y;\n      const P2 = valid[p0Idx + 2].y;\n      const P3 = valid[p0Idx + 3].y;\n      const x0 = valid[p0Idx + 1].x;\n      const x1 = valid[p0Idx + 2].x;\n      const t = (i - x0) / (x1 - x0); // normalized position\n      const t2 = t * t,\n        t3 = t2 * t;\n      result[i] = 0.5 * (2 * P1 + (-P0 + P2) * t + (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 + (-P0 + 3 * P1 - 3 * P2 + P3) * t3);\n    }\n  }\n  return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n  console.log('[fillMonotone] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 3) return result;\n\n  // 预计算斜率\n  const dx = [],\n    dy = [],\n    m = [],\n    t = [];\n  for (let i = 0; i < n - 1; i++) {\n    dx[i] = valid[i + 1].x - valid[i].x;\n    dy[i] = valid[i + 1].y - valid[i].y;\n    m[i] = dy[i] / dx[i];\n  }\n  t[0] = m[0];\n  for (let i = 1; i < n - 1; i++) {\n    if (m[i - 1] * m[i] <= 0) {\n      t[i] = 0;\n    } else {\n      const w1 = 2 * dx[i] + dx[i - 1];\n      const w2 = dx[i] + 2 * dx[i - 1];\n      t[i] = w1 + w2 === 0 ? 0 : (w1 + w2) / (w1 / m[i - 1] + w2 / m[i]);\n    }\n  }\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = valid[idx - 1].x;\n      const x1 = valid[idx].x;\n      const y0 = valid[idx - 1].y;\n      const y1 = valid[idx].y;\n      const t0 = t[idx - 1];\n      const t1 = t[idx];\n      const h = x1 - x0;\n      const s = (i - x0) / h;\n      result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n    }\n  }\n  return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n  console.log('[fillAkima] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 5) return result;\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const m = new Array(n - 1);\n  for (let i = 0; i < n - 1; i++) {\n    m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n  }\n  const t = [];\n  for (let i = 2; i < n - 2; i++) {\n    const w1 = Math.abs(m[i + 1] - m[i]);\n    const w2 = Math.abs(m[i - 1] - m[i - 2]);\n    t[i] = w1 + w2 === 0 ? (m[i - 1] + m[i]) / 2 : (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n  }\n  // 端点斜率回退为邻近斜率\n  t[0] = m[0];\n  t[1] = m[1];\n  t[n - 2] = m[n - 2];\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = x[idx - 1],\n        x1 = x[idx];\n      const y0 = y[idx - 1],\n        y1 = y[idx];\n      const s = (i - x0) / (x1 - x0);\n      const t0 = t[idx - 1] * (x1 - x0);\n      const t1 = t[idx] * (x1 - x0);\n      result[i] = hermite(s, y0, y1, t0, t1);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["getValidPoints","data","map","y","x","filter","p","isNaN","hermite","t","y0","y1","m0","m1","t2","t3","ignoreNull","console","log","fillZero","v","undefined","Number","fillNearest","ecStat","missingValue","linearInterpolate","result","i","length","prev","next","fillCubicSpline","cubicSplineCoefficients","n","a","slice","h","Array","alpha","Error","l","mu","z","c","fill","b","d","j","cubicSplineInterpolate","xi","coefs","dx","valid","warn","fillPolynomial","lagrange","term","fillStepBefore","lastVal","fillStepAfter","fillBasis","createUniformKnotVector","degree","m","knots","push","deBoor","k","ctrlPoints","left","right","ctrlX","ctrlY","fillCardinal","p1Idx","findIndex","p0Idx","P0","P1","P2","P3","x0","x1","fillMonotone","dy","w1","w2","idx","t0","t1","s","fillAkima","Math","abs"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n    return data.map((y, x) => ({ x, y })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// Hermite插值函数，供单调、Akima、Cardinal等插值方法调用\nfunction hermite(t, y0, y1, m0, m1) {\n    // t: [0,1]，y0/y1: 端点，m0/m1: 端点切线\n    const t2 = t * t;\n    const t3 = t2 * t;\n    return (\n        (2 * t3 - 3 * t2 + 1) * y0 +\n        (t3 - 2 * t2 + t) * m0 +\n        (-2 * t3 + 3 * t2) * y1 +\n        (t3 - t2) * m1\n    );\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    \n    return ecStat.missingValue.linearInterpolate\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 找前一个和后一个非空\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 线性插值\n                result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n    // 首先构造自然三次样条的求解函数\n    function cubicSplineCoefficients(x, y) {\n        const n = x.length;\n        const a = y.slice();\n        const h = new Array(n - 1);\n        const alpha = new Array(n - 1);\n\n        for (let i = 0; i < n - 1; i++) {\n            h[i] = x[i + 1] - x[i];\n            if (h[i] <= 0) {\n                throw new Error('x values must be strictly increasing');\n            }\n        }\n        for (let i = 1; i < n - 1; i++) {\n            alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1]);\n        }\n\n        const l = [1], mu = [0], z = [0];\n        for (let i = 1; i < n - 1; i++) {\n            l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n            mu[i] = h[i] / l[i];\n            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n        }\n        l[n - 1] = 1;\n        z[n - 1] = 0;\n\n        const c = Array(n).fill(0);\n        const b = Array(n - 1);\n        const d = Array(n - 1);\n\n        for (let j = n - 2; j >= 0; j--) {\n            c[j] = z[j] - mu[j] * c[j + 1];\n            b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n            d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n        }\n        return { a, b, c, d, x };\n    }\n\n    // 然后构造样条插值函数\n    function cubicSplineInterpolate(xi, coefs) {\n        const { a, b, c, d, x } = coefs;\n        let i = x.length - 2;\n\n        for (let j = 0; j < x.length - 1; j++) {\n            if (xi >= x[j] && xi <= x[j + 1]) {\n                i = j;\n                break;\n            }\n        }\n\n        const dx = xi - x[i];\n        return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n    }\n\n    // 主函数\n    console.log('[fillCubicSpline] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n\n    if (valid.length < 3) {\n        console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n        return result;\n    }\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const coefs = cubicSplineCoefficients(x, y);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            result[i] = cubicSplineInterpolate(i, coefs);\n        }\n    }\n\n    return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n    console.log('[fillPolynomial] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n    function lagrange(x) {\n        let y = 0;\n        for (let i = 0; i < n; i++) {\n            let term = valid[i].y;\n            for (let j = 0; j < n; j++) {\n                if (i !== j) {\n                    term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n                }\n            }\n            y += term;\n        }\n        return y;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lagrange(i);\n        }\n    }\n    return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n    console.log('[fillStepBefore] method is working');\n    const result = [...data];\n    let lastVal = null;\n    for (let i = 1; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n    console.log('[fillStepAfter] method is working');\n    const result = [...data];\n    let lastVal = null;\n    for (let i = result.length - 2; i >= 0; i--) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n    // 首先构造均匀节点向量(open uniform knot vector)\n    function createUniformKnotVector(n, degree) {\n        const m = n + degree + 1;\n        const knots = [];\n        for (let i = 0; i < m; i++) {\n            if (i < degree) knots.push(0);\n            else if (i > n) knots.push(n - degree + 1);\n            else knots.push(i - degree);\n        }\n        return knots;\n    }\n\n    // 然后递归 de Boor 算法计算 B 样条点\n    function deBoor(i, k, t, knots, ctrlPoints) {\n        if (k === 0) return ctrlPoints[i];\n\n        const alpha = (t - knots[i]) / (knots[i + k] - knots[i]);\n        const left = deBoor(i - 1, k - 1, t, knots, ctrlPoints);\n        const right = deBoor(i, k - 1, t, knots, ctrlPoints);\n\n        return (1 - alpha) * left + alpha * right;\n    }\n\n    // 主函数\n    console.log('[fillBasis] method is working');\n\n    const result = [...data];\n    const valid = data.map((y, x) => ({ x, y }))\n        .filter(p => p.y != null && !isNaN(p.y));\n\n    const degree = 3;\n    const n = valid.length - 1;\n    if (n < degree) {\n        console.warn('[fillBasis] Not enough valid points for B-spline');\n        return result;\n    }\n\n    const ctrlX = valid.map(p => p.x);\n    const ctrlY = valid.map(p => p.y);\n    const knots = createUniformKnotVector(n, degree);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const t = i * (n - degree + 1) / (result.length - 1);  // 归一化到 knot domain\n            // 找起始区间索引 i，使 knots[i] <= t < knots[i+1]\n            let j = degree;\n            while (j < knots.length - 1 && t >= knots[j + 1]) j++;\n\n            // de Boor 插值\n            result[i] = deBoor(j, degree, t, knots, ctrlY);\n        }\n    }\n\n    return result;\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n    console.log('[fillCardinal] method is working');\n\n    const result = [...data];\n    const valid = data.map((y, x) => ({ x, y }))\n        .filter(p => p.y != null && !isNaN(p.y));\n\n    if (valid.length < 4) {\n        console.warn('[fillCardinal] Not enough points');\n        return result;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const p1Idx = valid.findIndex(p => p.x > i);\n            const p0Idx = p1Idx - 2;\n            if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n\n            const P0 = valid[p0Idx].y;\n            const P1 = valid[p0Idx + 1].y;\n            const P2 = valid[p0Idx + 2].y;\n            const P3 = valid[p0Idx + 3].y;\n\n            const x0 = valid[p0Idx + 1].x;\n            const x1 = valid[p0Idx + 2].x;\n\n            const t = (i - x0) / (x1 - x0); // normalized position\n            const t2 = t * t, t3 = t2 * t;\n\n            result[i] = 0.5 * (\n                (2 * P1) +\n                (-P0 + P2) * t +\n                (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 +\n                (-P0 + 3 * P1 - 3 * P2 + P3) * t3\n            );\n        }\n    }\n\n    return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n    console.log('[fillMonotone] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 3) return result;\n\n    // 预计算斜率\n    const dx = [], dy = [], m = [], t = [];\n    for (let i = 0; i < n - 1; i++) {\n        dx[i] = valid[i + 1].x - valid[i].x;\n        dy[i] = valid[i + 1].y - valid[i].y;\n        m[i] = dy[i] / dx[i];\n    }\n\n    t[0] = m[0];\n    for (let i = 1; i < n - 1; i++) {\n        if (m[i - 1] * m[i] <= 0) {\n            t[i] = 0;\n        } else {\n            const w1 = 2 * dx[i] + dx[i - 1];\n            const w2 = dx[i] + 2 * dx[i - 1];\n            t[i] = (w1 + w2) === 0 ? 0 : (w1 + w2) / ((w1 / m[i - 1]) + (w2 / m[i]));\n        }\n    }\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = valid[idx - 1].x;\n            const x1 = valid[idx].x;\n            const y0 = valid[idx - 1].y;\n            const y1 = valid[idx].y;\n            const t0 = t[idx - 1];\n            const t1 = t[idx];\n\n            const h = x1 - x0;\n            const s = (i - x0) / h;\n            result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n        }\n    }\n\n    return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n    console.log('[fillAkima] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 5) return result;\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const m = new Array(n - 1);\n\n    for (let i = 0; i < n - 1; i++) {\n        m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n    }\n\n    const t = [];\n    for (let i = 2; i < n - 2; i++) {\n        const w1 = Math.abs(m[i + 1] - m[i]);\n        const w2 = Math.abs(m[i - 1] - m[i - 2]);\n        t[i] = (w1 + w2 === 0) ? ((m[i - 1] + m[i]) / 2) :\n            (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n    }\n    // 端点斜率回退为邻近斜率\n    t[0] = m[0];\n    t[1] = m[1];\n    t[n - 2] = m[n - 2];\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = x[idx - 1], x1 = x[idx];\n            const y0 = y[idx - 1], y1 = y[idx];\n            const s = (i - x0) / (x1 - x0);\n            const t0 = t[idx - 1] * (x1 - x0);\n            const t1 = t[idx] * (x1 - x0);\n\n            result[i] = hermite(s, y0, y1, t0, t1);\n        }\n    }\n\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}