{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n  return data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n/**\n * 直接忽略缺失值（null/undefined/NaN）\n * @param {Array} data\n * @returns {Array}\n */\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  return data;\n}\n\n/**\n * 缺失值填充为0\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n/**\n * 用最近的非空值填充缺失值（前向/后向最近邻）\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 前向查找\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      // 后向查找\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 距离更近的邻居\n        result[i] = i - prev <= next - i ? result[prev] : result[next];\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * 线性插值填充缺失值\n * @param {Array} data\n * @returns {Array}\n */\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 找前一个和后一个非空\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 线性插值\n        result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\nexport function fillSpline(data) {\n  console.log('[fillSpline] method is working');\n}\nexport function fillPolynomial(data) {}\nexport function fillStepBefore(data) {\n  return ignoreNull(data);\n}\nexport function fillStepAfter(data) {\n  return ignoreNull(data);\n}\nexport function fillBasis(data) {\n  return ignoreNull(data);\n}\nexport function fillCardinal(data) {\n  return ignoreNull(data);\n}\nexport function fillMonotone(data) {\n  return ignoreNull(data);\n}\nexport function fillAkima(data) {\n  return ignoreNull(data);\n}","map":{"version":3,"names":["getValidPoints","data","map","y","x","filter","p","isNaN","ignoreNull","console","log","fillZero","v","undefined","Number","fillNearest","result","i","length","prev","next","linearInterpolate","fillSpline","fillPolynomial","fillStepBefore","fillStepAfter","fillBasis","fillCardinal","fillMonotone","fillAkima"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n    return data.map((y, x) => ({ x, y })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n/**\n * 直接忽略缺失值（null/undefined/NaN）\n * @param {Array} data\n * @returns {Array}\n */\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    return data;\n}\n\n/**\n * 缺失值填充为0\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n/**\n * 用最近的非空值填充缺失值（前向/后向最近邻）\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 前向查找\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            // 后向查找\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 距离更近的邻居\n                result[i] = (i - prev <= next - i) ? result[prev] : result[next];\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * 线性插值填充缺失值\n * @param {Array} data\n * @returns {Array}\n */\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 找前一个和后一个非空\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 线性插值\n                result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\nexport function fillSpline(data) {\n    console.log('[fillSpline] method is working');\n}\nexport function fillPolynomial(data) { }\nexport function fillStepBefore(data) { return ignoreNull(data); }\nexport function fillStepAfter(data) { return ignoreNull(data); }\nexport function fillBasis(data) { return ignoreNull(data); }\nexport function fillCardinal(data) { return ignoreNull(data); }\nexport function fillMonotone(data) { return ignoreNull(data); }\nexport function fillAkima(data) { return ignoreNull(data); }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}