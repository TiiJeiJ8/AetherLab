{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.flat-map.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n// dataMergeUtils.js\n// 多文件数据合并与主键处理工具函数\n// 根据不同图表类型，主函数分发到对应的处理器进行数据处理，生成能够绘制图表的数据\n\n/*\n关键函数 mergeChartData(config, fileDataMap, nullHandlingType, options)\n    参数校验 validateParams\n    类型\n    图表类型分发器 chartTypeHandlers[type]\n    数据提取 getDataRows\n    过滤器插件 options.filterPlugin 或 defaultFilterPlugin\n    缺失值处理插件 handleNulls (调用 nullHandlingModule 中的具体方法)\n    主键合并 如有多文件/多字段，合并主键\n    组装seriesData 生成最终用于图表的数据结构\n    返回 {xData, yDataArr, mergeType, seriesData}\n*/\n\n/* eslint-disable */\n\n/**\n * @typedef {Object} AxisConfig\n * @property {string} file - 数据文件名\n * @property {string} field - 字段名\n */\n\n/**\n * @typedef {Object} ChartConfig\n * @property {AxisConfig} [xAxis]\n * @property {AxisConfig|AxisConfig[]} [yAxis]\n * @property {AxisConfig} [category]\n * @property {AxisConfig} [value]\n * @property {Object} [filter]\n * @property {string} [type] - 图表类型，如 'pie', 'line', 'bar' 等\n */\n\n/**\n * @typedef {Object.<string, Array<Object>>} FileDataMap\n */\n\n/**\n * 判断是否有主键（即所有y轴字段的文件都包含x轴字段）\n * @param {AxisConfig} xAxis\n * @param {AxisConfig|AxisConfig[]} yAxis\n * @param {FileDataMap} fileDataMap\n * @returns {boolean}\n */\nexport function hasPrimaryKey(xAxis, yAxis, fileDataMap) {\n  if (!xAxis || !xAxis.field) return false;\n  const xField = xAxis.field;\n  const yArr = Array.isArray(yAxis) ? yAxis : [yAxis];\n  return yArr.every(y => {\n    const yFileData = fileDataMap[y.file];\n    return yFileData && yFileData.length > 0 && yFileData[0].hasOwnProperty(xField);\n  });\n}\n\n// ---------------- 通用数据处理工具函数 ----------------\n\n/**\n * 提取数据并去掉标题行\n * @param {FileDataMap} fileDataMap\n * @param {string} file\n * @returns {Array<Object>}\n */\nfunction getDataRows(fileDataMap, file) {\n  return (fileDataMap[file] || []).slice(1);\n}\n\n/**\n * 通用缺失值处理器分发\n * @param {string} type\n * @param {Array} arr\n * @param {Object} nullHandlingModule\n * @returns {Array}\n */\nfunction handleNulls(type, arr, nullHandlingModule) {\n  if (!type || type === 'ignore') return arr;\n  const handler = nullHandlingModule[type] || nullHandlingModule.ignoreNull;\n  return handler(arr);\n}\n\n/**\n * 参数校验\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n */\nfunction validateParams(config, fileDataMap) {\n  if (!config || typeof config !== 'object') throw new Error('config must be an object');\n  if (!fileDataMap || typeof fileDataMap !== 'object') throw new Error('fileDataMap must be an object');\n}\n\n// ---------------- 过滤器插件化 ----------------\n\n/**\n * 过滤器插件，默认实现\n * @param {Array} rows\n * @param {Object} filters\n * @returns {Array}\n */\nexport function defaultFilterPlugin(rows, filters) {\n  if (!filters || !filters.filters || !Array.isArray(filters.filters) || filters.filters.length === 0) return rows;\n  const logic = filters.logic || 'AND';\n  const conds = filters.filters || [];\n  console.log('[defaultFilterPlugin] Applying filters:', conds);\n  if (conds.length === 0) return rows;\n  return rows.filter(row => {\n    const results = conds.map(f => {\n      const val = row[f.field];\n      switch (f.type) {\n        case 'integer':\n          {\n            console.log(`[defaultFilterPlugin] Checking integer field ${f.field} with value ${val}`);\n            const num = parseFloat(val);\n            const cmp = parseFloat(f.value);\n            if (f.operator === 'eq') return num === cmp;\n            if (f.operator === 'ne') return num !== cmp;\n            if (f.operator === 'gt') return num > cmp;\n            if (f.operator === 'ge') return num >= cmp;\n            if (f.operator === 'lt') return num < cmp;\n            if (f.operator === 'le') return num <= cmp;\n            return true;\n          }\n        case 'string':\n          {\n            console.log(`[defaultFilterPlugin] Checking string field ${f.field} with value ${val}`);\n            const str = String(val ?? '');\n            const cmp = String(f.value ?? '');\n            if (f.operator === 'eq') return str === cmp;\n            if (f.operator === 'ne') return str !== cmp;\n            if (f.operator === 'contains') return str.includes(cmp);\n            if (f.operator === 'notcontains') return !str.includes(cmp);\n            if (f.operator === 'startsWith') return str.startsWith(cmp);\n            if (f.operator === 'endsWith') return str.endsWith(cmp);\n            return true;\n          }\n        case 'category':\n          {\n            console.log(`[defaultFilterPlugin] Checking category field ${f.field} with value ${val}`);\n            if (f.operator === 'eq') return val === f.value;\n            if (f.operator === 'ne') return val !== f.value;\n            if (f.operator === 'in') return Array.isArray(f.value) ? f.value.includes(val) : false;\n            if (f.operator === 'notin') return Array.isArray(f.value) ? !f.value.includes(val) : false;\n            return true;\n          }\n        case 'boolean':\n          {\n            console.log(`[defaultFilterPlugin] Checking boolean field ${f.field} with value ${val}`);\n            const boolVal = val === true || val === 'true' || val === 1 || val === '1';\n            const cmp = f.value === true || f.value === 'true' || f.value === 1 || f.value === '1';\n            if (f.operator === 'eq') return boolVal === cmp;\n            if (f.operator === 'ne') return boolVal !== cmp;\n            return true;\n          }\n        case 'date':\n          {\n            console.log(`[defaultFilterPlugin] Checking date field ${f.field} with value ${val}`);\n            const dateVal = new Date(val).getTime();\n            const cmp = new Date(f.value).getTime();\n            if (f.operator === 'eq') return dateVal === cmp;\n            if (f.operator === 'ne') return dateVal !== cmp;\n            if (f.operator === 'before') return dateVal < cmp;\n            if (f.operator === 'after') return dateVal > cmp;\n            return true;\n          }\n        default:\n          return true;\n      }\n    });\n    return logic === 'AND' ? results.every(Boolean) : results.some(Boolean);\n  });\n}\nimport BoxplotChartIcon from '../../../components/svg/BoxplotChartIcon.vue';\n/**\n * 合并多文件数据，返回 { xData, yDataArr, mergeType, seriesData }\n * @param {Object} config - chartConfig\n * @param {Object} fileDataMap - 文件名到对象数组的映射\n * @returns {Object}\n */\n\nimport * as nullHandling from './nullHandling.js';\n\n// ---------------- 图表类型处理器 ----------------\n\n// 调试输入函数\nfunction debugInput(config, fileDataMap, options) {\n  console.log('[--debugInput {Chart Type Processor}--] config:', config);\n  console.log('[--debugInput {Chart Type Processor}--] fileDataMap:', fileDataMap);\n  console.log('[--debugInput {Chart Type Processor}--] options:', options);\n}\n\n// 调试输出函数\nfunction debugOutput(series) {\n  // 遍历 series 中的所有项目\n  series.forEach((item, index) => {\n    console.log(`[--debugOutput {Chart Type Processor}--] ${index}:`, item);\n  });\n}\n\n/**\n * 通用 x/y 图表（如折线、柱状等）数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction xyChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  let {\n    nullHandlingType = 'ignore',\n    nullHandlingModule = nullHandling,\n    filterPlugin = defaultFilterPlugin\n  } = options;\n  let {\n    xAxis,\n    yAxis\n  } = config;\n  let mainData = getDataRows(fileDataMap, xAxis.file);\n  // 优先使用config.isAggregate，否则用options.isAggregate，默认true\n  let isAggregate = typeof config.isAggregate === 'boolean' ? config.isAggregate : typeof options.isAggregate === 'boolean' ? options.isAggregate : true;\n  let aggregateFn = options.aggregateFn;\n  // 应用过滤\n  if (config.filter && config.filter.filters && config.filter.filters.length) {\n    mainData = filterPlugin(mainData, config.filter);\n  }\n  // 只过滤空行，不去重\n  mainData = mainData.filter(row => {\n    const key = row[xAxis.field];\n    return key !== undefined && key !== null && key !== '';\n  });\n  const yArr = Array.isArray(yAxis) ? yAxis : [yAxis];\n  if (isAggregate) {\n    // 按 name 分组聚合，可自定义聚合方式\n    const groupMap = new Map(); // key: name, value: [ [y1, y2, ...], [y1, y2, ...], ... ]\n    for (const row of mainData) {\n      const key = row[xAxis.field];\n      if (!groupMap.has(key)) {\n        groupMap.set(key, yArr.map(() => []));\n      }\n      yArr.forEach((y, idx) => {\n        const rawVal = row[y.field];\n        const parsedVal = parseFloat(rawVal);\n        // console.log(`[xyChartHandler] key=${key}, rawVal=${rawVal}, parsedVal=${parsedVal}`);\n        if (rawVal !== null && rawVal !== undefined && rawVal !== '' && !Number.isNaN(parsedVal)) {\n          groupMap.get(key)[idx].push(parsedVal);\n        }\n      });\n    }\n    const xData = Array.from(groupMap.keys());\n    // 默认聚合函数为累加\n    const defaultAggregate = arr => arr.length === 0 ? null : arr.reduce((a, b) => a + b, 0);\n    const aggFn = typeof aggregateFn === 'function' ? aggregateFn : defaultAggregate;\n    let yDataArr = yArr.map((y, idx) => xData.map(name => aggFn(groupMap.get(name)[idx])));\n\n    // 应用缺失值处理\n    if (nullHandlingType && nullHandlingType !== 'ignore') {\n      yDataArr = yDataArr.map(arr => handleNulls(nullHandlingType, arr, nullHandlingModule));\n    }\n    return {\n      xData,\n      yDataArr,\n      mergeType: 'groupByName',\n      seriesData: []\n    };\n  } else {\n    // 返回原始未聚合数据\n    const xData = mainData.map(row => row[xAxis.field]);\n    let yDataArr = yArr.map(y => mainData.map(row => {\n      const rawVal = row[y.field];\n      const parsedVal = parseFloat(rawVal);\n      return rawVal === null || rawVal === undefined || rawVal === '' || Number.isNaN(parsedVal) ? null : parsedVal;\n    }));\n\n    // 应用缺失值处理\n    if (nullHandlingType && nullHandlingType !== 'ignore') {\n      yDataArr = yDataArr.map(arr => handleNulls(nullHandlingType, arr, nullHandlingModule));\n    }\n    return {\n      xData,\n      yDataArr,\n      mergeType: 'raw',\n      seriesData: []\n    };\n  }\n}\n\n/**\n * 饼图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction pieChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    filterPlugin = defaultFilterPlugin\n  } = options;\n  let catData = getDataRows(fileDataMap, config.category.file);\n  let valData = getDataRows(fileDataMap, config.value.file);\n  // 应用过滤\n  if (config.filter && config.filter.filters && config.filter.filters.length) {\n    catData = filterPlugin(catData, config.filter);\n    valData = filterPlugin(valData, config.filter);\n  }\n  const len = Math.min(catData.length, valData.length);\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    const name = catData[i][config.category.field];\n    const rawVal = valData[i][config.value.field];\n    const parsedVal = parseFloat(rawVal);\n    const val = rawVal === null || rawVal === undefined || rawVal === '' || Number.isNaN(parsedVal) ? null : parsedVal;\n    if (name !== undefined && name !== null && name !== '') {\n      result.push({\n        name,\n        value: val\n      });\n    }\n  }\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'pie',\n    seriesData: result\n  };\n}\n\n/**\n * 地图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction mapChartHandler(config, fileDataMap, options) {\n  debugInput(config, fileDataMap, options);\n  const seriesType = config.seriesType || 'map';\n\n  // 根据seriesType分发地图图表类型\n  if (seriesType === 'map') {\n    const {\n      nameField,\n      value\n    } = config;\n    // 提取数据\n    const dataRow = getDataRows(fileDataMap, value.file);\n\n    // 分离数据行\n    const nameFieldRow = dataRow[nameField.index];\n    const valueFieldRow = dataRow[value.field];\n    console.log(nameFieldRow, valueFieldRow);\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else if (seriesType === 'heatmap') {\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else if (seriesType === 'scatter') {\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else if (seriesType === 'pie') {\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else if (seriesType === 'bar') {\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else if (seriesType === 'lines') {\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  } else {\n    // 兜底\n    console.warn(`[mapChartHandler] Unsupported seriesType: ${seriesType}`);\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'map',\n      seriesData: []\n    };\n  }\n}\n\n/**\n * K线图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction candlestickChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    nullHandlingType = 'ignore',\n    nullHandlingModule = nullHandling,\n    filterPlugin = defaultFilterPlugin\n  } = options;\n  const {\n    time,\n    open,\n    close,\n    high,\n    low,\n    filter\n  } = config;\n  // 提取主文件数据\n  let mainData = getDataRows(fileDataMap, time.file);\n  if (filter && filter.filters && filter.filters.length) {\n    mainData = filterPlugin(mainData, filter);\n  }\n  // 按时间字段排序\n  mainData.sort((a, b) => {\n    if (a[time.field] < b[time.field]) return -1;\n    if (a[time.field] > b[time.field]) return 1;\n    return 0;\n  });\n  // 组装 xData 和 seriesData\n  const xData = mainData.map(row => row[time.field]);\n  const seriesData = mainData.map(row => {\n    const o = parseFloat(row[open.field]);\n    const c = parseFloat(row[close.field]);\n    const h = parseFloat(row[high.field]);\n    const l = parseFloat(row[low.field]);\n    // 缺失值处理\n    const arr = [o, c, l, h].map(v => v === null || v === undefined || v === '' || Number.isNaN(v) ? null : v);\n    return handleNulls(nullHandlingType, arr, nullHandlingModule);\n  });\n  return {\n    xData,\n    yDataArr: [seriesData],\n    mergeType: 'candlestick',\n    seriesData\n  };\n}\n\n/**\n * 热力图数据处理器（主键合并，一一对应）\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction heatmapChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    xAxis,\n    yAxis,\n    value\n  } = config;\n  // 获取所有数据行\n  const xRows = getDataRows(fileDataMap, xAxis.file);\n  const yRows = getDataRows(fileDataMap, yAxis.file);\n  const valRows = getDataRows(fileDataMap, value.file);\n\n  // 收集所有x、y的取值（类别）\n  const xSet = new Set(xRows.map(row => row[xAxis.field]));\n  const ySet = new Set(yRows.map(row => row[yAxis.field]));\n  const xData = Array.from(xSet);\n  const yData = Array.from(ySet);\n\n  // 构建value映射\n  const valueMap = new Map();\n  valRows.forEach(row => {\n    // 优先用valRows里的x/y字段，否则用xRows/yRows索引补齐\n    const x = row[xAxis.field] !== undefined ? row[xAxis.field] : null;\n    const y = row[yAxis.field] !== undefined ? row[yAxis.field] : null;\n    if (x !== null && y !== null) {\n      const key = `${x}|${y}`;\n      valueMap.set(key, row[value.field]);\n    }\n  });\n\n  // 生成 seriesData，补齐所有 (x, y) 组合\n  const seriesData = [];\n  yData.forEach(y => {\n    xData.forEach(x => {\n      const key = `${x}|${y}`;\n      const v = valueMap.has(key) ? valueMap.get(key) : null;\n      seriesData.push([x, y, v]);\n    });\n  });\n  return {\n    xData,\n    yData,\n    mergeType: 'heatmap',\n    seriesData\n  };\n}\n\n/**\n * 雷达图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction radarChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    indicator,\n    value,\n    name\n  } = config;\n\n  // 维度配置\n  const indicators = indicator.map(item => {\n    const rows = getDataRows(fileDataMap, item.file);\n    const values = rows.map(row => row[item.field]).filter(v => v !== undefined && v !== null);\n    const max = Math.ceil(Math.max(...values.map(v => Number(v))) * 1.2); // 乘以安全系数\n    return {\n      name: item.field,\n      max: max || 100\n    };\n  });\n\n  // 系列数据\n  const nameRows = getDataRows(fileDataMap, name.file);\n  const seriesData = nameRows.map(row => {\n    const values = value.map(item => row[item.field]);\n    return {\n      name: row[name.field],\n      value: values\n    };\n  });\n\n  // 先封装传输\n  const RadarPack = {\n    indicator: indicators,\n    seriesData_radar: seriesData\n  };\n  return {\n    xData: [],\n    yData: [],\n    mergeType: 'radar',\n    seriesData: RadarPack\n  };\n}\n\n/**\n * 箱线图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction boxplotChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  // 解析配置\n  const {\n    category,\n    series,\n    value,\n    min,\n    q1,\n    median,\n    q3,\n    max\n  } = config;\n  // 获取数据行\n  const catRows = getDataRows(fileDataMap, category.file);\n  const seriesRows = series ? getDataRows(fileDataMap, series.file) : null;\n  // 收集所有分组和系列\n  const xData = Array.from(new Set(catRows.map(row => row[category.field])));\n  let seriesList = seriesRows ? Array.from(new Set(seriesRows.map(row => row[series.field]))) : null;\n  if (!seriesList || seriesList.length === 0) seriesList = ['default'];\n  let useValue = !!value;\n  let valArrs = [];\n  if (useValue) {\n    if (Array.isArray(value)) {\n      valArrs = value.map(v => getDataRows(fileDataMap, v.file).map(row => parseFloat(row[v.field])));\n    } else {\n      valArrs = [getDataRows(fileDataMap, value.file).map(row => parseFloat(row[value.field]))];\n    }\n  }\n\n  // 构建分组：series -> category -> [values]\n  const groupMap = new Map(); // key: series, value: Map(category, [values])\n  catRows.forEach((row, idx) => {\n    const cat = row[category.field];\n    const ser = seriesRows && seriesRows[idx] && series.field ? seriesRows[idx][series.field] : 'default';\n    if (!groupMap.has(ser)) groupMap.set(ser, new Map());\n    const catMap = groupMap.get(ser);\n    if (!catMap.has(cat)) catMap.set(cat, []);\n    if (useValue) {\n      valArrs.forEach(arr => {\n        if (arr[idx] !== undefined && !Number.isNaN(arr[idx])) {\n          catMap.get(cat).push(arr[idx]);\n        }\n      });\n    }\n  });\n\n  // 计算统计量\n  function calcBoxStats(arr) {\n    if (!arr || arr.length === 0) return [null, null, null, null, null];\n    const sorted = arr.slice().sort((a, b) => a - b);\n    const minV = sorted[0];\n    const maxV = sorted[sorted.length - 1];\n    const medianV = quantile(sorted, 0.5);\n    const q1V = quantile(sorted, 0.25);\n    const q3V = quantile(sorted, 0.75);\n    return [minV, q1V, medianV, q3V, maxV];\n  }\n  function quantile(arr, q) {\n    const pos = (arr.length - 1) * q;\n    const base = Math.floor(pos);\n    const rest = pos - base;\n    if (arr[base + 1] !== undefined) {\n      return arr[base] + rest * (arr[base + 1] - arr[base]);\n    } else {\n      return arr[base];\n    }\n  }\n\n  // 计算异常值（outlier）\n  function calcOutliers(arr, stats) {\n    if (!arr || arr.length === 0) return [];\n    const [min, q1, median, q3, max] = stats;\n    // 1.5倍四分位距法\n    const IQR = q3 - q1;\n    const lower = q1 - 1.5 * IQR;\n    const upper = q3 + 1.5 * IQR;\n    return arr.filter(v => v < lower || v > upper);\n  }\n\n  // 组装 seriesData: 每个系列一个数组，数组顺序与 xData一致\n  let seriesData, outlierData;\n  if (useValue) {\n    // 自动计算五数和异常值\n    seriesData = seriesList.map(ser => {\n      const catMap = groupMap.get(ser) || new Map();\n      return xData.map(cat => calcBoxStats(catMap.get(cat) || []));\n    });\n    // 计算异常值\n    outlierData = seriesList.map(ser => {\n      const catMap = groupMap.get(ser) || new Map();\n      return xData.flatMap((cat, catIdx) => {\n        const arr = catMap.get(cat) || [];\n        const stats = seriesData[seriesList.indexOf(ser)][catIdx];\n        const outliers = calcOutliers(arr, stats);\n        // 返回 [x轴索引, 异常值]，ECharts scatter 需要这种格式\n        return outliers.map(v => [catIdx, v]);\n      });\n    });\n  } else {\n    // 直接读取五数\n    const minRows = min ? getDataRows(fileDataMap, min.file) : null;\n    const q1Rows = q1 ? getDataRows(fileDataMap, q1.file) : null;\n    const medianRows = median ? getDataRows(fileDataMap, median.file) : null;\n    const q3Rows = q3 ? getDataRows(fileDataMap, q3.file) : null;\n    const maxRows = max ? getDataRows(fileDataMap, max.file) : null;\n    seriesData = seriesList.map(ser => {\n      return xData.map((cat, idx) => {\n        let rowIdx = -1;\n        for (let i = 0; i < catRows.length; i++) {\n          const catVal = catRows[i][category.field];\n          const serVal = seriesRows ? seriesRows[i][series.field] : 'default';\n          if (catVal === cat && serVal === ser) {\n            rowIdx = i;\n            break;\n          }\n        }\n        if (rowIdx === -1) return [null, null, null, null, null];\n        return [minRows ? parseFloat(minRows[rowIdx][min.field]) : null, q1Rows ? parseFloat(q1Rows[rowIdx][q1.field]) : null, medianRows ? parseFloat(medianRows[rowIdx][median.field]) : null, q3Rows ? parseFloat(q3Rows[rowIdx][q3.field]) : null, maxRows ? parseFloat(maxRows[rowIdx][max.field]) : null];\n      });\n    });\n    // 无法自动计算异常值\n    outlierData = seriesList.map(() => []);\n  }\n  const boxplotPack = {\n    seriesList: seriesList,\n    seriesData_boxplot: seriesData,\n    outlierData: outlierData\n  };\n  return {\n    xData,\n    yDataArr: [],\n    mergeType: 'boxplot',\n    seriesData: boxplotPack\n  };\n}\n\n/**\n * 关系图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction graphChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options);\n  const {\n    nodeID,\n    nodeName,\n    nodeValue,\n    nodeCategory,\n    edgeSource,\n    edgeTarget,\n    edgeWeight\n  } = config;\n\n  // 必填字段校验\n  if (!nodeID || !nodeID.file || !nodeID.field) throw new Error('nodeID为必填项');\n  if (!edgeSource || !edgeSource.file || !edgeSource.field) throw new Error('edgeSource为必填项');\n  if (!edgeTarget || !edgeTarget.file || !edgeTarget.field) throw new Error('edgeTarget为必填项');\n\n  //获取数据行\n  const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n  const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n  const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n  const nodeCategoryRows = nodeCategory && nodeCategory.file ? getDataRows(fileDataMap, nodeCategory.file) : [];\n  const edgeSourceRows = getDataRows(fileDataMap, edgeSource.file);\n  const edgeTargetRows = getDataRows(fileDataMap, edgeTarget.file);\n  const edgeWeightRows = edgeWeight && edgeWeight.file ? getDataRows(fileDataMap, edgeWeight.file) : [];\n\n  // 节点去重，只保留每个id的第一个节点\n  const nodes = [];\n  const nodeSet = new Set();\n  nodeIDRows.forEach((row, idx) => {\n    const id = row[nodeID.field];\n    if (id !== undefined && id !== null && id !== '' && !nodeSet.has(id)) {\n      const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n      const value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : 1;\n      const category = nodeCategoryRows[idx] && nodeCategory && nodeCategory.field ? nodeCategoryRows[idx][nodeCategory.field] : '';\n      const node = {\n        id\n      };\n      if (name !== undefined) node.name = name;\n      if (value !== undefined) node.value = value;\n      if (category !== undefined) node.category = category;\n      nodes.push(node);\n      nodeSet.add(id);\n    }\n  });\n\n  // 生成边数据，source/target直接用id字符串\n  const edges = [];\n  edgeSourceRows.forEach((row, idx) => {\n    const source = row[edgeSource.field];\n    const target = edgeTargetRows[idx] ? edgeTargetRows[idx][edgeTarget.field] : undefined;\n    const weight = edgeWeightRows[idx] && edgeWeight && edgeWeight.field ? parseFloat(edgeWeightRows[idx][edgeWeight.field]) : 1;\n    if (source !== undefined && source !== null && source !== '' && target !== undefined && target !== null && target !== '') {\n      const edge = {\n        source: String(source),\n        target: String(target)\n      };\n      if (!isNaN(weight)) edge.weight = weight;\n      edges.push(edge);\n    }\n  });\n\n  // 打包\n  const graphPack = {\n    nodes: nodes,\n    edges: edges\n  };\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'graph',\n    seriesData: graphPack\n  };\n}\n\n/**\n * 树图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction treeChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    nodeID,\n    nodeName,\n    parentID,\n    parentName,\n    nodeValue,\n    path\n  } = config;\n  // 合理判定：有 nodeID 和 parentID 字段\n  const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n\n  // 平铺模式处理\n  if (isValid) {\n    const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n    const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n    const parentIDRows = getDataRows(fileDataMap, parentID.file);\n    const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n    const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n    // 构建节点映射\n    const nodeMap = new Map();\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      if (!id) return;\n      const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n      const value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n      nodeMap.set(id, {\n        id,\n        name,\n        value,\n        children: []\n      });\n    });\n\n    // 构建树结构\n    let rootNodes = [];\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n      if (!parentId || !nodeMap.has(parentId)) {\n        // 没有父节点，认为是根节点\n        rootNodes.push(nodeMap.get(id));\n      } else {\n        nodeMap.get(parentId).children.push(nodeMap.get(id));\n      }\n    });\n\n    // 只返回根节点数组\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'tree',\n      seriesData: rootNodes\n    };\n  }\n\n  // 兜底\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'tree',\n    seriesData: []\n  };\n}\n\n/**\n * 矩形树图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction treemapChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    nodeID,\n    nodeName,\n    parentID,\n    parentName,\n    nodeValue\n  } = config;\n  // 判定数据是否有效\n  const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n  if (isValid) {\n    const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n    const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n    const parentIDRows = getDataRows(fileDataMap, parentID.file);\n    const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n    const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n    // 构建节点映射\n    const nodeMap = new Map();\n    // 先收集所有 parentId，便于后续层级计算\n    const parentIdSet = new Set();\n    parentIDRows.forEach(row => {\n      if (row && parentID && parentID.field) {\n        const pid = row[parentID.field];\n        if (pid) parentIdSet.add(pid);\n      }\n    });\n\n    // 计算每个节点的层级（根节点为1，子节点依次+1）\n    function getLevel(id, cache = {}) {\n      if (cache[id]) return cache[id];\n      let level = 1;\n      let currentId = id;\n      let idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n      while (idx !== -1) {\n        const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n        if (!parentId || !nodeMap.has(parentId)) break;\n        level++;\n        currentId = parentId;\n        idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n      }\n      cache[id] = level;\n      return level;\n    }\n\n    // 统计最大层级\n    let maxLevel = 1;\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      const level = getLevel(id);\n      if (level > maxLevel) maxLevel = level;\n    });\n\n    // 构建节点，value 按层级递减（根节点最大，叶子最小）\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      if (!id) return;\n      const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n      let value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n      // 层级递减赋值，根节点 value = maxLevel，下一层 maxLevel-1，依次类推\n      if (value === undefined || value === null || isNaN(value)) {\n        const level = getLevel(id);\n        value = Math.max(1, maxLevel - level + 1);\n      }\n      nodeMap.set(id, {\n        id,\n        name,\n        value,\n        children: []\n      });\n    });\n\n    // 构建树结构\n    let rootNodes = [];\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n      if (!parentId || !nodeMap.has(parentId)) {\n        // 没有父节点，认为是根节点\n        rootNodes.push(nodeMap.get(id));\n      } else {\n        nodeMap.get(parentId).children.push(nodeMap.get(id));\n      }\n    });\n\n    // 递归获取最大层级\n    function getMaxDepth(nodes, depth) {\n      if (!nodes || nodes.length === 0) return depth;\n      let max = depth;\n      for (let i = 0; i < nodes.length; i++) {\n        max = Math.max(max, getMaxDepth(nodes[i].children, depth + 1));\n      }\n      return max;\n    }\n    const maxDepth = getMaxDepth(rootNodes, 1);\n\n    // 递归分配 value：有原始 value 则保留，无则自动分配\n    function assignValue(nodes) {\n      if (!nodes) return 0;\n      for (let i = 0; i < nodes.length; i++) {\n        if (!nodes[i].children || nodes[i].children.length === 0) {\n          if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n            nodes[i].value = 1;\n          }\n        } else {\n          if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n            nodes[i].value = assignValue(nodes[i].children);\n          } else {\n            // 有 value 时，仍需递归处理子节点\n            assignValue(nodes[i].children);\n          }\n        }\n      }\n      // 返回所有节点 value 之和\n      return nodes.reduce((sum, node) => sum + (node.value || 0), 0);\n    }\n    assignValue(rootNodes);\n\n    // Treemap 要求每个节点有 value, 非叶子节点 value 可为 undefined\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'treemap',\n      seriesData: rootNodes\n    };\n  }\n\n  // 兜底\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'treemap',\n    seriesData: []\n  };\n}\n\n/**\n * 旭日图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction sunburstChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options)\n  const {\n    nodeID,\n    nodeName,\n    parentID,\n    parentName,\n    nodeValue\n  } = config;\n  // 判定数据是否有效\n  const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n  if (isValid) {\n    const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n    const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n    const parentIDRows = getDataRows(fileDataMap, parentID.file);\n    const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n    const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n    // 构建节点映射\n    const nodeMap = new Map();\n    // 先收集所有 parentId，便于后续层级计算\n    const parentIdSet = new Set();\n    parentIDRows.forEach(row => {\n      if (row && parentID && parentID.field) {\n        const pid = row[parentID.field];\n        if (pid) parentIdSet.add(pid);\n      }\n    });\n\n    // 计算每个节点的层级（根节点为1，子节点依次+1）\n    function getLevel(id, cache = {}) {\n      if (cache[id]) return cache[id];\n      let level = 1;\n      let currentId = id;\n      let idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n      while (idx !== -1) {\n        const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n        if (!parentId || !nodeMap.has(parentId)) break;\n        level++;\n        currentId = parentId;\n        idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n      }\n      cache[id] = level;\n      return level;\n    }\n\n    // 统计最大层级\n    let maxLevel = 1;\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      const level = getLevel(id);\n      if (level > maxLevel) maxLevel = level;\n    });\n\n    // 构建节点，value 按层级递减（根节点最大，叶子最小）\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      if (!id) return;\n      const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n      let value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n      // 层级递减赋值，根节点 value = maxLevel，下一层 maxLevel-1，依次类推\n      if (value === undefined || value === null || isNaN(value)) {\n        const level = getLevel(id);\n        value = Math.max(1, maxLevel - level + 1);\n      }\n      nodeMap.set(id, {\n        id,\n        name,\n        value,\n        children: []\n      });\n    });\n\n    // 构建树结构\n    let rootNodes = [];\n    nodeIDRows.forEach((row, idx) => {\n      const id = row[nodeID.field];\n      const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n      if (!parentId || !nodeMap.has(parentId)) {\n        // 没有父节点，认为是根节点\n        rootNodes.push(nodeMap.get(id));\n      } else {\n        nodeMap.get(parentId).children.push(nodeMap.get(id));\n      }\n    });\n\n    // 递归获取最大层级\n    function getMaxDepth(nodes, depth) {\n      if (!nodes || nodes.length === 0) return depth;\n      let max = depth;\n      for (let i = 0; i < nodes.length; i++) {\n        max = Math.max(max, getMaxDepth(nodes[i].children, depth + 1));\n      }\n      return max;\n    }\n    const maxDepth = getMaxDepth(rootNodes, 1);\n\n    // 递归分配 value：有原始 value 则保留，无则自动分配\n    function assignValue(nodes) {\n      if (!nodes) return 0;\n      for (let i = 0; i < nodes.length; i++) {\n        if (!nodes[i].children || nodes[i].children.length === 0) {\n          if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n            nodes[i].value = 1;\n          }\n        } else {\n          if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n            nodes[i].value = assignValue(nodes[i].children);\n          } else {\n            // 有 value 时，仍需递归处理子节点\n            assignValue(nodes[i].children);\n          }\n        }\n      }\n      // 返回所有节点 value 之和\n      return nodes.reduce((sum, node) => sum + (node.value || 0), 0);\n    }\n    assignValue(rootNodes);\n\n    // Sunburst 要求每个节点有 value, 非叶子节点 value 可为 undefined\n    return {\n      xData: [],\n      yDataArr: [],\n      mergeType: 'sunburst',\n      seriesData: rootNodes\n    };\n  }\n\n  // 兜底\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'sunburst',\n    seriesData: []\n  };\n}\n\n/**\n * 平行坐标系图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction parallelChartHandler(config, fileDataMap, options) {\n  const {\n    dimensions,\n    nameField\n  } = config;\n  const {\n    nullHandlingType = 'ignore',\n    nullHandlingModule = nullHandling\n  } = options;\n  const mainFile = dimensions[0].file;\n  const rows = getDataRows(fileDataMap, mainFile);\n\n  // 过滤掉所有维度都为空的行\n  const filteredRows = rows.filter(row => dimensions.some(dim => {\n    const v = row[dim.field];\n    return v !== undefined && v !== null && v !== '';\n  }));\n\n  // 按列收集数据\n  const dimData = dimensions.map(dim => filteredRows.map(row => {\n    const v = row[dim.field];\n    const num = parseFloat(v);\n    return v === null || v === undefined || v === '' || Number.isNaN(num) ? null : num;\n  }));\n\n  // 缺失值处理\n  const handledDimData = dimData.map(arr => nullHandlingType && nullHandlingType !== 'ignore' ? (nullHandlingModule[nullHandlingType] || (d => d))(arr) : arr);\n\n  // 重新组装为对象数组\n  const dimensionsRows = filteredRows.map((row, idx) => {\n    const obj = {};\n    dimensions.forEach((dim, dIdx) => {\n      obj[dim.field] = handledDimData[dIdx][idx];\n    });\n    return obj;\n  });\n  const nameRows = nameField ? filteredRows.map(row => ({\n    name: row[nameField.field]\n  })) : [];\n  const combinedRows = dimensionsRows.map((dimObj, idx) => ({\n    ...dimObj,\n    ...(nameRows[idx] || {})\n  }));\n  const seriesData = combinedRows;\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'parallel',\n    seriesData\n  };\n}\n\n/**\n * 桑基图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction sankeyChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options);\n  const {\n    source,\n    target,\n    value\n  } = config;\n\n  // 支持直接传入数组或文件字段\n  let sourceArr = Array.isArray(source) ? source : getDataRows(fileDataMap, source.file).map(row => row[source.field]);\n  let targetArr = Array.isArray(target) ? target : getDataRows(fileDataMap, target.file).map(row => row[target.field]);\n  let valueArr = Array.isArray(value) ? value : value ? getDataRows(fileDataMap, value.file).map(row => row[value.field]) : [];\n\n  // 合并为原始数组 [{Source, Target, Value}]\n  const raw = sourceArr.map((s, i) => ({\n    Source: s,\n    Target: targetArr[i],\n    Value: valueArr[i]\n  }));\n\n  // nodes: 所有唯一 Source/Target\n  const nodeSet = new Set();\n  raw.forEach(row => {\n    if (row.Source !== undefined && row.Source !== null && row.Source !== '') nodeSet.add(row.Source);\n    if (row.Target !== undefined && row.Target !== null && row.Target !== '') nodeSet.add(row.Target);\n  });\n  const nodes = Array.from(nodeSet).map(name => ({\n    name\n  }));\n\n  // links: { source, target, value }\n  const links = raw.map(row => ({\n    source: row.Source,\n    target: row.Target,\n    value: row.Value\n  }));\n  const seriesData = {\n    data: nodes,\n    links: links\n  };\n  return {\n    mergeType: 'sankey',\n    seriesData\n  };\n}\n\n/**\n * 漏斗图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction funnelChartHandler(config, fileDataMap, options) {\n  debugInput(config, fileDataMap, options);\n  const {\n    stage,\n    value\n  } = config;\n\n  // 获取数据行\n  const dataRows = getDataRows(fileDataMap, stage.file);\n  const funnelData = dataRows.map(row => ({\n    name: row[stage.field],\n    value: row[value.field]\n  }));\n  return {\n    xData: [],\n    yDataArr: [],\n    mergeType: 'funnel',\n    seriesData: funnelData\n  };\n}\n\n/**\n * 仪表盘图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction gaugeChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options);\n\n  const {\n    name,\n    value\n  } = config;\n\n  // 获取数据行\n  const dataRows = getDataRows(fileDataMap, name.file);\n  const nameData = dataRows.map(row => row[name.field]);\n  const valueData = dataRows.map(row => parseFloat(row[value.field]));\n  const gaugeData = {\n    name: nameData,\n    value: valueData\n  };\n  return {\n    mergeType: 'gauge',\n    seriesData: gaugeData\n  };\n}\n\n/**\n * 象形柱图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction pictorialBarChartHandler(config, fileDataMap, options) {\n  debugInput(config, fileDataMap, options);\n  return {};\n}\n\n/**\n * 主题河流图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction themeRiverChartHandler(config, fileDataMap, options) {\n  // debugInput(config, fileDataMap, options);\n\n  const {\n    date,\n    value,\n    category\n  } = config;\n\n  // 获取数据行\n  const dataRows = getDataRows(fileDataMap, date.file);\n\n  // 按顺序组合(date, value, category)\n  const seriesData = dataRows.map(row => [row[date.field], parseFloat(row[value.field]), row[category.field]]);\n  return {\n    mergeType: 'themeRiver',\n    seriesData\n  };\n}\n\n/**\n * 日历图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction calendarChartHandler(config, fileDataMap, options) {\n  debugInput(config, fileDataMap, options);\n  return {};\n}\n\n// ---------------- 图表类型分发器 ----------------\n\nconst chartTypeHandlers = {\n  Line: xyChartHandler,\n  Bar: xyChartHandler,\n  Pie: pieChartHandler,\n  Scatter: xyChartHandler,\n  Geo_Map: mapChartHandler,\n  Candlestick: candlestickChartHandler,\n  Heatmap: heatmapChartHandler,\n  Radar: radarChartHandler,\n  Boxplot: boxplotChartHandler,\n  Graph: graphChartHandler,\n  Tree: treeChartHandler,\n  Treemap: treemapChartHandler,\n  Sunburst: sunburstChartHandler,\n  Parallel: parallelChartHandler,\n  Sankey: sankeyChartHandler,\n  Funnel: funnelChartHandler,\n  Gauge: gaugeChartHandler,\n  PictorialBar: pictorialBarChartHandler,\n  ThemeRiver: themeRiverChartHandler,\n  Calendar: calendarChartHandler\n  // 其他类型可继续扩展\n};\n\n/**\n * 主入口：合并多文件数据，返回 { xData, yDataArr, mergeType, seriesData }\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {string} [nullHandlingType]\n * @param {Object} [options] - 可选项：filterPlugin, nullHandlingModule\n * @returns {Object}\n */\nexport function mergeChartData(config, fileDataMap, nullHandlingType = 'ignore', options = {}) {\n  validateParams(config, fileDataMap);\n  let chartType = config.type;\n  console.log('[mergeChartData] Inferred chart type:', chartType);\n  const handler = chartTypeHandlers[chartType] || xyChartHandler;\n  console.log('[mergeChartData] Handler:', handler);\n\n  // 允许config.isAggregate传递到handler\n  return handler(config, fileDataMap, {\n    ...options,\n    nullHandlingType,\n    isAggregate: config.isAggregate\n  });\n}\n\n// applyFiltersToRows 已被插件化，见 defaultFilterPlugin","map":{"version":3,"names":["hasPrimaryKey","xAxis","yAxis","fileDataMap","field","xField","yArr","Array","isArray","every","y","yFileData","file","length","hasOwnProperty","getDataRows","slice","handleNulls","type","arr","nullHandlingModule","handler","ignoreNull","validateParams","config","Error","defaultFilterPlugin","rows","filters","logic","conds","console","log","filter","row","results","map","f","val","num","parseFloat","cmp","value","operator","str","String","includes","startsWith","endsWith","boolVal","dateVal","Date","getTime","Boolean","some","BoxplotChartIcon","nullHandling","debugInput","options","debugOutput","series","forEach","item","index","xyChartHandler","nullHandlingType","filterPlugin","mainData","isAggregate","aggregateFn","key","undefined","groupMap","Map","has","set","idx","rawVal","parsedVal","Number","isNaN","get","push","xData","from","keys","defaultAggregate","reduce","a","b","aggFn","yDataArr","name","mergeType","seriesData","pieChartHandler","catData","category","valData","len","Math","min","result","i","mapChartHandler","seriesType","nameField","dataRow","nameFieldRow","valueFieldRow","warn","candlestickChartHandler","time","open","close","high","low","sort","o","c","h","l","v","heatmapChartHandler","xRows","yRows","valRows","xSet","Set","ySet","yData","valueMap","x","radarChartHandler","indicator","indicators","values","max","ceil","nameRows","RadarPack","seriesData_radar","boxplotChartHandler","q1","median","q3","catRows","seriesRows","seriesList","useValue","valArrs","cat","ser","catMap","calcBoxStats","sorted","minV","maxV","medianV","quantile","q1V","q3V","q","pos","base","floor","rest","calcOutliers","stats","IQR","lower","upper","outlierData","flatMap","catIdx","indexOf","outliers","minRows","q1Rows","medianRows","q3Rows","maxRows","rowIdx","catVal","serVal","boxplotPack","seriesData_boxplot","graphChartHandler","nodeID","nodeName","nodeValue","nodeCategory","edgeSource","edgeTarget","edgeWeight","nodeIDRows","nodeNameRows","nodeValueRows","nodeCategoryRows","edgeSourceRows","edgeTargetRows","edgeWeightRows","nodes","nodeSet","id","node","add","edges","source","target","weight","edge","graphPack","treeChartHandler","parentID","parentName","path","isValid","parentIDRows","parentNameRows","nodeMap","children","rootNodes","parentId","treemapChartHandler","parentIdSet","pid","getLevel","cache","level","currentId","findIndex","maxLevel","getMaxDepth","depth","maxDepth","assignValue","sum","sunburstChartHandler","parallelChartHandler","dimensions","mainFile","filteredRows","dim","dimData","handledDimData","d","dimensionsRows","obj","dIdx","combinedRows","dimObj","sankeyChartHandler","sourceArr","targetArr","valueArr","raw","s","Source","Target","Value","links","data","funnelChartHandler","stage","dataRows","funnelData","gaugeChartHandler","nameData","valueData","gaugeData","pictorialBarChartHandler","themeRiverChartHandler","date","calendarChartHandler","chartTypeHandlers","Line","Bar","Pie","Scatter","Geo_Map","Candlestick","Heatmap","Radar","Boxplot","Graph","Tree","Treemap","Sunburst","Parallel","Sankey","Funnel","Gauge","PictorialBar","ThemeRiver","Calendar","mergeChartData","chartType"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/dataMergeUtils.js"],"sourcesContent":["// dataMergeUtils.js\n// 多文件数据合并与主键处理工具函数\n// 根据不同图表类型，主函数分发到对应的处理器进行数据处理，生成能够绘制图表的数据\n\n/*\n关键函数 mergeChartData(config, fileDataMap, nullHandlingType, options)\n    参数校验 validateParams\n    类型\n    图表类型分发器 chartTypeHandlers[type]\n    数据提取 getDataRows\n    过滤器插件 options.filterPlugin 或 defaultFilterPlugin\n    缺失值处理插件 handleNulls (调用 nullHandlingModule 中的具体方法)\n    主键合并 如有多文件/多字段，合并主键\n    组装seriesData 生成最终用于图表的数据结构\n    返回 {xData, yDataArr, mergeType, seriesData}\n*/\n\n/* eslint-disable */\n\n/**\n * @typedef {Object} AxisConfig\n * @property {string} file - 数据文件名\n * @property {string} field - 字段名\n */\n\n/**\n * @typedef {Object} ChartConfig\n * @property {AxisConfig} [xAxis]\n * @property {AxisConfig|AxisConfig[]} [yAxis]\n * @property {AxisConfig} [category]\n * @property {AxisConfig} [value]\n * @property {Object} [filter]\n * @property {string} [type] - 图表类型，如 'pie', 'line', 'bar' 等\n */\n\n/**\n * @typedef {Object.<string, Array<Object>>} FileDataMap\n */\n\n\n/**\n * 判断是否有主键（即所有y轴字段的文件都包含x轴字段）\n * @param {AxisConfig} xAxis\n * @param {AxisConfig|AxisConfig[]} yAxis\n * @param {FileDataMap} fileDataMap\n * @returns {boolean}\n */\nexport function hasPrimaryKey(xAxis, yAxis, fileDataMap) {\n    if (!xAxis || !xAxis.field) return false;\n    const xField = xAxis.field;\n    const yArr = Array.isArray(yAxis) ? yAxis : [yAxis];\n    return yArr.every(y => {\n        const yFileData = fileDataMap[y.file];\n        return yFileData && yFileData.length > 0 && yFileData[0].hasOwnProperty(xField);\n    });\n}\n\n\n// ---------------- 通用数据处理工具函数 ----------------\n\n/**\n * 提取数据并去掉标题行\n * @param {FileDataMap} fileDataMap\n * @param {string} file\n * @returns {Array<Object>}\n */\nfunction getDataRows(fileDataMap, file) {\n    return (fileDataMap[file] || []).slice(1);\n}\n\n/**\n * 通用缺失值处理器分发\n * @param {string} type\n * @param {Array} arr\n * @param {Object} nullHandlingModule\n * @returns {Array}\n */\nfunction handleNulls(type, arr, nullHandlingModule) {\n    if (!type || type === 'ignore') return arr;\n    const handler = nullHandlingModule[type] || nullHandlingModule.ignoreNull;\n    return handler(arr);\n}\n\n/**\n * 参数校验\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n */\nfunction validateParams(config, fileDataMap) {\n    if (!config || typeof config !== 'object') throw new Error('config must be an object');\n    if (!fileDataMap || typeof fileDataMap !== 'object') throw new Error('fileDataMap must be an object');\n}\n\n// ---------------- 过滤器插件化 ----------------\n\n/**\n * 过滤器插件，默认实现\n * @param {Array} rows\n * @param {Object} filters\n * @returns {Array}\n */\nexport function defaultFilterPlugin(rows, filters) {\n    if (!filters || !filters.filters || !Array.isArray(filters.filters) || filters.filters.length === 0) return rows;\n    const logic = filters.logic || 'AND';\n    const conds = filters.filters || [];\n    console.log('[defaultFilterPlugin] Applying filters:', conds);\n    if (conds.length === 0) return rows;\n    return rows.filter(row => {\n        const results = conds.map(f => {\n            const val = row[f.field];\n            switch (f.type) {\n                case 'integer': {\n                    console.log(`[defaultFilterPlugin] Checking integer field ${f.field} with value ${val}`);\n                    const num = parseFloat(val);\n                    const cmp = parseFloat(f.value);\n                    if (f.operator === 'eq') return num === cmp;\n                    if (f.operator === 'ne') return num !== cmp;\n                    if (f.operator === 'gt') return num > cmp;\n                    if (f.operator === 'ge') return num >= cmp;\n                    if (f.operator === 'lt') return num < cmp;\n                    if (f.operator === 'le') return num <= cmp;\n                    return true;\n                }\n                case 'string': {\n                    console.log(`[defaultFilterPlugin] Checking string field ${f.field} with value ${val}`);\n                    const str = String(val ?? '');\n                    const cmp = String(f.value ?? '');\n                    if (f.operator === 'eq') return str === cmp;\n                    if (f.operator === 'ne') return str !== cmp;\n                    if (f.operator === 'contains') return str.includes(cmp);\n                    if (f.operator === 'notcontains') return !str.includes(cmp);\n                    if (f.operator === 'startsWith') return str.startsWith(cmp);\n                    if (f.operator === 'endsWith') return str.endsWith(cmp);\n                    return true;\n                }\n                case 'category': {\n                    console.log(`[defaultFilterPlugin] Checking category field ${f.field} with value ${val}`);\n                    if (f.operator === 'eq') return val === f.value;\n                    if (f.operator === 'ne') return val !== f.value;\n                    if (f.operator === 'in') return Array.isArray(f.value) ? f.value.includes(val) : false;\n                    if (f.operator === 'notin') return Array.isArray(f.value) ? !f.value.includes(val) : false;\n                    return true;\n                }\n                case 'boolean': {\n                    console.log(`[defaultFilterPlugin] Checking boolean field ${f.field} with value ${val}`);\n                    const boolVal = val === true || val === 'true' || val === 1 || val === '1';\n                    const cmp = f.value === true || f.value === 'true' || f.value === 1 || f.value === '1';\n                    if (f.operator === 'eq') return boolVal === cmp;\n                    if (f.operator === 'ne') return boolVal !== cmp;\n                    return true;\n                }\n                case 'date': {\n                    console.log(`[defaultFilterPlugin] Checking date field ${f.field} with value ${val}`);\n                    const dateVal = new Date(val).getTime();\n                    const cmp = new Date(f.value).getTime();\n                    if (f.operator === 'eq') return dateVal === cmp;\n                    if (f.operator === 'ne') return dateVal !== cmp;\n                    if (f.operator === 'before') return dateVal < cmp;\n                    if (f.operator === 'after') return dateVal > cmp;\n                    return true;\n                }\n                default:\n                    return true;\n            }\n        });\n        return logic === 'AND' ? results.every(Boolean) : results.some(Boolean);\n    });\n}\n\nimport BoxplotChartIcon from '../../../components/svg/BoxplotChartIcon.vue';\n/**\n * 合并多文件数据，返回 { xData, yDataArr, mergeType, seriesData }\n * @param {Object} config - chartConfig\n * @param {Object} fileDataMap - 文件名到对象数组的映射\n * @returns {Object}\n */\n\nimport * as nullHandling from './nullHandling.js';\n\n// ---------------- 图表类型处理器 ----------------\n\n// 调试输入函数\nfunction debugInput(config, fileDataMap, options) {\n    console.log('[--debugInput {Chart Type Processor}--] config:', config);\n    console.log('[--debugInput {Chart Type Processor}--] fileDataMap:', fileDataMap);\n    console.log('[--debugInput {Chart Type Processor}--] options:', options);\n}\n\n// 调试输出函数\nfunction debugOutput(series) {\n    // 遍历 series 中的所有项目\n    series.forEach((item, index) => {\n        console.log(`[--debugOutput {Chart Type Processor}--] ${index}:`, item);\n    });\n}\n\n/**\n * 通用 x/y 图表（如折线、柱状等）数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction xyChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    let { nullHandlingType = 'ignore', nullHandlingModule = nullHandling, filterPlugin = defaultFilterPlugin } = options;\n    let { xAxis, yAxis } = config;\n    let mainData = getDataRows(fileDataMap, xAxis.file);\n    // 优先使用config.isAggregate，否则用options.isAggregate，默认true\n    let isAggregate = typeof config.isAggregate === 'boolean' ? config.isAggregate : (typeof options.isAggregate === 'boolean' ? options.isAggregate : true);\n    let aggregateFn = options.aggregateFn;\n    // 应用过滤\n    if (config.filter && config.filter.filters && config.filter.filters.length) {\n        mainData = filterPlugin(mainData, config.filter);\n    }\n    // 只过滤空行，不去重\n    mainData = mainData.filter(row => {\n        const key = row[xAxis.field];\n        return key !== undefined && key !== null && key !== '';\n    });\n    const yArr = Array.isArray(yAxis) ? yAxis : [yAxis];\n    if (isAggregate) {\n        // 按 name 分组聚合，可自定义聚合方式\n        const groupMap = new Map(); // key: name, value: [ [y1, y2, ...], [y1, y2, ...], ... ]\n        for (const row of mainData) {\n            const key = row[xAxis.field];\n            if (!groupMap.has(key)) {\n                groupMap.set(key, yArr.map(() => []));\n            }\n            yArr.forEach((y, idx) => {\n                const rawVal = row[y.field];\n                const parsedVal = parseFloat(rawVal);\n                // console.log(`[xyChartHandler] key=${key}, rawVal=${rawVal}, parsedVal=${parsedVal}`);\n                if (rawVal !== null && rawVal !== undefined && rawVal !== '' && !Number.isNaN(parsedVal)) {\n                    groupMap.get(key)[idx].push(parsedVal);\n                }\n            });\n        }\n        const xData = Array.from(groupMap.keys());\n        // 默认聚合函数为累加\n        const defaultAggregate = arr => arr.length === 0 ? null : arr.reduce((a, b) => a + b, 0);\n        const aggFn = typeof aggregateFn === 'function' ? aggregateFn : defaultAggregate;\n        let yDataArr = yArr.map((y, idx) => xData.map(name => aggFn(groupMap.get(name)[idx])));\n\n        // 应用缺失值处理\n        if (nullHandlingType && nullHandlingType !== 'ignore') {\n            yDataArr = yDataArr.map(arr => handleNulls(nullHandlingType, arr, nullHandlingModule));\n        }\n\n        return { xData, yDataArr, mergeType: 'groupByName', seriesData: [] };\n    } else {\n        // 返回原始未聚合数据\n        const xData = mainData.map(row => row[xAxis.field]);\n        let yDataArr = yArr.map(y => mainData.map(row => {\n            const rawVal = row[y.field];\n            const parsedVal = parseFloat(rawVal);\n            return (rawVal === null || rawVal === undefined || rawVal === '' || Number.isNaN(parsedVal)) ? null : parsedVal;\n        }));\n\n        // 应用缺失值处理\n        if (nullHandlingType && nullHandlingType !== 'ignore') {\n            yDataArr = yDataArr.map(arr => handleNulls(nullHandlingType, arr, nullHandlingModule));\n        }\n\n        return { xData, yDataArr, mergeType: 'raw', seriesData: [] };\n    }\n}\n\n/**\n * 饼图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction pieChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { filterPlugin = defaultFilterPlugin } = options;\n    let catData = getDataRows(fileDataMap, config.category.file);\n    let valData = getDataRows(fileDataMap, config.value.file);\n    // 应用过滤\n    if (config.filter && config.filter.filters && config.filter.filters.length) {\n        catData = filterPlugin(catData, config.filter);\n        valData = filterPlugin(valData, config.filter);\n    }\n    const len = Math.min(catData.length, valData.length);\n    const result = [];\n    for (let i = 0; i < len; i++) {\n        const name = catData[i][config.category.field];\n        const rawVal = valData[i][config.value.field];\n        const parsedVal = parseFloat(rawVal);\n        const val = (rawVal === null || rawVal === undefined || rawVal === '' || Number.isNaN(parsedVal)) ? null : parsedVal;\n        if (name !== undefined && name !== null && name !== '') {\n            result.push({ name, value: val });\n        }\n    }\n    return { xData: [], yDataArr: [], mergeType: 'pie', seriesData: result };\n}\n\n/**\n * 地图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction mapChartHandler(config, fileDataMap, options) {\n    debugInput(config, fileDataMap, options);\n    const seriesType = config.seriesType || 'map';\n\n    // 根据seriesType分发地图图表类型\n    if (seriesType === 'map') {\n        const { nameField, value } = config;\n        // 提取数据\n        const dataRow = getDataRows(fileDataMap, value.file);\n\n        // 分离数据行\n        const nameFieldRow = dataRow[nameField.index];\n        const valueFieldRow = dataRow[value.field];\n\n        console.log(nameFieldRow, valueFieldRow);\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else if (seriesType === 'heatmap') {\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else if (seriesType === 'scatter') {\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else if (seriesType === 'pie') {\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else if (seriesType === 'bar') {\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else if (seriesType === 'lines') {\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n    else {\n        // 兜底\n        console.warn(`[mapChartHandler] Unsupported seriesType: ${seriesType}`);\n        return { xData: [], yDataArr: [], mergeType: 'map', seriesData: [] };\n    }\n}\n\n/**\n * K线图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction candlestickChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { nullHandlingType = 'ignore', nullHandlingModule = nullHandling, filterPlugin = defaultFilterPlugin } = options;\n    const { time, open, close, high, low, filter } = config;\n    // 提取主文件数据\n    let mainData = getDataRows(fileDataMap, time.file);\n    if (filter && filter.filters && filter.filters.length) {\n        mainData = filterPlugin(mainData, filter);\n    }\n    // 按时间字段排序\n    mainData.sort((a, b) => {\n        if (a[time.field] < b[time.field]) return -1;\n        if (a[time.field] > b[time.field]) return 1;\n        return 0;\n    });\n    // 组装 xData 和 seriesData\n    const xData = mainData.map(row => row[time.field]);\n    const seriesData = mainData.map(row => {\n        const o = parseFloat(row[open.field]);\n        const c = parseFloat(row[close.field]);\n        const h = parseFloat(row[high.field]);\n        const l = parseFloat(row[low.field]);\n        // 缺失值处理\n        const arr = [o, c, l, h].map(v => (v === null || v === undefined || v === '' || Number.isNaN(v)) ? null : v);\n        return handleNulls(nullHandlingType, arr, nullHandlingModule);\n    });\n    return { xData, yDataArr: [seriesData], mergeType: 'candlestick', seriesData };\n}\n\n/**\n * 热力图数据处理器（主键合并，一一对应）\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction heatmapChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { xAxis, yAxis, value } = config;\n    // 获取所有数据行\n    const xRows = getDataRows(fileDataMap, xAxis.file);\n    const yRows = getDataRows(fileDataMap, yAxis.file);\n    const valRows = getDataRows(fileDataMap, value.file);\n\n    // 收集所有x、y的取值（类别）\n    const xSet = new Set(xRows.map(row => row[xAxis.field]));\n    const ySet = new Set(yRows.map(row => row[yAxis.field]));\n    const xData = Array.from(xSet);\n    const yData = Array.from(ySet);\n\n    // 构建value映射\n    const valueMap = new Map();\n    valRows.forEach(row => {\n        // 优先用valRows里的x/y字段，否则用xRows/yRows索引补齐\n        const x = row[xAxis.field] !== undefined ? row[xAxis.field] : null;\n        const y = row[yAxis.field] !== undefined ? row[yAxis.field] : null;\n        if (x !== null && y !== null) {\n            const key = `${x}|${y}`;\n            valueMap.set(key, row[value.field]);\n        }\n    });\n\n    // 生成 seriesData，补齐所有 (x, y) 组合\n    const seriesData = [];\n    yData.forEach(y => {\n        xData.forEach(x => {\n            const key = `${x}|${y}`;\n            const v = valueMap.has(key) ? valueMap.get(key) : null;\n            seriesData.push([x, y, v]);\n        });\n    });\n    return { xData, yData, mergeType: 'heatmap', seriesData };\n}\n\n\n/**\n * 雷达图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction radarChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { indicator, value, name } = config;\n\n    // 维度配置\n    const indicators = indicator.map(item => {\n        const rows = getDataRows(fileDataMap, item.file);\n        const values = rows.map(row => row[item.field]).filter(v => v !== undefined && v !== null);\n        const max = Math.ceil(Math.max(...values.map(v => Number(v))) * 1.2); // 乘以安全系数\n        return {\n            name: item.field,\n            max: max || 100\n        };\n    });\n\n    // 系列数据\n    const nameRows = getDataRows(fileDataMap, name.file);\n    const seriesData = nameRows.map(row => {\n        const values = value.map(item => row[item.field]);\n        return {\n            name: row[name.field],\n            value: values\n        };\n    });\n\n    // 先封装传输\n    const RadarPack = {\n        indicator: indicators,\n        seriesData_radar: seriesData,\n    }\n    return { xData: [], yData: [], mergeType: 'radar', seriesData: RadarPack };\n}\n\n/**\n * 箱线图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction boxplotChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    // 解析配置\n    const { category, series, value, min, q1, median, q3, max } = config;\n    // 获取数据行\n    const catRows = getDataRows(fileDataMap, category.file);\n    const seriesRows = series ? getDataRows(fileDataMap, series.file) : null;\n    // 收集所有分组和系列\n    const xData = Array.from(new Set(catRows.map(row => row[category.field])));\n    let seriesList = seriesRows ? Array.from(new Set(seriesRows.map(row => row[series.field]))) : null;\n    if (!seriesList || seriesList.length === 0) seriesList = ['default'];\n\n    let useValue = !!value;\n    let valArrs = [];\n    if (useValue) {\n        if (Array.isArray(value)) {\n            valArrs = value.map(v => getDataRows(fileDataMap, v.file).map(row => parseFloat(row[v.field])));\n        } else {\n            valArrs = [getDataRows(fileDataMap, value.file).map(row => parseFloat(row[value.field]))];\n        }\n    }\n\n    // 构建分组：series -> category -> [values]\n    const groupMap = new Map(); // key: series, value: Map(category, [values])\n    catRows.forEach((row, idx) => {\n        const cat = row[category.field];\n        const ser = (seriesRows && seriesRows[idx] && series.field) ? seriesRows[idx][series.field] : 'default';\n        if (!groupMap.has(ser)) groupMap.set(ser, new Map());\n        const catMap = groupMap.get(ser);\n        if (!catMap.has(cat)) catMap.set(cat, []);\n        if (useValue) {\n            valArrs.forEach(arr => {\n                if (arr[idx] !== undefined && !Number.isNaN(arr[idx])) {\n                    catMap.get(cat).push(arr[idx]);\n                }\n            });\n        }\n    });\n\n    // 计算统计量\n    function calcBoxStats(arr) {\n        if (!arr || arr.length === 0) return [null, null, null, null, null];\n        const sorted = arr.slice().sort((a, b) => a - b);\n        const minV = sorted[0];\n        const maxV = sorted[sorted.length - 1];\n        const medianV = quantile(sorted, 0.5);\n        const q1V = quantile(sorted, 0.25);\n        const q3V = quantile(sorted, 0.75);\n        return [minV, q1V, medianV, q3V, maxV];\n    }\n    function quantile(arr, q) {\n        const pos = (arr.length - 1) * q;\n        const base = Math.floor(pos);\n        const rest = pos - base;\n        if (arr[base + 1] !== undefined) {\n            return arr[base] + rest * (arr[base + 1] - arr[base]);\n        } else {\n            return arr[base];\n        }\n    }\n\n    // 计算异常值（outlier）\n    function calcOutliers(arr, stats) {\n        if (!arr || arr.length === 0) return [];\n        const [min, q1, median, q3, max] = stats;\n        // 1.5倍四分位距法\n        const IQR = q3 - q1;\n        const lower = q1 - 1.5 * IQR;\n        const upper = q3 + 1.5 * IQR;\n        return arr.filter(v => v < lower || v > upper);\n    }\n\n    // 组装 seriesData: 每个系列一个数组，数组顺序与 xData一致\n    let seriesData, outlierData;\n    if (useValue) {\n        // 自动计算五数和异常值\n        seriesData = seriesList.map(ser => {\n            const catMap = groupMap.get(ser) || new Map();\n            return xData.map(cat => calcBoxStats(catMap.get(cat) || []));\n        });\n        // 计算异常值\n        outlierData = seriesList.map(ser => {\n            const catMap = groupMap.get(ser) || new Map();\n            return xData.flatMap((cat, catIdx) => {\n                const arr = catMap.get(cat) || [];\n                const stats = seriesData[seriesList.indexOf(ser)][catIdx];\n                const outliers = calcOutliers(arr, stats);\n                // 返回 [x轴索引, 异常值]，ECharts scatter 需要这种格式\n                return outliers.map(v => [catIdx, v]);\n            });\n        });\n    } else {\n        // 直接读取五数\n        const minRows = min ? getDataRows(fileDataMap, min.file) : null;\n        const q1Rows = q1 ? getDataRows(fileDataMap, q1.file) : null;\n        const medianRows = median ? getDataRows(fileDataMap, median.file) : null;\n        const q3Rows = q3 ? getDataRows(fileDataMap, q3.file) : null;\n        const maxRows = max ? getDataRows(fileDataMap, max.file) : null;\n        seriesData = seriesList.map(ser => {\n            return xData.map((cat, idx) => {\n                let rowIdx = -1;\n                for (let i = 0; i < catRows.length; i++) {\n                    const catVal = catRows[i][category.field];\n                    const serVal = seriesRows ? seriesRows[i][series.field] : 'default';\n                    if (catVal === cat && serVal === ser) {\n                        rowIdx = i;\n                        break;\n                    }\n                }\n                if (rowIdx === -1) return [null, null, null, null, null];\n                return [\n                    minRows ? parseFloat(minRows[rowIdx][min.field]) : null,\n                    q1Rows ? parseFloat(q1Rows[rowIdx][q1.field]) : null,\n                    medianRows ? parseFloat(medianRows[rowIdx][median.field]) : null,\n                    q3Rows ? parseFloat(q3Rows[rowIdx][q3.field]) : null,\n                    maxRows ? parseFloat(maxRows[rowIdx][max.field]) : null\n                ];\n            });\n        });\n        // 无法自动计算异常值\n        outlierData = seriesList.map(() => []);\n    }\n\n    const boxplotPack = {\n        seriesList: seriesList,\n        seriesData_boxplot: seriesData,\n        outlierData: outlierData\n    }\n\n    return {\n        xData,\n        yDataArr: [],\n        mergeType: 'boxplot',\n        seriesData: boxplotPack\n    };\n}\n\n/**\n * 关系图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction graphChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options);\n    const { nodeID, nodeName, nodeValue, nodeCategory, edgeSource, edgeTarget, edgeWeight } = config;\n\n    // 必填字段校验\n    if (!nodeID || !nodeID.file || !nodeID.field) throw new Error('nodeID为必填项');\n    if (!edgeSource || !edgeSource.file || !edgeSource.field) throw new Error('edgeSource为必填项');\n    if (!edgeTarget || !edgeTarget.file || !edgeTarget.field) throw new Error('edgeTarget为必填项');\n\n    //获取数据行\n    const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n    const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n    const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n    const nodeCategoryRows = nodeCategory && nodeCategory.file ? getDataRows(fileDataMap, nodeCategory.file) : [];\n    const edgeSourceRows = getDataRows(fileDataMap, edgeSource.file);\n    const edgeTargetRows = getDataRows(fileDataMap, edgeTarget.file);\n    const edgeWeightRows = edgeWeight && edgeWeight.file ? getDataRows(fileDataMap, edgeWeight.file) : [];\n\n    // 节点去重，只保留每个id的第一个节点\n    const nodes = [];\n    const nodeSet = new Set();\n    nodeIDRows.forEach((row, idx) => {\n        const id = row[nodeID.field];\n        if (id !== undefined && id !== null && id !== '' && !nodeSet.has(id)) {\n            const name = (nodeNameRows[idx] && nodeName && nodeName.field) ? nodeNameRows[idx][nodeName.field] : id;\n            const value = (nodeValueRows[idx] && nodeValue && nodeValue.field) ? parseFloat(nodeValueRows[idx][nodeValue.field]) : 1;\n            const category = (nodeCategoryRows[idx] && nodeCategory && nodeCategory.field) ? nodeCategoryRows[idx][nodeCategory.field] : '';\n            const node = { id };\n            if (name !== undefined) node.name = name;\n            if (value !== undefined) node.value = value;\n            if (category !== undefined) node.category = category;\n            nodes.push(node);\n            nodeSet.add(id);\n        }\n    });\n\n    // 生成边数据，source/target直接用id字符串\n    const edges = [];\n    edgeSourceRows.forEach((row, idx) => {\n        const source = row[edgeSource.field];\n        const target = edgeTargetRows[idx] ? edgeTargetRows[idx][edgeTarget.field] : undefined;\n        const weight = (edgeWeightRows[idx] && edgeWeight && edgeWeight.field) ? parseFloat(edgeWeightRows[idx][edgeWeight.field]) : 1;\n        if (source !== undefined && source !== null && source !== '' &&\n            target !== undefined && target !== null && target !== '') {\n            const edge = { source: String(source), target: String(target) };\n            if (!isNaN(weight)) edge.weight = weight;\n            edges.push(edge);\n        }\n    });\n\n    // 打包\n    const graphPack = {\n        nodes: nodes,\n        edges: edges\n    };\n\n    return {\n        xData: [],\n        yDataArr: [],\n        mergeType: 'graph',\n        seriesData: graphPack,\n    };\n}\n\n/**\n * 树图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction treeChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { nodeID, nodeName, parentID, parentName, nodeValue, path } = config;\n    // 合理判定：有 nodeID 和 parentID 字段\n    const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n\n    // 平铺模式处理\n    if (isValid) {\n        const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n        const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n        const parentIDRows = getDataRows(fileDataMap, parentID.file);\n        const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n        const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n        // 构建节点映射\n        const nodeMap = new Map();\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            if (!id) return;\n            const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n            const value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n            nodeMap.set(id, {\n                id,\n                name,\n                value,\n                children: []\n            });\n        });\n\n        // 构建树结构\n        let rootNodes = [];\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n            if (!parentId || !nodeMap.has(parentId)) {\n                // 没有父节点，认为是根节点\n                rootNodes.push(nodeMap.get(id));\n            } else {\n                nodeMap.get(parentId).children.push(nodeMap.get(id));\n            }\n        });\n\n        // 只返回根节点数组\n        return {\n            xData: [],\n            yDataArr: [],\n            mergeType: 'tree',\n            seriesData: rootNodes\n        };\n    }\n\n    // 兜底\n    return {\n        xData: [],\n        yDataArr: [],\n        mergeType: 'tree',\n        seriesData: []\n    };\n}\n\n/**\n * 矩形树图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction treemapChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { nodeID, nodeName, parentID, parentName, nodeValue } = config;\n    // 判定数据是否有效\n    const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n\n    if (isValid) {\n        const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n        const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n        const parentIDRows = getDataRows(fileDataMap, parentID.file);\n        const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n        const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n        // 构建节点映射\n        const nodeMap = new Map();\n        // 先收集所有 parentId，便于后续层级计算\n        const parentIdSet = new Set();\n        parentIDRows.forEach(row => {\n            if (row && parentID && parentID.field) {\n                const pid = row[parentID.field];\n                if (pid) parentIdSet.add(pid);\n            }\n        });\n\n        // 计算每个节点的层级（根节点为1，子节点依次+1）\n        function getLevel(id, cache = {}) {\n            if (cache[id]) return cache[id];\n            let level = 1;\n            let currentId = id;\n            let idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n            while (idx !== -1) {\n                const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n                if (!parentId || !nodeMap.has(parentId)) break;\n                level++;\n                currentId = parentId;\n                idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n            }\n            cache[id] = level;\n            return level;\n        }\n\n        // 统计最大层级\n        let maxLevel = 1;\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            const level = getLevel(id);\n            if (level > maxLevel) maxLevel = level;\n        });\n\n        // 构建节点，value 按层级递减（根节点最大，叶子最小）\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            if (!id) return;\n            const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n            let value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n            // 层级递减赋值，根节点 value = maxLevel，下一层 maxLevel-1，依次类推\n            if (value === undefined || value === null || isNaN(value)) {\n                const level = getLevel(id);\n                value = Math.max(1, maxLevel - level + 1);\n            }\n            nodeMap.set(id, {\n                id,\n                name,\n                value,\n                children: []\n            });\n        });\n\n        // 构建树结构\n        let rootNodes = [];\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n            if (!parentId || !nodeMap.has(parentId)) {\n                // 没有父节点，认为是根节点\n                rootNodes.push(nodeMap.get(id));\n            } else {\n                nodeMap.get(parentId).children.push(nodeMap.get(id));\n            }\n        });\n\n        // 递归获取最大层级\n        function getMaxDepth(nodes, depth) {\n            if (!nodes || nodes.length === 0) return depth;\n            let max = depth;\n            for (let i = 0; i < nodes.length; i++) {\n                max = Math.max(max, getMaxDepth(nodes[i].children, depth + 1));\n            }\n            return max;\n        }\n        const maxDepth = getMaxDepth(rootNodes, 1);\n\n        // 递归分配 value：有原始 value 则保留，无则自动分配\n        function assignValue(nodes) {\n            if (!nodes) return 0;\n            for (let i = 0; i < nodes.length; i++) {\n                if (!nodes[i].children || nodes[i].children.length === 0) {\n                    if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n                        nodes[i].value = 1;\n                    }\n                } else {\n                    if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n                        nodes[i].value = assignValue(nodes[i].children);\n                    } else {\n                        // 有 value 时，仍需递归处理子节点\n                        assignValue(nodes[i].children);\n                    }\n                }\n            }\n            // 返回所有节点 value 之和\n            return nodes.reduce((sum, node) => sum + (node.value || 0), 0);\n        }\n        assignValue(rootNodes);\n\n        // Treemap 要求每个节点有 value, 非叶子节点 value 可为 undefined\n        return {\n            xData: [],\n            yDataArr: [],\n            mergeType: 'treemap',\n            seriesData: rootNodes\n        };\n    }\n\n    // 兜底\n    return {\n        xData: [],\n        yDataArr: [],\n        mergeType: 'treemap',\n        seriesData: []\n    };\n}\n\n/**\n * 旭日图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction sunburstChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options)\n    const { nodeID, nodeName, parentID, parentName, nodeValue } = config;\n    // 判定数据是否有效\n    const isValid = nodeID && nodeID.file && nodeID.field && parentID && parentID.file && parentID.field;\n\n    if (isValid) {\n        const nodeIDRows = getDataRows(fileDataMap, nodeID.file);\n        const nodeNameRows = nodeName && nodeName.file ? getDataRows(fileDataMap, nodeName.file) : [];\n        const parentIDRows = getDataRows(fileDataMap, parentID.file);\n        const parentNameRows = parentName && parentName.file ? getDataRows(fileDataMap, parentName.file) : [];\n        const nodeValueRows = nodeValue && nodeValue.file ? getDataRows(fileDataMap, nodeValue.file) : [];\n\n        // 构建节点映射\n        const nodeMap = new Map();\n        // 先收集所有 parentId，便于后续层级计算\n        const parentIdSet = new Set();\n        parentIDRows.forEach(row => {\n            if (row && parentID && parentID.field) {\n                const pid = row[parentID.field];\n                if (pid) parentIdSet.add(pid);\n            }\n        });\n\n        // 计算每个节点的层级（根节点为1，子节点依次+1）\n        function getLevel(id, cache = {}) {\n            if (cache[id]) return cache[id];\n            let level = 1;\n            let currentId = id;\n            let idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n            while (idx !== -1) {\n                const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n                if (!parentId || !nodeMap.has(parentId)) break;\n                level++;\n                currentId = parentId;\n                idx = nodeIDRows.findIndex(row => row[nodeID.field] === currentId);\n            }\n            cache[id] = level;\n            return level;\n        }\n\n        // 统计最大层级\n        let maxLevel = 1;\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            const level = getLevel(id);\n            if (level > maxLevel) maxLevel = level;\n        });\n\n        // 构建节点，value 按层级递减（根节点最大，叶子最小）\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            if (!id) return;\n            const name = nodeNameRows[idx] && nodeName && nodeName.field ? nodeNameRows[idx][nodeName.field] : id;\n            let value = nodeValueRows[idx] && nodeValue && nodeValue.field ? parseFloat(nodeValueRows[idx][nodeValue.field]) : undefined;\n            // 层级递减赋值，根节点 value = maxLevel，下一层 maxLevel-1，依次类推\n            if (value === undefined || value === null || isNaN(value)) {\n                const level = getLevel(id);\n                value = Math.max(1, maxLevel - level + 1);\n            }\n            nodeMap.set(id, {\n                id,\n                name,\n                value,\n                children: []\n            });\n        });\n\n        // 构建树结构\n        let rootNodes = [];\n        nodeIDRows.forEach((row, idx) => {\n            const id = row[nodeID.field];\n            const parentId = parentIDRows[idx] ? parentIDRows[idx][parentID.field] : undefined;\n            if (!parentId || !nodeMap.has(parentId)) {\n                // 没有父节点，认为是根节点\n                rootNodes.push(nodeMap.get(id));\n            } else {\n                nodeMap.get(parentId).children.push(nodeMap.get(id));\n            }\n        });\n\n        // 递归获取最大层级\n        function getMaxDepth(nodes, depth) {\n            if (!nodes || nodes.length === 0) return depth;\n            let max = depth;\n            for (let i = 0; i < nodes.length; i++) {\n                max = Math.max(max, getMaxDepth(nodes[i].children, depth + 1));\n            }\n            return max;\n        }\n        const maxDepth = getMaxDepth(rootNodes, 1);\n\n        // 递归分配 value：有原始 value 则保留，无则自动分配\n        function assignValue(nodes) {\n            if (!nodes) return 0;\n            for (let i = 0; i < nodes.length; i++) {\n                if (!nodes[i].children || nodes[i].children.length === 0) {\n                    if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n                        nodes[i].value = 1;\n                    }\n                } else {\n                    if (nodes[i].value === undefined || nodes[i].value === null || isNaN(nodes[i].value)) {\n                        nodes[i].value = assignValue(nodes[i].children);\n                    } else {\n                        // 有 value 时，仍需递归处理子节点\n                        assignValue(nodes[i].children);\n                    }\n                }\n            }\n            // 返回所有节点 value 之和\n            return nodes.reduce((sum, node) => sum + (node.value || 0), 0);\n        }\n        assignValue(rootNodes);\n\n        // Sunburst 要求每个节点有 value, 非叶子节点 value 可为 undefined\n        return {\n            xData: [],\n            yDataArr: [],\n            mergeType: 'sunburst',\n            seriesData: rootNodes\n        };\n    }\n\n    // 兜底\n    return {\n        xData: [],\n        yDataArr: [],\n        mergeType: 'sunburst',\n        seriesData: []\n    };\n}\n\n/**\n * 平行坐标系图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction parallelChartHandler(config, fileDataMap, options) {\n    const { dimensions, nameField } = config;\n    const { nullHandlingType = 'ignore', nullHandlingModule = nullHandling } = options;\n\n    const mainFile = dimensions[0].file;\n    const rows = getDataRows(fileDataMap, mainFile);\n\n    // 过滤掉所有维度都为空的行\n    const filteredRows = rows.filter(row =>\n        dimensions.some(dim => {\n            const v = row[dim.field];\n            return v !== undefined && v !== null && v !== '';\n        })\n    );\n\n    // 按列收集数据\n    const dimData = dimensions.map(dim =>\n        filteredRows.map(row => {\n            const v = row[dim.field];\n            const num = parseFloat(v);\n            return (v === null || v === undefined || v === '' || Number.isNaN(num)) ? null : num;\n        })\n    );\n\n    // 缺失值处理\n    const handledDimData = dimData.map(arr =>\n        nullHandlingType && nullHandlingType !== 'ignore'\n            ? (nullHandlingModule[nullHandlingType] || (d => d))(arr)\n            : arr\n    );\n\n    // 重新组装为对象数组\n    const dimensionsRows = filteredRows.map((row, idx) => {\n        const obj = {};\n        dimensions.forEach((dim, dIdx) => {\n            obj[dim.field] = handledDimData[dIdx][idx];\n        });\n        return obj;\n    });\n\n    const nameRows = nameField\n        ? filteredRows.map(row => ({ name: row[nameField.field] }))\n        : [];\n\n    const combinedRows = dimensionsRows.map((dimObj, idx) => ({\n        ...dimObj,\n        ...(nameRows[idx] || {})\n    }));\n\n    const seriesData = combinedRows;\n\n    return {\n        xData: [],\n        yDataArr: [],\n        mergeType: 'parallel',\n        seriesData,\n    };\n}\n\n/**\n * 桑基图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction sankeyChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options);\n    const { source, target, value } = config;\n\n    // 支持直接传入数组或文件字段\n    let sourceArr = Array.isArray(source) ? source : getDataRows(fileDataMap, source.file).map(row => row[source.field]);\n    let targetArr = Array.isArray(target) ? target : getDataRows(fileDataMap, target.file).map(row => row[target.field]);\n    let valueArr = Array.isArray(value) ? value : (value ? getDataRows(fileDataMap, value.file).map(row => row[value.field]) : []);\n\n    // 合并为原始数组 [{Source, Target, Value}]\n    const raw = sourceArr.map((s, i) => ({\n        Source: s,\n        Target: targetArr[i],\n        Value: valueArr[i],\n    }));\n\n    // nodes: 所有唯一 Source/Target\n    const nodeSet = new Set();\n    raw.forEach(row => {\n        if (row.Source !== undefined && row.Source !== null && row.Source !== '') nodeSet.add(row.Source);\n        if (row.Target !== undefined && row.Target !== null && row.Target !== '') nodeSet.add(row.Target);\n    });\n    const nodes = Array.from(nodeSet).map(name => ({ name }));\n\n    // links: { source, target, value }\n    const links = raw.map(row => ({\n        source: row.Source,\n        target: row.Target,\n        value: row.Value\n    }));\n\n    const seriesData = {\n        data: nodes,\n        links: links,\n    };\n\n    return { mergeType: 'sankey', seriesData };\n}\n\n/**\n * 漏斗图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction funnelChartHandler(config, fileDataMap, options) {\n    debugInput(config, fileDataMap, options);\n\n    const { stage, value } = config;\n\n    // 获取数据行\n    const dataRows = getDataRows(fileDataMap, stage.file);\n\n    const funnelData = dataRows.map((row) => ({\n        name: row[stage.field],\n        value: row[value.field],\n    }));\n\n    return { xData: [], yDataArr: [], mergeType: 'funnel', seriesData: funnelData, };\n}\n\n/**\n * 仪表盘图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction gaugeChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options);\n\n    const { name, value } = config;\n\n    // 获取数据行\n    const dataRows = getDataRows(fileDataMap, name.file);\n\n    const nameData = dataRows.map(row => row[name.field]);\n    const valueData = dataRows.map(row => parseFloat(row[value.field]));\n\n    const gaugeData = {\n        name: nameData,\n        value: valueData,\n    }\n\n    return { mergeType: 'gauge', seriesData: gaugeData };\n}\n\n/**\n * 象形柱图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction pictorialBarChartHandler(config, fileDataMap, options) {\n    debugInput(config, fileDataMap, options);\n    return {};\n}\n\n/**\n * 主题河流图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction themeRiverChartHandler(config, fileDataMap, options) {\n    // debugInput(config, fileDataMap, options);\n\n    const { date, value, category } = config;\n\n    // 获取数据行\n    const dataRows = getDataRows(fileDataMap, date.file);\n\n    // 按顺序组合(date, value, category)\n    const seriesData = dataRows.map(row => [\n        row[date.field],\n        parseFloat(row[value.field]),\n        row[category.field]\n    ]);\n\n    return { mergeType: 'themeRiver', seriesData };\n}\n\n/**\n * 日历图数据处理器\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {Object} options\n * @returns {Object}\n */\nfunction calendarChartHandler(config, fileDataMap, options) {\n    debugInput(config, fileDataMap, options);\n    return {};\n}\n\n// ---------------- 图表类型分发器 ----------------\n\nconst chartTypeHandlers = {\n    Line: xyChartHandler,\n    Bar: xyChartHandler,\n    Pie: pieChartHandler,\n    Scatter: xyChartHandler,\n    Geo_Map: mapChartHandler,\n    Candlestick: candlestickChartHandler,\n    Heatmap: heatmapChartHandler,\n    Radar: radarChartHandler,\n    Boxplot: boxplotChartHandler,\n    Graph: graphChartHandler,\n    Tree: treeChartHandler,\n    Treemap: treemapChartHandler,\n    Sunburst: sunburstChartHandler,\n    Parallel: parallelChartHandler,\n    Sankey: sankeyChartHandler,\n    Funnel: funnelChartHandler,\n    Gauge: gaugeChartHandler,\n    PictorialBar: pictorialBarChartHandler,\n    ThemeRiver: themeRiverChartHandler,\n    Calendar: calendarChartHandler,\n    // 其他类型可继续扩展\n};\n\n/**\n * 主入口：合并多文件数据，返回 { xData, yDataArr, mergeType, seriesData }\n * @param {ChartConfig} config\n * @param {FileDataMap} fileDataMap\n * @param {string} [nullHandlingType]\n * @param {Object} [options] - 可选项：filterPlugin, nullHandlingModule\n * @returns {Object}\n */\nexport function mergeChartData(config, fileDataMap, nullHandlingType = 'ignore', options = {}) {\n    validateParams(config, fileDataMap);\n    let chartType = config.type;\n\n    console.log('[mergeChartData] Inferred chart type:', chartType);\n\n    const handler = chartTypeHandlers[chartType] || xyChartHandler;\n\n    console.log('[mergeChartData] Handler:', handler);\n\n    // 允许config.isAggregate传递到handler\n    return handler(config, fileDataMap, { ...options, nullHandlingType, isAggregate: config.isAggregate });\n}\n\n// applyFiltersToRows 已被插件化，见 defaultFilterPlugin\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}