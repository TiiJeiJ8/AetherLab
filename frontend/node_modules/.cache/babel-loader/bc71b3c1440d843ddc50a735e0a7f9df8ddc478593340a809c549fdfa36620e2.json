{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx';\nconst API_BASE_URL = '/api';\nconst CACHE_KEY = 'fuck_charts_files';\n\n// 后端连接状态\nlet isBackendConnected = false;\n\n/**\n * 检测后端连接状态\n * @returns {Promise<boolean>} 连接状态\n */\nexport async function checkBackendConnection() {\n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 3000);\n    const response = await fetch(`${API_BASE_URL}/health`, {\n      method: 'GET',\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    isBackendConnected = response.ok;\n    return isBackendConnected;\n  } catch (error) {\n    console.log('后端连接检测:', error.message);\n    isBackendConnected = false;\n    return false;\n  }\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n  return isBackendConnected;\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n  try {\n    const cached = localStorage.getItem(CACHE_KEY);\n    return cached ? JSON.parse(cached) : [];\n  } catch (error) {\n    console.error('读取缓存失败:', error);\n    return [];\n  }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n  try {\n    const cached = getCachedFiles();\n    cached.push(fileInfo);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(cached));\n  } catch (error) {\n    console.error('保存到缓存失败:', error);\n  }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n  try {\n    const cached = getCachedFiles();\n    const filtered = cached.filter(file => file.id !== fileId);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(filtered));\n  } catch (error) {\n    console.error('从缓存删除失败:', error);\n  }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = e.target.result;\n        let workbook, worksheet, jsonData;\n        if (file.name.toLowerCase().endsWith('.csv')) {\n          // CSV文件解析 - 支持中文字符\n          workbook = XLSX.read(data, {\n            type: 'string',\n            codepage: 65001 // UTF-8\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1,\n            defval: '',\n            blankrows: false\n          });\n        } else {\n          // Excel文件解析 - 支持中文字符\n          workbook = XLSX.read(data, {\n            type: 'array',\n            cellDates: true,\n            cellNF: false,\n            cellText: false\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1,\n            defval: '',\n            blankrows: false\n          });\n        }\n\n        // 过滤空行\n        jsonData = jsonData.filter(row => row.some(cell => cell !== null && cell !== ''));\n\n        // 限制预览行数\n        const previewData = jsonData.slice(0, 100);\n        resolve({\n          data: previewData,\n          totalRows: jsonData.length,\n          totalColumns: jsonData[0] ? jsonData[0].length : 0,\n          headers: jsonData[0] || []\n        });\n      } catch (error) {\n        console.error('文件解析失败:', error);\n        reject(new Error('文件解析失败：' + error.message));\n      }\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    if (file.name.toLowerCase().endsWith('.csv')) {\n      reader.readAsText(file, 'UTF-8');\n    } else {\n      reader.readAsArrayBuffer(file);\n    }\n  });\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * @param {File} file - 要上传的文件对象\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file) {\n  try {\n    // 生成唯一文件ID\n    const fileId = Date.now().toString() + Math.random().toString(36).substring(2);\n\n    // 解析文件内容\n    const parseResult = await parseFileContent(file);\n\n    // 将解析结果转换为对象数组格式\n    const headers = parseResult.headers;\n    const previewData = parseResult.data.slice(1).map(row => {\n      const obj = {};\n      headers.forEach((header, index) => {\n        obj[header] = row[index] || null;\n      });\n      return obj;\n    });\n\n    // 创建文件信息对象\n    const fileInfo = {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified,\n      uploadTime: new Date().toISOString(),\n      status: 'local',\n      previewData: previewData,\n      totalRows: parseResult.totalRows,\n      totalColumns: parseResult.totalColumns,\n      headers: headers,\n      fileObject: file // 保存文件对象以备后续使用\n    };\n\n    // 保存到本地缓存\n    saveToCache(fileInfo);\n\n    // 尝试上传到服务器（如果连接可用）\n    if (await checkBackendConnection()) {\n      try {\n        const formData = new FormData();\n        formData.append('file', file);\n        const response = await fetch(`${API_BASE_URL}/files/upload`, {\n          method: 'POST',\n          body: formData\n        });\n        if (response.ok) {\n          const serverResult = await response.json();\n          fileInfo.serverId = serverResult.id;\n          fileInfo.status = 'uploaded';\n\n          // 更新缓存\n          const cached = getCachedFiles();\n          const updatedFiles = cached.map(f => f.id === fileId ? fileInfo : f);\n          localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n        }\n      } catch (error) {\n        console.warn('服务器上传失败，仅保存到本地:', error);\n      }\n    }\n    return {\n      success: true,\n      file: fileInfo,\n      preview: {\n        data: previewData,\n        totalRows: parseResult.totalRows,\n        totalColumns: parseResult.totalColumns,\n        headers: headers\n      }\n    };\n  } catch (error) {\n    console.error('文件上传失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise<Object>} 预览数据\n */\nexport async function getFilePreview(fileId) {\n  try {\n    const cachedFiles = getCachedFiles();\n    const fileInfo = cachedFiles.find(file => file.id === fileId);\n    if (!fileInfo) {\n      throw new Error('文件不存在');\n    }\n    console.log('getFilePreview - fileInfo found:', fileInfo);\n    console.log('getFilePreview - has previewData:', !!fileInfo.previewData);\n    console.log('getFilePreview - has fileObject:', !!fileInfo.fileObject);\n\n    // 如果文件已经有缓存的预览数据，直接返回\n    if (fileInfo.previewData && fileInfo.previewData.length > 0) {\n      console.log('getFilePreview - returning cached data');\n      return {\n        data: fileInfo.previewData,\n        totalRows: fileInfo.totalRows || fileInfo.previewData.length,\n        totalColumns: fileInfo.totalColumns || (fileInfo.previewData[0] ? Object.keys(fileInfo.previewData[0]).length : 0),\n        headers: fileInfo.headers || (fileInfo.previewData[0] ? Object.keys(fileInfo.previewData[0]) : [])\n      };\n    }\n\n    // 如果没有缓存数据，需要重新解析文件\n    if (fileInfo.fileObject) {\n      console.log('getFilePreview - re-parsing file object');\n      const parseResult = await parseFileContent(fileInfo.fileObject);\n\n      // 将解析结果转换为对象数组格式\n      const headers = parseResult.headers;\n      const previewData = parseResult.data.slice(1).map(row => {\n        const obj = {};\n        headers.forEach((header, index) => {\n          obj[header] = row[index] || null;\n        });\n        return obj;\n      });\n\n      // 更新缓存中的文件信息\n      fileInfo.previewData = previewData;\n      fileInfo.totalRows = parseResult.totalRows;\n      fileInfo.totalColumns = parseResult.totalColumns;\n      fileInfo.headers = headers;\n      const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n      localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n      return {\n        data: previewData,\n        totalRows: parseResult.totalRows,\n        totalColumns: parseResult.totalColumns,\n        headers: headers\n      };\n    }\n    console.error('getFilePreview - 文件数据不可用，fileInfo:', fileInfo);\n    throw new Error('文件数据不可用：缺少预览数据和原始文件对象');\n  } catch (error) {\n    console.error('获取文件预览失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo || !fileInfo.file) {\n    throw new Error('本地文件不存在');\n  }\n  if (!(await checkBackendConnection())) {\n    throw new Error('后端未连接');\n  }\n  try {\n    const formData = new FormData();\n    formData.append('file', fileInfo.file);\n    const response = await fetch(`${API_BASE_URL}/files/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error('同步失败');\n    }\n    const result = await response.json();\n\n    // 更新缓存中的文件状态\n    fileInfo.status = 'uploaded';\n    fileInfo.serverId = result.fileId;\n    const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n    return fileInfo;\n  } catch (error) {\n    console.error('同步文件失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n  const cachedFiles = getCachedFiles();\n  if (!(await checkBackendConnection())) {\n    return cachedFiles;\n  }\n  try {\n    const response = await fetch(`${API_BASE_URL}/files`);\n    if (!response.ok) {\n      return cachedFiles;\n    }\n    const remoteFiles = await response.json();\n\n    // 合并本地和远程文件，避免重复\n    const allFiles = [...cachedFiles];\n    remoteFiles.forEach(remoteFile => {\n      const existsInCache = cachedFiles.some(cached => cached.serverId === remoteFile.id);\n      if (!existsInCache) {\n        allFiles.push({\n          ...remoteFile,\n          id: remoteFile.id,\n          serverId: remoteFile.id,\n          status: 'uploaded'\n        });\n      }\n    });\n    return allFiles;\n  } catch (error) {\n    console.error('获取远程文件列表失败:', error);\n    return cachedFiles;\n  }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时从服务器删除\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n          method: 'DELETE'\n        });\n        if (!response.ok) {\n          console.warn('从服务器删除文件失败');\n        }\n      } catch (error) {\n        console.error('从服务器删除文件失败:', error);\n      }\n    }\n  }\n\n  // 从本地缓存删除\n  removeFromCache(fileId);\n  return {\n    success: true\n  };\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时更新服务器\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            name: newName\n          })\n        });\n        if (!response.ok) {\n          console.warn('服务器重命名失败');\n        }\n      } catch (error) {\n        console.error('服务器重命名失败:', error);\n      }\n    }\n  }\n\n  // 更新本地缓存\n  fileInfo.name = newName;\n  const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n  localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n  return {\n    success: true,\n    file: fileInfo\n  };\n}","map":{"version":3,"names":["XLSX","API_BASE_URL","CACHE_KEY","isBackendConnected","checkBackendConnection","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","signal","clearTimeout","ok","error","console","log","message","getBackendStatus","getCachedFiles","cached","localStorage","getItem","JSON","parse","saveToCache","fileInfo","push","setItem","stringify","removeFromCache","fileId","filtered","filter","file","id","parseFileContent","Promise","resolve","reject","reader","FileReader","onload","e","data","target","result","workbook","worksheet","jsonData","name","toLowerCase","endsWith","read","type","codepage","Sheets","SheetNames","utils","sheet_to_json","header","defval","blankrows","cellDates","cellNF","cellText","row","some","cell","previewData","slice","totalRows","length","totalColumns","headers","Error","onerror","readAsText","readAsArrayBuffer","uploadFile","Date","now","toString","Math","random","substring","parseResult","map","obj","forEach","index","size","lastModified","uploadTime","toISOString","status","fileObject","formData","FormData","append","body","serverResult","json","serverId","updatedFiles","f","warn","success","preview","getFilePreview","cachedFiles","find","Object","keys","syncFileToBackend","getAllFiles","remoteFiles","allFiles","remoteFile","existsInCache","deleteFile","renameFile","newName"],"sources":["D:/Learning Material/Git/Fuck-Charts/newArchitecture/frontend_vue_design/src/services/FileServices.js"],"sourcesContent":["/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx'\n\nconst API_BASE_URL = '/api'\nconst CACHE_KEY = 'fuck_charts_files'\n\n// 后端连接状态\nlet isBackendConnected = false\n\n/**\n * 检测后端连接状态\n * @returns {Promise<boolean>} 连接状态\n */\nexport async function checkBackendConnection() {\n    try {\n        const controller = new AbortController()\n        const timeoutId = setTimeout(() => controller.abort(), 3000)\n\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            signal: controller.signal\n        })\n\n        clearTimeout(timeoutId)\n        isBackendConnected = response.ok\n        return isBackendConnected\n    } catch (error) {\n        console.log('后端连接检测:', error.message)\n        isBackendConnected = false\n        return false\n    }\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n    return isBackendConnected\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n    try {\n        const cached = localStorage.getItem(CACHE_KEY)\n        return cached ? JSON.parse(cached) : []\n    } catch (error) {\n        console.error('读取缓存失败:', error)\n        return []\n    }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n    try {\n        const cached = getCachedFiles()\n        cached.push(fileInfo)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(cached))\n    } catch (error) {\n        console.error('保存到缓存失败:', error)\n    }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n    try {\n        const cached = getCachedFiles()\n        const filtered = cached.filter(file => file.id !== fileId)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(filtered))\n    } catch (error) {\n        console.error('从缓存删除失败:', error)\n    }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n\n        reader.onload = (e) => {\n            try {\n                const data = e.target.result\n                let workbook, worksheet, jsonData\n\n                if (file.name.toLowerCase().endsWith('.csv')) {\n                    // CSV文件解析 - 支持中文字符\n                    workbook = XLSX.read(data, {\n                        type: 'string',\n                        codepage: 65001 // UTF-8\n                    })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                        header: 1,\n                        defval: '',\n                        blankrows: false\n                    })\n                } else {\n                    // Excel文件解析 - 支持中文字符\n                    workbook = XLSX.read(data, {\n                        type: 'array',\n                        cellDates: true,\n                        cellNF: false,\n                        cellText: false\n                    })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, {\n                        header: 1,\n                        defval: '',\n                        blankrows: false\n                    })\n                }\n\n                // 过滤空行\n                jsonData = jsonData.filter(row => row.some(cell => cell !== null && cell !== ''))\n\n                // 限制预览行数\n                const previewData = jsonData.slice(0, 100)\n\n                resolve({\n                    data: previewData,\n                    totalRows: jsonData.length,\n                    totalColumns: jsonData[0] ? jsonData[0].length : 0,\n                    headers: jsonData[0] || []\n                })\n            } catch (error) {\n                console.error('文件解析失败:', error)\n                reject(new Error('文件解析失败：' + error.message))\n            }\n        }\n\n        reader.onerror = () => reject(new Error('文件读取失败'))\n\n        if (file.name.toLowerCase().endsWith('.csv')) {\n            reader.readAsText(file, 'UTF-8')\n        } else {\n            reader.readAsArrayBuffer(file)\n        }\n    })\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * @param {File} file - 要上传的文件对象\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file) {\n    try {\n        // 生成唯一文件ID\n        const fileId = Date.now().toString() + Math.random().toString(36).substring(2)\n        \n        // 解析文件内容\n        const parseResult = await parseFileContent(file)\n        \n        // 将解析结果转换为对象数组格式\n        const headers = parseResult.headers\n        const previewData = parseResult.data.slice(1).map(row => {\n            const obj = {}\n            headers.forEach((header, index) => {\n                obj[header] = row[index] || null\n            })\n            return obj\n        })\n\n        // 创建文件信息对象\n        const fileInfo = {\n            id: fileId,\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            lastModified: file.lastModified,\n            uploadTime: new Date().toISOString(),\n            status: 'local',\n            previewData: previewData,\n            totalRows: parseResult.totalRows,\n            totalColumns: parseResult.totalColumns,\n            headers: headers,\n            fileObject: file // 保存文件对象以备后续使用\n        }\n\n        // 保存到本地缓存\n        saveToCache(fileInfo)\n\n        // 尝试上传到服务器（如果连接可用）\n        if (await checkBackendConnection()) {\n            try {\n                const formData = new FormData()\n                formData.append('file', file)\n                \n                const response = await fetch(`${API_BASE_URL}/files/upload`, {\n                    method: 'POST',\n                    body: formData\n                })\n                \n                if (response.ok) {\n                    const serverResult = await response.json()\n                    fileInfo.serverId = serverResult.id\n                    fileInfo.status = 'uploaded'\n                    \n                    // 更新缓存\n                    const cached = getCachedFiles()\n                    const updatedFiles = cached.map(f => f.id === fileId ? fileInfo : f)\n                    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n                }\n            } catch (error) {\n                console.warn('服务器上传失败，仅保存到本地:', error)\n            }\n        }\n\n        return {\n            success: true,\n            file: fileInfo,\n            preview: {\n                data: previewData,\n                totalRows: parseResult.totalRows,\n                totalColumns: parseResult.totalColumns,\n                headers: headers\n            }\n        }\n    } catch (error) {\n        console.error('文件上传失败:', error)\n        throw error\n    }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise<Object>} 预览数据\n */\nexport async function getFilePreview(fileId) {\n    try {\n        const cachedFiles = getCachedFiles()\n        const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n        if (!fileInfo) {\n            throw new Error('文件不存在')\n        }\n\n        console.log('getFilePreview - fileInfo found:', fileInfo)\n        console.log('getFilePreview - has previewData:', !!fileInfo.previewData)\n        console.log('getFilePreview - has fileObject:', !!fileInfo.fileObject)\n        \n        // 如果文件已经有缓存的预览数据，直接返回\n        if (fileInfo.previewData && fileInfo.previewData.length > 0) {\n            console.log('getFilePreview - returning cached data')\n            return {\n                data: fileInfo.previewData,\n                totalRows: fileInfo.totalRows || fileInfo.previewData.length,\n                totalColumns: fileInfo.totalColumns || (fileInfo.previewData[0] ? Object.keys(fileInfo.previewData[0]).length : 0),\n                headers: fileInfo.headers || (fileInfo.previewData[0] ? Object.keys(fileInfo.previewData[0]) : [])\n            }\n        }\n\n        // 如果没有缓存数据，需要重新解析文件\n        if (fileInfo.fileObject) {\n            console.log('getFilePreview - re-parsing file object')\n            const parseResult = await parseFileContent(fileInfo.fileObject)\n            \n            // 将解析结果转换为对象数组格式\n            const headers = parseResult.headers\n            const previewData = parseResult.data.slice(1).map(row => {\n                const obj = {}\n                headers.forEach((header, index) => {\n                    obj[header] = row[index] || null\n                })\n                return obj\n            })\n\n            // 更新缓存中的文件信息\n            fileInfo.previewData = previewData\n            fileInfo.totalRows = parseResult.totalRows\n            fileInfo.totalColumns = parseResult.totalColumns\n            fileInfo.headers = headers\n\n            const updatedFiles = cachedFiles.map(file =>\n                file.id === fileId ? fileInfo : file\n            )\n            localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n\n            return {\n                data: previewData,\n                totalRows: parseResult.totalRows,\n                totalColumns: parseResult.totalColumns,\n                headers: headers\n            }\n        }\n\n        console.error('getFilePreview - 文件数据不可用，fileInfo:', fileInfo)\n        throw new Error('文件数据不可用：缺少预览数据和原始文件对象')\n    } catch (error) {\n        console.error('获取文件预览失败:', error)\n        throw error\n    }\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo || !fileInfo.file) {\n        throw new Error('本地文件不存在')\n    }\n\n    if (!await checkBackendConnection()) {\n        throw new Error('后端未连接')\n    }\n\n    try {\n        const formData = new FormData()\n        formData.append('file', fileInfo.file)\n\n        const response = await fetch(`${API_BASE_URL}/files/upload`, {\n            method: 'POST',\n            body: formData\n        })\n\n        if (!response.ok) {\n            throw new Error('同步失败')\n        }\n\n        const result = await response.json()\n\n        // 更新缓存中的文件状态\n        fileInfo.status = 'uploaded'\n        fileInfo.serverId = result.fileId\n\n        const updatedFiles = cachedFiles.map(file =>\n            file.id === fileId ? fileInfo : file\n        )\n        localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n\n        return fileInfo\n    } catch (error) {\n        console.error('同步文件失败:', error)\n        throw error\n    }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n    const cachedFiles = getCachedFiles()\n\n    if (!await checkBackendConnection()) {\n        return cachedFiles\n    }\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/files`)\n        if (!response.ok) {\n            return cachedFiles\n        }\n\n        const remoteFiles = await response.json()\n\n        // 合并本地和远程文件，避免重复\n        const allFiles = [...cachedFiles]\n\n        remoteFiles.forEach(remoteFile => {\n            const existsInCache = cachedFiles.some(cached =>\n                cached.serverId === remoteFile.id\n            )\n\n            if (!existsInCache) {\n                allFiles.push({\n                    ...remoteFile,\n                    id: remoteFile.id,\n                    serverId: remoteFile.id,\n                    status: 'uploaded'\n                })\n            }\n        })\n\n        return allFiles\n    } catch (error) {\n        console.error('获取远程文件列表失败:', error)\n        return cachedFiles\n    }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n\n    // 如果文件已上传到服务器，同时从服务器删除\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n                    method: 'DELETE'\n                })\n                if (!response.ok) {\n                    console.warn('从服务器删除文件失败')\n                }\n            } catch (error) {\n                console.error('从服务器删除文件失败:', error)\n            }\n        }\n    }\n\n    // 从本地缓存删除\n    removeFromCache(fileId)\n\n    return { success: true }\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n\n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n\n    // 如果文件已上传到服务器，同时更新服务器\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ name: newName })\n                })\n                if (!response.ok) {\n                    console.warn('服务器重命名失败')\n                }\n            } catch (error) {\n                console.error('服务器重命名失败:', error)\n            }\n        }\n    }\n\n    // 更新本地缓存\n    fileInfo.name = newName\n    const updatedFiles = cachedFiles.map(file =>\n        file.id === fileId ? fileInfo : file\n    )\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n\n    return { success: true, file: fileInfo }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}