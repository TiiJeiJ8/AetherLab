{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n  return data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// Hermite插值函数，供单调、Akima、Cardinal等插值方法调用\nfunction hermite(t, y0, y1, m0, m1) {\n  // t: [0,1]，y0/y1: 端点，m0/m1: 端点切线\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return (2 * t3 - 3 * t2 + 1) * y0 + (t3 - 2 * t2 + t) * m0 + (-2 * t3 + 3 * t2) * y1 + (t3 - t2) * m1;\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  // echarts-stat 没有直接的“忽略”方法，直接返回原始数据即可\n  return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  // echarts-stat 没有直接的“填充0”API，直接用原生实现\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 使用 echarts-stat 的 nearest 插值方法\nimport * as ecStat from 'echarts-stat';\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  // echarts-stat 的 missingValue.interpolate 支持 'nearest' 方法\n  return ecStat.missingValue.interpolate(data, 'nearest');\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 使用 echarts-stat 的 linear 插值方法\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  return ecStat.missingValue.interpolate(data, 'linear');\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n  // 首先构造自然三次样条的求解函数\n  function cubicSplineCoefficients(x, y) {\n    const n = x.length;\n    const a = y.slice();\n    const h = new Array(n - 1);\n    const alpha = new Array(n - 1);\n    for (let i = 0; i < n - 1; i++) {\n      h[i] = x[i + 1] - x[i];\n      if (h[i] <= 0) {\n        throw new Error('x values must be strictly increasing');\n      }\n    }\n    for (let i = 1; i < n - 1; i++) {\n      alpha[i] = 3 / h[i] * (a[i + 1] - a[i]) - 3 / h[i - 1] * (a[i] - a[i - 1]);\n    }\n    const l = [1],\n      mu = [0],\n      z = [0];\n    for (let i = 1; i < n - 1; i++) {\n      l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n      mu[i] = h[i] / l[i];\n      z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n    }\n    l[n - 1] = 1;\n    z[n - 1] = 0;\n    const c = Array(n).fill(0);\n    const b = Array(n - 1);\n    const d = Array(n - 1);\n    for (let j = n - 2; j >= 0; j--) {\n      c[j] = z[j] - mu[j] * c[j + 1];\n      b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n      d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n    }\n    return {\n      a,\n      b,\n      c,\n      d,\n      x\n    };\n  }\n\n  // 然后构造样条插值函数\n  function cubicSplineInterpolate(xi, coefs) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      x\n    } = coefs;\n    let i = x.length - 2;\n    for (let j = 0; j < x.length - 1; j++) {\n      if (xi >= x[j] && xi <= x[j + 1]) {\n        i = j;\n        break;\n      }\n    }\n    const dx = xi - x[i];\n    return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n  }\n\n  // 主函数\n  console.log('[fillCubicSpline] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  if (valid.length < 3) {\n    console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n    return result;\n  }\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const coefs = cubicSplineCoefficients(x, y);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      result[i] = cubicSplineInterpolate(i, coefs);\n    }\n  }\n  return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n  console.log('[fillPolynomial] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  function lagrange(x) {\n    let y = 0;\n    for (let i = 0; i < n; i++) {\n      let term = valid[i].y;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n        }\n      }\n      y += term;\n    }\n    return y;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lagrange(i);\n    }\n  }\n  return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n  console.log('[fillStepBefore] method is working');\n  const result = [...data];\n  let lastVal = null;\n  for (let i = 1; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n  console.log('[fillStepAfter] method is working');\n  const result = [...data];\n  let lastVal = null;\n  for (let i = result.length - 2; i >= 0; i--) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n  // 首先构造均匀节点向量(open uniform knot vector)\n  function createUniformKnotVector(n, degree) {\n    const m = n + degree + 1;\n    const knots = [];\n    for (let i = 0; i < m; i++) {\n      if (i < degree) knots.push(0);else if (i > n) knots.push(n - degree + 1);else knots.push(i - degree);\n    }\n    return knots;\n  }\n\n  // 然后递归 de Boor 算法计算 B 样条点\n  function deBoor(i, k, t, knots, ctrlPoints) {\n    if (k === 0) return ctrlPoints[i];\n    const alpha = (t - knots[i]) / (knots[i + k] - knots[i]);\n    const left = deBoor(i - 1, k - 1, t, knots, ctrlPoints);\n    const right = deBoor(i, k - 1, t, knots, ctrlPoints);\n    return (1 - alpha) * left + alpha * right;\n  }\n\n  // 主函数\n  console.log('[fillBasis] method is working');\n  const result = [...data];\n  const valid = data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n  const degree = 3;\n  const n = valid.length - 1;\n  if (n < degree) {\n    console.warn('[fillBasis] Not enough valid points for B-spline');\n    return result;\n  }\n  const ctrlX = valid.map(p => p.x);\n  const ctrlY = valid.map(p => p.y);\n  const knots = createUniformKnotVector(n, degree);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const t = i * (n - degree + 1) / (result.length - 1); // 归一化到 knot domain\n      // 找起始区间索引 i，使 knots[i] <= t < knots[i+1]\n      let j = degree;\n      while (j < knots.length - 1 && t >= knots[j + 1]) j++;\n\n      // de Boor 插值\n      result[i] = deBoor(j, degree, t, knots, ctrlY);\n    }\n  }\n  return result;\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n  console.log('[fillCardinal] method is working');\n  const result = [...data];\n  const valid = data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n  if (valid.length < 4) {\n    console.warn('[fillCardinal] Not enough points');\n    return result;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const p1Idx = valid.findIndex(p => p.x > i);\n      const p0Idx = p1Idx - 2;\n      if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n      const P0 = valid[p0Idx].y;\n      const P1 = valid[p0Idx + 1].y;\n      const P2 = valid[p0Idx + 2].y;\n      const P3 = valid[p0Idx + 3].y;\n      const x0 = valid[p0Idx + 1].x;\n      const x1 = valid[p0Idx + 2].x;\n      const t = (i - x0) / (x1 - x0); // normalized position\n      const t2 = t * t,\n        t3 = t2 * t;\n      result[i] = 0.5 * (2 * P1 + (-P0 + P2) * t + (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 + (-P0 + 3 * P1 - 3 * P2 + P3) * t3);\n    }\n  }\n  return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n  console.log('[fillMonotone] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 3) return result;\n\n  // 预计算斜率\n  const dx = [],\n    dy = [],\n    m = [],\n    t = [];\n  for (let i = 0; i < n - 1; i++) {\n    dx[i] = valid[i + 1].x - valid[i].x;\n    dy[i] = valid[i + 1].y - valid[i].y;\n    m[i] = dy[i] / dx[i];\n  }\n  t[0] = m[0];\n  for (let i = 1; i < n - 1; i++) {\n    if (m[i - 1] * m[i] <= 0) {\n      t[i] = 0;\n    } else {\n      const w1 = 2 * dx[i] + dx[i - 1];\n      const w2 = dx[i] + 2 * dx[i - 1];\n      t[i] = w1 + w2 === 0 ? 0 : (w1 + w2) / (w1 / m[i - 1] + w2 / m[i]);\n    }\n  }\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = valid[idx - 1].x;\n      const x1 = valid[idx].x;\n      const y0 = valid[idx - 1].y;\n      const y1 = valid[idx].y;\n      const t0 = t[idx - 1];\n      const t1 = t[idx];\n      const h = x1 - x0;\n      const s = (i - x0) / h;\n      result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n    }\n  }\n  return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n  console.log('[fillAkima] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 5) return result;\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const m = new Array(n - 1);\n  for (let i = 0; i < n - 1; i++) {\n    m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n  }\n  const t = [];\n  for (let i = 2; i < n - 2; i++) {\n    const w1 = Math.abs(m[i + 1] - m[i]);\n    const w2 = Math.abs(m[i - 1] - m[i - 2]);\n    t[i] = w1 + w2 === 0 ? (m[i - 1] + m[i]) / 2 : (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n  }\n  // 端点斜率回退为邻近斜率\n  t[0] = m[0];\n  t[1] = m[1];\n  t[n - 2] = m[n - 2];\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = x[idx - 1],\n        x1 = x[idx];\n      const y0 = y[idx - 1],\n        y1 = y[idx];\n      const s = (i - x0) / (x1 - x0);\n      const t0 = t[idx - 1] * (x1 - x0);\n      const t1 = t[idx] * (x1 - x0);\n      result[i] = hermite(s, y0, y1, t0, t1);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["getValidPoints","data","map","y","x","filter","p","isNaN","hermite","t","y0","y1","m0","m1","t2","t3","ignoreNull","console","log","fillZero","v","undefined","Number","ecStat","fillNearest","missingValue","interpolate","linearInterpolate","fillCubicSpline","cubicSplineCoefficients","n","length","a","slice","h","Array","alpha","i","Error","l","mu","z","c","fill","b","d","j","cubicSplineInterpolate","xi","coefs","dx","result","valid","warn","fillPolynomial","lagrange","term","fillStepBefore","lastVal","fillStepAfter","fillBasis","createUniformKnotVector","degree","m","knots","push","deBoor","k","ctrlPoints","left","right","ctrlX","ctrlY","fillCardinal","p1Idx","findIndex","p0Idx","P0","P1","P2","P3","x0","x1","fillMonotone","dy","w1","w2","idx","t0","t1","s","fillAkima","Math","abs"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n    return data.map((y, x) => ({ x, y })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// Hermite插值函数，供单调、Akima、Cardinal等插值方法调用\nfunction hermite(t, y0, y1, m0, m1) {\n    // t: [0,1]，y0/y1: 端点，m0/m1: 端点切线\n    const t2 = t * t;\n    const t3 = t2 * t;\n    return (\n        (2 * t3 - 3 * t2 + 1) * y0 +\n        (t3 - 2 * t2 + t) * m0 +\n        (-2 * t3 + 3 * t2) * y1 +\n        (t3 - t2) * m1\n    );\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    // echarts-stat 没有直接的“忽略”方法，直接返回原始数据即可\n    return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    // echarts-stat 没有直接的“填充0”API，直接用原生实现\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 使用 echarts-stat 的 nearest 插值方法\nimport * as ecStat from 'echarts-stat';\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    // echarts-stat 的 missingValue.interpolate 支持 'nearest' 方法\n    return ecStat.missingValue.interpolate(data, 'nearest');\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 使用 echarts-stat 的 linear 插值方法\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    return ecStat.missingValue.interpolate(data, 'linear');\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n    // 首先构造自然三次样条的求解函数\n    function cubicSplineCoefficients(x, y) {\n        const n = x.length;\n        const a = y.slice();\n        const h = new Array(n - 1);\n        const alpha = new Array(n - 1);\n\n        for (let i = 0; i < n - 1; i++) {\n            h[i] = x[i + 1] - x[i];\n            if (h[i] <= 0) {\n                throw new Error('x values must be strictly increasing');\n            }\n        }\n        for (let i = 1; i < n - 1; i++) {\n            alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1]);\n        }\n\n        const l = [1], mu = [0], z = [0];\n        for (let i = 1; i < n - 1; i++) {\n            l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n            mu[i] = h[i] / l[i];\n            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n        }\n        l[n - 1] = 1;\n        z[n - 1] = 0;\n\n        const c = Array(n).fill(0);\n        const b = Array(n - 1);\n        const d = Array(n - 1);\n\n        for (let j = n - 2; j >= 0; j--) {\n            c[j] = z[j] - mu[j] * c[j + 1];\n            b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n            d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n        }\n        return { a, b, c, d, x };\n    }\n\n    // 然后构造样条插值函数\n    function cubicSplineInterpolate(xi, coefs) {\n        const { a, b, c, d, x } = coefs;\n        let i = x.length - 2;\n\n        for (let j = 0; j < x.length - 1; j++) {\n            if (xi >= x[j] && xi <= x[j + 1]) {\n                i = j;\n                break;\n            }\n        }\n\n        const dx = xi - x[i];\n        return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n    }\n\n    // 主函数\n    console.log('[fillCubicSpline] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n\n    if (valid.length < 3) {\n        console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n        return result;\n    }\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const coefs = cubicSplineCoefficients(x, y);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            result[i] = cubicSplineInterpolate(i, coefs);\n        }\n    }\n\n    return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n    console.log('[fillPolynomial] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n    function lagrange(x) {\n        let y = 0;\n        for (let i = 0; i < n; i++) {\n            let term = valid[i].y;\n            for (let j = 0; j < n; j++) {\n                if (i !== j) {\n                    term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n                }\n            }\n            y += term;\n        }\n        return y;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lagrange(i);\n        }\n    }\n    return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n    console.log('[fillStepBefore] method is working');\n    const result = [...data];\n    let lastVal = null;\n    for (let i = 1; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n    console.log('[fillStepAfter] method is working');\n    const result = [...data];\n    let lastVal = null;\n    for (let i = result.length - 2; i >= 0; i--) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n    // 首先构造均匀节点向量(open uniform knot vector)\n    function createUniformKnotVector(n, degree) {\n        const m = n + degree + 1;\n        const knots = [];\n        for (let i = 0; i < m; i++) {\n            if (i < degree) knots.push(0);\n            else if (i > n) knots.push(n - degree + 1);\n            else knots.push(i - degree);\n        }\n        return knots;\n    }\n\n    // 然后递归 de Boor 算法计算 B 样条点\n    function deBoor(i, k, t, knots, ctrlPoints) {\n        if (k === 0) return ctrlPoints[i];\n\n        const alpha = (t - knots[i]) / (knots[i + k] - knots[i]);\n        const left = deBoor(i - 1, k - 1, t, knots, ctrlPoints);\n        const right = deBoor(i, k - 1, t, knots, ctrlPoints);\n\n        return (1 - alpha) * left + alpha * right;\n    }\n\n    // 主函数\n    console.log('[fillBasis] method is working');\n\n    const result = [...data];\n    const valid = data.map((y, x) => ({ x, y }))\n        .filter(p => p.y != null && !isNaN(p.y));\n\n    const degree = 3;\n    const n = valid.length - 1;\n    if (n < degree) {\n        console.warn('[fillBasis] Not enough valid points for B-spline');\n        return result;\n    }\n\n    const ctrlX = valid.map(p => p.x);\n    const ctrlY = valid.map(p => p.y);\n    const knots = createUniformKnotVector(n, degree);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const t = i * (n - degree + 1) / (result.length - 1);  // 归一化到 knot domain\n            // 找起始区间索引 i，使 knots[i] <= t < knots[i+1]\n            let j = degree;\n            while (j < knots.length - 1 && t >= knots[j + 1]) j++;\n\n            // de Boor 插值\n            result[i] = deBoor(j, degree, t, knots, ctrlY);\n        }\n    }\n\n    return result;\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n    console.log('[fillCardinal] method is working');\n\n    const result = [...data];\n    const valid = data.map((y, x) => ({ x, y }))\n        .filter(p => p.y != null && !isNaN(p.y));\n\n    if (valid.length < 4) {\n        console.warn('[fillCardinal] Not enough points');\n        return result;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const p1Idx = valid.findIndex(p => p.x > i);\n            const p0Idx = p1Idx - 2;\n            if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n\n            const P0 = valid[p0Idx].y;\n            const P1 = valid[p0Idx + 1].y;\n            const P2 = valid[p0Idx + 2].y;\n            const P3 = valid[p0Idx + 3].y;\n\n            const x0 = valid[p0Idx + 1].x;\n            const x1 = valid[p0Idx + 2].x;\n\n            const t = (i - x0) / (x1 - x0); // normalized position\n            const t2 = t * t, t3 = t2 * t;\n\n            result[i] = 0.5 * (\n                (2 * P1) +\n                (-P0 + P2) * t +\n                (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 +\n                (-P0 + 3 * P1 - 3 * P2 + P3) * t3\n            );\n        }\n    }\n\n    return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n    console.log('[fillMonotone] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 3) return result;\n\n    // 预计算斜率\n    const dx = [], dy = [], m = [], t = [];\n    for (let i = 0; i < n - 1; i++) {\n        dx[i] = valid[i + 1].x - valid[i].x;\n        dy[i] = valid[i + 1].y - valid[i].y;\n        m[i] = dy[i] / dx[i];\n    }\n\n    t[0] = m[0];\n    for (let i = 1; i < n - 1; i++) {\n        if (m[i - 1] * m[i] <= 0) {\n            t[i] = 0;\n        } else {\n            const w1 = 2 * dx[i] + dx[i - 1];\n            const w2 = dx[i] + 2 * dx[i - 1];\n            t[i] = (w1 + w2) === 0 ? 0 : (w1 + w2) / ((w1 / m[i - 1]) + (w2 / m[i]));\n        }\n    }\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = valid[idx - 1].x;\n            const x1 = valid[idx].x;\n            const y0 = valid[idx - 1].y;\n            const y1 = valid[idx].y;\n            const t0 = t[idx - 1];\n            const t1 = t[idx];\n\n            const h = x1 - x0;\n            const s = (i - x0) / h;\n            result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n        }\n    }\n\n    return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n    console.log('[fillAkima] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 5) return result;\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const m = new Array(n - 1);\n\n    for (let i = 0; i < n - 1; i++) {\n        m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n    }\n\n    const t = [];\n    for (let i = 2; i < n - 2; i++) {\n        const w1 = Math.abs(m[i + 1] - m[i]);\n        const w2 = Math.abs(m[i - 1] - m[i - 2]);\n        t[i] = (w1 + w2 === 0) ? ((m[i - 1] + m[i]) / 2) :\n            (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n    }\n    // 端点斜率回退为邻近斜率\n    t[0] = m[0];\n    t[1] = m[1];\n    t[n - 2] = m[n - 2];\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = x[idx - 1], x1 = x[idx];\n            const y0 = y[idx - 1], y1 = y[idx];\n            const s = (i - x0) / (x1 - x0);\n            const t0 = t[idx - 1] * (x1 - x0);\n            const t1 = t[idx] * (x1 - x0);\n\n            result[i] = hermite(s, y0, y1, t0, t1);\n        }\n    }\n\n    return result;\n}\n"],"mappings":";;;;AAAA;AACA;AACA;;AAEA;;AAEA;AACA,SAASA,cAAcA,CAACC,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,MAAM;IAAEA,CAAC;IAAED;EAAE,CAAC,CAAC,CAAC,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACH,CAAC,IAAI,IAAI,IAAI,CAACI,KAAK,CAACD,CAAC,CAACH,CAAC,CAAC,CAAC;AACjF;;AAEA;AACA,SAASK,OAAOA,CAACC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAChC;EACA,MAAMC,EAAE,GAAGL,CAAC,GAAGA,CAAC;EAChB,MAAMM,EAAE,GAAGD,EAAE,GAAGL,CAAC;EACjB,OACI,CAAC,CAAC,GAAGM,EAAE,GAAG,CAAC,GAAGD,EAAE,GAAG,CAAC,IAAIJ,EAAE,GAC1B,CAACK,EAAE,GAAG,CAAC,GAAGD,EAAE,GAAGL,CAAC,IAAIG,EAAE,GACtB,CAAC,CAAC,CAAC,GAAGG,EAAE,GAAG,CAAC,GAAGD,EAAE,IAAIH,EAAE,GACvB,CAACI,EAAE,GAAGD,EAAE,IAAID,EAAE;AAEtB;;AAEA;AACA,OAAO,SAASG,UAAUA,CAACf,IAAI,EAAE;EAC7BgB,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;EAC7C;EACA,OAAOjB,IAAI;AACf;;AAEA;AACA,OAAO,SAASkB,QAAQA,CAAClB,IAAI,EAAE;EAC3BgB,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;EAC3C;EACA,OAAOjB,IAAI,CAACC,GAAG,CAACkB,CAAC,IAAKA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAKC,SAAS,IAAIC,MAAM,CAACf,KAAK,CAACa,CAAC,CAAC,GAAI,CAAC,GAAGA,CAAC,CAAC;AACpF;;AAEA;AACA;AACA,OAAO,KAAKG,MAAM,MAAM,cAAc;AACtC,OAAO,SAASC,WAAWA,CAACvB,IAAI,EAAE;EAC9BgB,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;EAC9C;EACA,OAAOK,MAAM,CAACE,YAAY,CAACC,WAAW,CAACzB,IAAI,EAAE,SAAS,CAAC;AAC3D;;AAEA;AACA;AACA,OAAO,SAAS0B,iBAAiBA,CAAC1B,IAAI,EAAE;EACpCgB,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;EACpD,OAAOK,MAAM,CAACE,YAAY,CAACC,WAAW,CAACzB,IAAI,EAAE,QAAQ,CAAC;AAC1D;;AAEA;AACA;AACA;AACA,OAAO,SAAS2B,eAAeA,CAAC3B,IAAI,EAAE;EAClC;EACA,SAAS4B,uBAAuBA,CAACzB,CAAC,EAAED,CAAC,EAAE;IACnC,MAAM2B,CAAC,GAAG1B,CAAC,CAAC2B,MAAM;IAClB,MAAMC,CAAC,GAAG7B,CAAC,CAAC8B,KAAK,CAAC,CAAC;IACnB,MAAMC,CAAC,GAAG,IAAIC,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;IAC1B,MAAMM,KAAK,GAAG,IAAID,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;IAE9B,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;MAC5BH,CAAC,CAACG,CAAC,CAAC,GAAGjC,CAAC,CAACiC,CAAC,GAAG,CAAC,CAAC,GAAGjC,CAAC,CAACiC,CAAC,CAAC;MACtB,IAAIH,CAAC,CAACG,CAAC,CAAC,IAAI,CAAC,EAAE;QACX,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;MAC3D;IACJ;IACA,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;MAC5BD,KAAK,CAACC,CAAC,CAAC,GAAI,CAAC,GAAGH,CAAC,CAACG,CAAC,CAAC,IAAKL,CAAC,CAACK,CAAC,GAAG,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC,CAAC,GAAI,CAAC,GAAGH,CAAC,CAACG,CAAC,GAAG,CAAC,CAAC,IAAKL,CAAC,CAACK,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC;IAClF;IAEA,MAAME,CAAC,GAAG,CAAC,CAAC,CAAC;MAAEC,EAAE,GAAG,CAAC,CAAC,CAAC;MAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;IAChC,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;MAC5BE,CAAC,CAACF,CAAC,CAAC,GAAG,CAAC,IAAIjC,CAAC,CAACiC,CAAC,GAAG,CAAC,CAAC,GAAGjC,CAAC,CAACiC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGH,CAAC,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGG,EAAE,CAACH,CAAC,GAAG,CAAC,CAAC;MACvDG,EAAE,CAACH,CAAC,CAAC,GAAGH,CAAC,CAACG,CAAC,CAAC,GAAGE,CAAC,CAACF,CAAC,CAAC;MACnBI,CAAC,CAACJ,CAAC,CAAC,GAAG,CAACD,KAAK,CAACC,CAAC,CAAC,GAAGH,CAAC,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGI,CAAC,CAACJ,CAAC,GAAG,CAAC,CAAC,IAAIE,CAAC,CAACF,CAAC,CAAC;IAClD;IACAE,CAAC,CAACT,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACZW,CAAC,CAACX,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IAEZ,MAAMY,CAAC,GAAGP,KAAK,CAACL,CAAC,CAAC,CAACa,IAAI,CAAC,CAAC,CAAC;IAC1B,MAAMC,CAAC,GAAGT,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;IACtB,MAAMe,CAAC,GAAGV,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;IAEtB,KAAK,IAAIgB,CAAC,GAAGhB,CAAC,GAAG,CAAC,EAAEgB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC7BJ,CAAC,CAACI,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC,GAAGN,EAAE,CAACM,CAAC,CAAC,GAAGJ,CAAC,CAACI,CAAC,GAAG,CAAC,CAAC;MAC9BF,CAAC,CAACE,CAAC,CAAC,GAAG,CAACd,CAAC,CAACc,CAAC,GAAG,CAAC,CAAC,GAAGd,CAAC,CAACc,CAAC,CAAC,IAAIZ,CAAC,CAACY,CAAC,CAAC,GAAGZ,CAAC,CAACY,CAAC,CAAC,IAAIJ,CAAC,CAACI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGJ,CAAC,CAACI,CAAC,CAAC,CAAC,GAAG,CAAC;MAClED,CAAC,CAACC,CAAC,CAAC,GAAG,CAACJ,CAAC,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGJ,CAAC,CAACI,CAAC,CAAC,KAAK,CAAC,GAAGZ,CAAC,CAACY,CAAC,CAAC,CAAC;IACzC;IACA,OAAO;MAAEd,CAAC;MAAEY,CAAC;MAAEF,CAAC;MAAEG,CAAC;MAAEzC;IAAE,CAAC;EAC5B;;EAEA;EACA,SAAS2C,sBAAsBA,CAACC,EAAE,EAAEC,KAAK,EAAE;IACvC,MAAM;MAAEjB,CAAC;MAAEY,CAAC;MAAEF,CAAC;MAAEG,CAAC;MAAEzC;IAAE,CAAC,GAAG6C,KAAK;IAC/B,IAAIZ,CAAC,GAAGjC,CAAC,CAAC2B,MAAM,GAAG,CAAC;IAEpB,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1C,CAAC,CAAC2B,MAAM,GAAG,CAAC,EAAEe,CAAC,EAAE,EAAE;MACnC,IAAIE,EAAE,IAAI5C,CAAC,CAAC0C,CAAC,CAAC,IAAIE,EAAE,IAAI5C,CAAC,CAAC0C,CAAC,GAAG,CAAC,CAAC,EAAE;QAC9BT,CAAC,GAAGS,CAAC;QACL;MACJ;IACJ;IAEA,MAAMI,EAAE,GAAGF,EAAE,GAAG5C,CAAC,CAACiC,CAAC,CAAC;IACpB,OAAOL,CAAC,CAACK,CAAC,CAAC,GAAGO,CAAC,CAACP,CAAC,CAAC,GAAGa,EAAE,GAAGR,CAAC,CAACL,CAAC,CAAC,GAAGa,EAAE,IAAI,CAAC,GAAGL,CAAC,CAACR,CAAC,CAAC,GAAGa,EAAE,IAAI,CAAC;EAC7D;;EAEA;EACAjC,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;EAClD,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGpD,cAAc,CAACC,IAAI,CAAC;EAElC,IAAImD,KAAK,CAACrB,MAAM,GAAG,CAAC,EAAE;IAClBd,OAAO,CAACoC,IAAI,CAAC,oEAAoE,CAAC;IAClF,OAAOF,MAAM;EACjB;EAEA,MAAM/C,CAAC,GAAGgD,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACF,CAAC,CAAC;EAC7B,MAAMD,CAAC,GAAGiD,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACH,CAAC,CAAC;EAC7B,MAAM8C,KAAK,GAAGpB,uBAAuB,CAACzB,CAAC,EAAED,CAAC,CAAC;EAE3C,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,IAAI,IAAI,IAAI9B,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MACvCc,MAAM,CAACd,CAAC,CAAC,GAAGU,sBAAsB,CAACV,CAAC,EAAEY,KAAK,CAAC;IAChD;EACJ;EAEA,OAAOE,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASG,cAAcA,CAACrD,IAAI,EAAE;EACjCgB,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;EACjD,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGpD,cAAc,CAACC,IAAI,CAAC;EAClC,MAAM6B,CAAC,GAAGsB,KAAK,CAACrB,MAAM;EACtB,SAASwB,QAAQA,CAACnD,CAAC,EAAE;IACjB,IAAID,CAAC,GAAG,CAAC;IACT,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;MACxB,IAAImB,IAAI,GAAGJ,KAAK,CAACf,CAAC,CAAC,CAAClC,CAAC;MACrB,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,CAAC,EAAEgB,CAAC,EAAE,EAAE;QACxB,IAAIT,CAAC,KAAKS,CAAC,EAAE;UACTU,IAAI,IAAI,CAACpD,CAAC,GAAGgD,KAAK,CAACN,CAAC,CAAC,CAAC1C,CAAC,KAAKgD,KAAK,CAACf,CAAC,CAAC,CAACjC,CAAC,GAAGgD,KAAK,CAACN,CAAC,CAAC,CAAC1C,CAAC,CAAC;QACxD;MACJ;MACAD,CAAC,IAAIqD,IAAI;IACb;IACA,OAAOrD,CAAC;EACZ;EAEA,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAK,IAAI,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAKhB,SAAS,IAAIC,MAAM,CAACf,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MAC1Ec,MAAM,CAACd,CAAC,CAAC,GAAGkB,QAAQ,CAAClB,CAAC,CAAC;IAC3B;EACJ;EACA,OAAOc,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASM,cAAcA,CAACxD,IAAI,EAAE;EACjCgB,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;EACjD,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,IAAIyD,OAAO,GAAG,IAAI;EAClB,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAK,IAAI,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAKhB,SAAS,IAAIC,MAAM,CAACf,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MAC1Ec,MAAM,CAACd,CAAC,CAAC,GAAGqB,OAAO;IACvB,CAAC,MAAM;MACHA,OAAO,GAAGP,MAAM,CAACd,CAAC,CAAC;IACvB;EACJ;EACA,OAAOc,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASQ,aAAaA,CAAC1D,IAAI,EAAE;EAChCgB,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;EAChD,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,IAAIyD,OAAO,GAAG,IAAI;EAClB,KAAK,IAAIrB,CAAC,GAAGc,MAAM,CAACpB,MAAM,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACzC,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAK,IAAI,IAAIc,MAAM,CAACd,CAAC,CAAC,KAAKhB,SAAS,IAAIC,MAAM,CAACf,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MAC1Ec,MAAM,CAACd,CAAC,CAAC,GAAGqB,OAAO;IACvB,CAAC,MAAM;MACHA,OAAO,GAAGP,MAAM,CAACd,CAAC,CAAC;IACvB;EACJ;EACA,OAAOc,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASS,SAASA,CAAC3D,IAAI,EAAE;EAC5B;EACA,SAAS4D,uBAAuBA,CAAC/B,CAAC,EAAEgC,MAAM,EAAE;IACxC,MAAMC,CAAC,GAAGjC,CAAC,GAAGgC,MAAM,GAAG,CAAC;IACxB,MAAME,KAAK,GAAG,EAAE;IAChB,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,CAAC,EAAE1B,CAAC,EAAE,EAAE;MACxB,IAAIA,CAAC,GAAGyB,MAAM,EAAEE,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,KACzB,IAAI5B,CAAC,GAAGP,CAAC,EAAEkC,KAAK,CAACC,IAAI,CAACnC,CAAC,GAAGgC,MAAM,GAAG,CAAC,CAAC,CAAC,KACtCE,KAAK,CAACC,IAAI,CAAC5B,CAAC,GAAGyB,MAAM,CAAC;IAC/B;IACA,OAAOE,KAAK;EAChB;;EAEA;EACA,SAASE,MAAMA,CAAC7B,CAAC,EAAE8B,CAAC,EAAE1D,CAAC,EAAEuD,KAAK,EAAEI,UAAU,EAAE;IACxC,IAAID,CAAC,KAAK,CAAC,EAAE,OAAOC,UAAU,CAAC/B,CAAC,CAAC;IAEjC,MAAMD,KAAK,GAAG,CAAC3B,CAAC,GAAGuD,KAAK,CAAC3B,CAAC,CAAC,KAAK2B,KAAK,CAAC3B,CAAC,GAAG8B,CAAC,CAAC,GAAGH,KAAK,CAAC3B,CAAC,CAAC,CAAC;IACxD,MAAMgC,IAAI,GAAGH,MAAM,CAAC7B,CAAC,GAAG,CAAC,EAAE8B,CAAC,GAAG,CAAC,EAAE1D,CAAC,EAAEuD,KAAK,EAAEI,UAAU,CAAC;IACvD,MAAME,KAAK,GAAGJ,MAAM,CAAC7B,CAAC,EAAE8B,CAAC,GAAG,CAAC,EAAE1D,CAAC,EAAEuD,KAAK,EAAEI,UAAU,CAAC;IAEpD,OAAO,CAAC,CAAC,GAAGhC,KAAK,IAAIiC,IAAI,GAAGjC,KAAK,GAAGkC,KAAK;EAC7C;;EAEA;EACArD,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;EAE5C,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGnD,IAAI,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,MAAM;IAAEA,CAAC;IAAED;EAAE,CAAC,CAAC,CAAC,CACvCE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACH,CAAC,IAAI,IAAI,IAAI,CAACI,KAAK,CAACD,CAAC,CAACH,CAAC,CAAC,CAAC;EAE5C,MAAM2D,MAAM,GAAG,CAAC;EAChB,MAAMhC,CAAC,GAAGsB,KAAK,CAACrB,MAAM,GAAG,CAAC;EAC1B,IAAID,CAAC,GAAGgC,MAAM,EAAE;IACZ7C,OAAO,CAACoC,IAAI,CAAC,kDAAkD,CAAC;IAChE,OAAOF,MAAM;EACjB;EAEA,MAAMoB,KAAK,GAAGnB,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACF,CAAC,CAAC;EACjC,MAAMoE,KAAK,GAAGpB,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACH,CAAC,CAAC;EACjC,MAAM6D,KAAK,GAAGH,uBAAuB,CAAC/B,CAAC,EAAEgC,MAAM,CAAC;EAEhD,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,IAAI,IAAI,IAAI9B,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MACvC,MAAM5B,CAAC,GAAG4B,CAAC,IAAIP,CAAC,GAAGgC,MAAM,GAAG,CAAC,CAAC,IAAIX,MAAM,CAACpB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAE;MACvD;MACA,IAAIe,CAAC,GAAGgB,MAAM;MACd,OAAOhB,CAAC,GAAGkB,KAAK,CAACjC,MAAM,GAAG,CAAC,IAAItB,CAAC,IAAIuD,KAAK,CAAClB,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE;;MAErD;MACAK,MAAM,CAACd,CAAC,CAAC,GAAG6B,MAAM,CAACpB,CAAC,EAAEgB,MAAM,EAAErD,CAAC,EAAEuD,KAAK,EAAEQ,KAAK,CAAC;IAClD;EACJ;EAEA,OAAOrB,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASsB,YAAYA,CAACxE,IAAI,EAAE;EAC/BgB,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;EAE/C,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGnD,IAAI,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,MAAM;IAAEA,CAAC;IAAED;EAAE,CAAC,CAAC,CAAC,CACvCE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACH,CAAC,IAAI,IAAI,IAAI,CAACI,KAAK,CAACD,CAAC,CAACH,CAAC,CAAC,CAAC;EAE5C,IAAIiD,KAAK,CAACrB,MAAM,GAAG,CAAC,EAAE;IAClBd,OAAO,CAACoC,IAAI,CAAC,kCAAkC,CAAC;IAChD,OAAOF,MAAM;EACjB;EAEA,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,IAAI,IAAI,IAAI9B,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MACvC,MAAMqC,KAAK,GAAGtB,KAAK,CAACuB,SAAS,CAACrE,CAAC,IAAIA,CAAC,CAACF,CAAC,GAAGiC,CAAC,CAAC;MAC3C,MAAMuC,KAAK,GAAGF,KAAK,GAAG,CAAC;MACvB,IAAIE,KAAK,GAAG,CAAC,IAAIF,KAAK,GAAG,CAAC,IAAItB,KAAK,CAACrB,MAAM,EAAE;MAE5C,MAAM8C,EAAE,GAAGzB,KAAK,CAACwB,KAAK,CAAC,CAACzE,CAAC;MACzB,MAAM2E,EAAE,GAAG1B,KAAK,CAACwB,KAAK,GAAG,CAAC,CAAC,CAACzE,CAAC;MAC7B,MAAM4E,EAAE,GAAG3B,KAAK,CAACwB,KAAK,GAAG,CAAC,CAAC,CAACzE,CAAC;MAC7B,MAAM6E,EAAE,GAAG5B,KAAK,CAACwB,KAAK,GAAG,CAAC,CAAC,CAACzE,CAAC;MAE7B,MAAM8E,EAAE,GAAG7B,KAAK,CAACwB,KAAK,GAAG,CAAC,CAAC,CAACxE,CAAC;MAC7B,MAAM8E,EAAE,GAAG9B,KAAK,CAACwB,KAAK,GAAG,CAAC,CAAC,CAACxE,CAAC;MAE7B,MAAMK,CAAC,GAAG,CAAC4B,CAAC,GAAG4C,EAAE,KAAKC,EAAE,GAAGD,EAAE,CAAC,CAAC,CAAC;MAChC,MAAMnE,EAAE,GAAGL,CAAC,GAAGA,CAAC;QAAEM,EAAE,GAAGD,EAAE,GAAGL,CAAC;MAE7B0C,MAAM,CAACd,CAAC,CAAC,GAAG,GAAG,IACV,CAAC,GAAGyC,EAAE,GACP,CAAC,CAACD,EAAE,GAAGE,EAAE,IAAItE,CAAC,GACd,CAAC,CAAC,GAAGoE,EAAE,GAAG,CAAC,GAAGC,EAAE,GAAG,CAAC,GAAGC,EAAE,GAAGC,EAAE,IAAIlE,EAAE,GACpC,CAAC,CAAC+D,EAAE,GAAG,CAAC,GAAGC,EAAE,GAAG,CAAC,GAAGC,EAAE,GAAGC,EAAE,IAAIjE,EAAE,CACpC;IACL;EACJ;EAEA,OAAOoC,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASgC,YAAYA,CAAClF,IAAI,EAAE;EAC/BgB,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;EAE/C,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGpD,cAAc,CAACC,IAAI,CAAC;EAClC,MAAM6B,CAAC,GAAGsB,KAAK,CAACrB,MAAM;EAEtB,IAAID,CAAC,GAAG,CAAC,EAAE,OAAOqB,MAAM;;EAExB;EACA,MAAMD,EAAE,GAAG,EAAE;IAAEkC,EAAE,GAAG,EAAE;IAAErB,CAAC,GAAG,EAAE;IAAEtD,CAAC,GAAG,EAAE;EACtC,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;IAC5Ba,EAAE,CAACb,CAAC,CAAC,GAAGe,KAAK,CAACf,CAAC,GAAG,CAAC,CAAC,CAACjC,CAAC,GAAGgD,KAAK,CAACf,CAAC,CAAC,CAACjC,CAAC;IACnCgF,EAAE,CAAC/C,CAAC,CAAC,GAAGe,KAAK,CAACf,CAAC,GAAG,CAAC,CAAC,CAAClC,CAAC,GAAGiD,KAAK,CAACf,CAAC,CAAC,CAAClC,CAAC;IACnC4D,CAAC,CAAC1B,CAAC,CAAC,GAAG+C,EAAE,CAAC/C,CAAC,CAAC,GAAGa,EAAE,CAACb,CAAC,CAAC;EACxB;EAEA5B,CAAC,CAAC,CAAC,CAAC,GAAGsD,CAAC,CAAC,CAAC,CAAC;EACX,KAAK,IAAI1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;IAC5B,IAAI0B,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAG0B,CAAC,CAAC1B,CAAC,CAAC,IAAI,CAAC,EAAE;MACtB5B,CAAC,CAAC4B,CAAC,CAAC,GAAG,CAAC;IACZ,CAAC,MAAM;MACH,MAAMgD,EAAE,GAAG,CAAC,GAAGnC,EAAE,CAACb,CAAC,CAAC,GAAGa,EAAE,CAACb,CAAC,GAAG,CAAC,CAAC;MAChC,MAAMiD,EAAE,GAAGpC,EAAE,CAACb,CAAC,CAAC,GAAG,CAAC,GAAGa,EAAE,CAACb,CAAC,GAAG,CAAC,CAAC;MAChC5B,CAAC,CAAC4B,CAAC,CAAC,GAAIgD,EAAE,GAAGC,EAAE,KAAM,CAAC,GAAG,CAAC,GAAG,CAACD,EAAE,GAAGC,EAAE,KAAMD,EAAE,GAAGtB,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAKiD,EAAE,GAAGvB,CAAC,CAAC1B,CAAC,CAAE,CAAC;IAC5E;EACJ;EACA5B,CAAC,CAACqB,CAAC,GAAG,CAAC,CAAC,GAAGiC,CAAC,CAACjC,CAAC,GAAG,CAAC,CAAC;EAEnB,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,IAAI,IAAI,IAAI9B,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MACvC,MAAMkD,GAAG,GAAGnC,KAAK,CAACuB,SAAS,CAACrE,CAAC,IAAIA,CAAC,CAACF,CAAC,GAAGiC,CAAC,CAAC;MACzC,IAAIkD,GAAG,IAAI,CAAC,EAAE;MAEd,MAAMN,EAAE,GAAG7B,KAAK,CAACmC,GAAG,GAAG,CAAC,CAAC,CAACnF,CAAC;MAC3B,MAAM8E,EAAE,GAAG9B,KAAK,CAACmC,GAAG,CAAC,CAACnF,CAAC;MACvB,MAAMM,EAAE,GAAG0C,KAAK,CAACmC,GAAG,GAAG,CAAC,CAAC,CAACpF,CAAC;MAC3B,MAAMQ,EAAE,GAAGyC,KAAK,CAACmC,GAAG,CAAC,CAACpF,CAAC;MACvB,MAAMqF,EAAE,GAAG/E,CAAC,CAAC8E,GAAG,GAAG,CAAC,CAAC;MACrB,MAAME,EAAE,GAAGhF,CAAC,CAAC8E,GAAG,CAAC;MAEjB,MAAMrD,CAAC,GAAGgD,EAAE,GAAGD,EAAE;MACjB,MAAMS,CAAC,GAAG,CAACrD,CAAC,GAAG4C,EAAE,IAAI/C,CAAC;MACtBiB,MAAM,CAACd,CAAC,CAAC,GAAG7B,OAAO,CAACkF,CAAC,EAAEhF,EAAE,EAAEC,EAAE,EAAE6E,EAAE,GAAGtD,CAAC,EAAEuD,EAAE,GAAGvD,CAAC,CAAC;IAClD;EACJ;EAEA,OAAOiB,MAAM;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASwC,SAASA,CAAC1F,IAAI,EAAE;EAC5BgB,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;EAE5C,MAAMiC,MAAM,GAAG,CAAC,GAAGlD,IAAI,CAAC;EACxB,MAAMmD,KAAK,GAAGpD,cAAc,CAACC,IAAI,CAAC;EAClC,MAAM6B,CAAC,GAAGsB,KAAK,CAACrB,MAAM;EAEtB,IAAID,CAAC,GAAG,CAAC,EAAE,OAAOqB,MAAM;EAExB,MAAM/C,CAAC,GAAGgD,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACF,CAAC,CAAC;EAC7B,MAAMD,CAAC,GAAGiD,KAAK,CAAClD,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACH,CAAC,CAAC;EAC7B,MAAM4D,CAAC,GAAG,IAAI5B,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;EAE1B,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;IAC5B0B,CAAC,CAAC1B,CAAC,CAAC,GAAG,CAAClC,CAAC,CAACkC,CAAC,GAAG,CAAC,CAAC,GAAGlC,CAAC,CAACkC,CAAC,CAAC,KAAKjC,CAAC,CAACiC,CAAC,GAAG,CAAC,CAAC,GAAGjC,CAAC,CAACiC,CAAC,CAAC,CAAC;EAChD;EAEA,MAAM5B,CAAC,GAAG,EAAE;EACZ,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAAG,CAAC,EAAEO,CAAC,EAAE,EAAE;IAC5B,MAAMgD,EAAE,GAAGO,IAAI,CAACC,GAAG,CAAC9B,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAG0B,CAAC,CAAC1B,CAAC,CAAC,CAAC;IACpC,MAAMiD,EAAE,GAAGM,IAAI,CAACC,GAAG,CAAC9B,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAG0B,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,CAAC;IACxC5B,CAAC,CAAC4B,CAAC,CAAC,GAAIgD,EAAE,GAAGC,EAAE,KAAK,CAAC,GAAK,CAACvB,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAG0B,CAAC,CAAC1B,CAAC,CAAC,IAAI,CAAC,GAC3C,CAACgD,EAAE,GAAGtB,CAAC,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAAGiD,EAAE,GAAGvB,CAAC,CAAC1B,CAAC,CAAC,KAAKgD,EAAE,GAAGC,EAAE,CAAC;EAC/C;EACA;EACA7E,CAAC,CAAC,CAAC,CAAC,GAAGsD,CAAC,CAAC,CAAC,CAAC;EACXtD,CAAC,CAAC,CAAC,CAAC,GAAGsD,CAAC,CAAC,CAAC,CAAC;EACXtD,CAAC,CAACqB,CAAC,GAAG,CAAC,CAAC,GAAGiC,CAAC,CAACjC,CAAC,GAAG,CAAC,CAAC;EACnBrB,CAAC,CAACqB,CAAC,GAAG,CAAC,CAAC,GAAGiC,CAAC,CAACjC,CAAC,GAAG,CAAC,CAAC;EAEnB,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,MAAM,CAACpB,MAAM,EAAEM,CAAC,EAAE,EAAE;IACpC,IAAIc,MAAM,CAACd,CAAC,CAAC,IAAI,IAAI,IAAI9B,KAAK,CAAC4C,MAAM,CAACd,CAAC,CAAC,CAAC,EAAE;MACvC,MAAMkD,GAAG,GAAGnC,KAAK,CAACuB,SAAS,CAACrE,CAAC,IAAIA,CAAC,CAACF,CAAC,GAAGiC,CAAC,CAAC;MACzC,IAAIkD,GAAG,IAAI,CAAC,EAAE;MAEd,MAAMN,EAAE,GAAG7E,CAAC,CAACmF,GAAG,GAAG,CAAC,CAAC;QAAEL,EAAE,GAAG9E,CAAC,CAACmF,GAAG,CAAC;MAClC,MAAM7E,EAAE,GAAGP,CAAC,CAACoF,GAAG,GAAG,CAAC,CAAC;QAAE5E,EAAE,GAAGR,CAAC,CAACoF,GAAG,CAAC;MAClC,MAAMG,CAAC,GAAG,CAACrD,CAAC,GAAG4C,EAAE,KAAKC,EAAE,GAAGD,EAAE,CAAC;MAC9B,MAAMO,EAAE,GAAG/E,CAAC,CAAC8E,GAAG,GAAG,CAAC,CAAC,IAAIL,EAAE,GAAGD,EAAE,CAAC;MACjC,MAAMQ,EAAE,GAAGhF,CAAC,CAAC8E,GAAG,CAAC,IAAIL,EAAE,GAAGD,EAAE,CAAC;MAE7B9B,MAAM,CAACd,CAAC,CAAC,GAAG7B,OAAO,CAACkF,CAAC,EAAEhF,EAAE,EAAEC,EAAE,EAAE6E,EAAE,EAAEC,EAAE,CAAC;IAC1C;EACJ;EAEA,OAAOtC,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}