{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n  return data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 前向查找\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      // 后向查找\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 距离更近的邻居\n        result[i] = i - prev <= next - i ? result[prev] : result[next];\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 找前一个和后一个非空\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 线性插值\n        result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n  // 首先构造自然三次样条的求解函数\n  function cubicSplineCoefficients(x, y) {\n    const n = x.length;\n    const a = y.slice();\n    const h = new Array(n - 1);\n    const alpha = new Array(n - 1);\n    for (let i = 0; i < n - 1; i++) {\n      h[i] = x[i + 1] - x[i];\n      if (h[i] <= 0) {\n        throw new Error('x values must be strictly increasing');\n      }\n      alpha[i] = 3 / h[i] * (a[i + 1] - a[i]) - 3 / h[i - 1 || 1] * (a[i] - a[i - 1 || 0]);\n    }\n    const l = [1],\n      mu = [0],\n      z = [0];\n    for (let i = 1; i < n - 1; i++) {\n      l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n      mu[i] = h[i] / l[i];\n      z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n    }\n    l[n - 1] = 1;\n    z[n - 1] = 0;\n    const c = Array(n).fill(0);\n    const b = Array(n - 1);\n    const d = Array(n - 1);\n    for (let j = n - 2; j >= 0; j--) {\n      c[j] = z[j] - mu[j] * c[j + 1];\n      b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n      d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n    }\n    return {\n      a,\n      b,\n      c,\n      d,\n      x\n    };\n  }\n\n  // 然后构造样条插值函数\n  function cubicSplineInterpolate(xi, coefs) {\n    const {\n      a,\n      b,\n      c,\n      d,\n      x\n    } = coefs;\n    let i = x.length - 2;\n    for (let j = 0; j < x.length - 1; j++) {\n      if (xi >= x[j] && xi <= x[j + 1]) {\n        i = j;\n        break;\n      }\n    }\n    const dx = xi - x[i];\n    return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n  }\n\n  // 主函数\n  console.log('[fillCubicSpline] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  if (valid.length < 3) {\n    console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n    return result;\n  }\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const coefs = cubicSplineCoefficients(x, y);\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      result[i] = cubicSplineInterpolate(i, coefs);\n    }\n  }\n  return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n  console.log('[fillPolynomial] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  function lagrange(x) {\n    let y = 0;\n    for (let i = 0; i < n; i++) {\n      let term = valid[i].y;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n        }\n      }\n      y += term;\n    }\n    return y;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lagrange(i);\n    }\n  }\n  return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n  console.log('[fillStepBefore] method is working');\n  const result = [...data];\n  const lastVal = null;\n  for (let i = 1; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n  console.log('[fillStepAfter] method is working');\n  const result = [...data];\n  const lastVal = null;\n  for (let i = result.length - 2; i >= 0; i--) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      result[i] = lastVal;\n    } else {\n      lastVal = result[i];\n    }\n  }\n  return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n  // 首先构造均匀节点向量（open uniform knot vector）\n  function createUniformKnotVector(n, degree) {\n    const m = n + degree + 1;\n    const knots = [];\n    for (let i = 0; i < m; i++) {\n      if (i < degree) knots.push(0);else if (i > n) knots.push(n - degree + 1);else knots.push(i - degree);\n    }\n    return knots;\n  }\n  console.log('[fillBasis] method is working');\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n  console.log('[fillCardinal] method is working');\n  const result = [...data];\n  const valid = data.map((y, x) => ({\n    x,\n    y\n  })).filter(p => p.y != null && !isNaN(p.y));\n  if (valid.length < 4) {\n    console.warn('[fillCardinal] Not enough points');\n    return result;\n  }\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const p1Idx = valid.findIndex(p => p.x > i);\n      const p0Idx = p1Idx - 2;\n      if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n      const P0 = valid[p0Idx].y;\n      const P1 = valid[p0Idx + 1].y;\n      const P2 = valid[p0Idx + 2].y;\n      const P3 = valid[p0Idx + 3].y;\n      const x0 = valid[p0Idx + 1].x;\n      const x1 = valid[p0Idx + 2].x;\n      const t = (i - x0) / (x1 - x0); // normalized position\n      const t2 = t * t,\n        t3 = t2 * t;\n      result[i] = 0.5 * (2 * P1 + (-P0 + P2) * t + (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 + (-P0 + 3 * P1 - 3 * P2 + P3) * t3);\n    }\n  }\n  return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n  console.log('[fillMonotone] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 3) return result;\n\n  // 预计算斜率\n  const dx = [],\n    dy = [],\n    m = [],\n    t = [];\n  for (let i = 0; i < n - 1; i++) {\n    dx[i] = valid[i + 1].x - valid[i].x;\n    dy[i] = valid[i + 1].y - valid[i].y;\n    m[i] = dy[i] / dx[i];\n  }\n  t[0] = m[0];\n  for (let i = 1; i < n - 1; i++) {\n    if (m[i - 1] * m[i] <= 0) {\n      t[i] = 0;\n    } else {\n      const w1 = 2 * dx[i] + dx[i - 1];\n      const w2 = dx[i] + 2 * dx[i - 1];\n      t[i] = w1 + w2 === 0 ? 0 : (w1 + w2) / (w1 / m[i - 1] + w2 / m[i]);\n    }\n  }\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = valid[idx - 1].x;\n      const x1 = valid[idx].x;\n      const y0 = valid[idx - 1].y;\n      const y1 = valid[idx].y;\n      const t0 = t[idx - 1];\n      const t1 = t[idx];\n      const h = x1 - x0;\n      const s = (i - x0) / h;\n      result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n    }\n  }\n  return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n  console.log('[fillAkima] method is working');\n  const result = [...data];\n  const valid = getValidPoints(data);\n  const n = valid.length;\n  if (n < 5) return result;\n  const x = valid.map(p => p.x);\n  const y = valid.map(p => p.y);\n  const m = new Array(n - 1);\n  for (let i = 0; i < n - 1; i++) {\n    m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n  }\n  const t = [];\n  for (let i = 2; i < n - 2; i++) {\n    const w1 = Math.abs(m[i + 1] - m[i]);\n    const w2 = Math.abs(m[i - 1] - m[i - 2]);\n    t[i] = w1 + w2 === 0 ? (m[i - 1] + m[i]) / 2 : (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n  }\n  // 端点斜率回退为邻近斜率\n  t[0] = m[0];\n  t[1] = m[1];\n  t[n - 2] = m[n - 2];\n  t[n - 1] = m[n - 2];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] == null || isNaN(result[i])) {\n      const idx = valid.findIndex(p => p.x > i);\n      if (idx <= 0) continue;\n      const x0 = x[idx - 1],\n        x1 = x[idx];\n      const y0 = y[idx - 1],\n        y1 = y[idx];\n      const s = (i - x0) / (x1 - x0);\n      const t0 = t[idx - 1] * (x1 - x0);\n      const t1 = t[idx] * (x1 - x0);\n      result[i] = hermite(s, y0, y1, t0, t1);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["getValidPoints","data","map","y","x","filter","p","isNaN","ignoreNull","console","log","fillZero","v","undefined","Number","fillNearest","result","i","length","prev","next","linearInterpolate","fillCubicSpline","cubicSplineCoefficients","n","a","slice","h","Array","alpha","Error","l","mu","z","c","fill","b","d","j","cubicSplineInterpolate","xi","coefs","dx","valid","warn","fillPolynomial","lagrange","term","fillStepBefore","lastVal","fillStepAfter","fillBasis","createUniformKnotVector","degree","m","knots","push","fillCardinal","p1Idx","findIndex","p0Idx","P0","P1","P2","P3","x0","x1","t","t2","t3","fillMonotone","dy","w1","w2","idx","y0","y1","t0","t1","s","hermite","fillAkima","Math","abs"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n// 辅助函数：过滤 null 并返回索引和值\nfunction getValidPoints(data) {\n    return data.map((y, x) => ({ x, y })).filter(p => p.y != null && !isNaN(p.y));\n}\n\n// 直接忽略缺失值（null/undefined/NaN）\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    return data;\n}\n\n// 缺失值填充为0\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n// 最近邻填充--缺失值填充为最近的非空值\n// 注意：前向查找和后向查找，取距离更近的邻居\n// 适用于时间序列数据，保持趋势连续性\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 前向查找\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            // 后向查找\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 距离更近的邻居\n                result[i] = (i - prev <= next - i) ? result[prev] : result[next];\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 线性插值--缺失值填充为线性插值曲线\n// 注意：线性插值适用于数据点较少且趋势平滑的情况\n// 适用于时间序列数据，保持趋势连续性\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 找前一个和后一个非空\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 线性插值\n                result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 三次样条插值--缺失值填充为三次样条曲线\n// 注意：三次样条插值可能需要依赖第三方库，但也可徒手实现\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCubicSpline(data) {\n    // 首先构造自然三次样条的求解函数\n    function cubicSplineCoefficients(x, y) {\n        const n = x.length;\n        const a = y.slice();\n        const h = new Array(n - 1);\n        const alpha = new Array(n - 1);\n\n        for (let i = 0; i < n - 1; i++) {\n            h[i] = x[i + 1] - x[i];\n            if (h[i] <= 0) {\n                throw new Error('x values must be strictly increasing');\n            }\n            alpha[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1 || 1]) * (a[i] - a[i - 1 || 0]);\n        }\n\n        const l = [1], mu = [0], z = [0];\n        for (let i = 1; i < n - 1; i++) {\n            l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];\n            mu[i] = h[i] / l[i];\n            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n        }\n        l[n - 1] = 1;\n        z[n - 1] = 0;\n\n        const c = Array(n).fill(0);\n        const b = Array(n - 1);\n        const d = Array(n - 1);\n\n        for (let j = n - 2; j >= 0; j--) {\n            c[j] = z[j] - mu[j] * c[j + 1];\n            b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;\n            d[j] = (c[j + 1] - c[j]) / (3 * h[j]);\n        }\n        return { a, b, c, d, x };\n    }\n\n    // 然后构造样条插值函数\n    function cubicSplineInterpolate(xi, coefs) {\n        const { a, b, c, d, x } = coefs;\n        let i = x.length - 2;\n\n        for (let j = 0; j < x.length - 1; j++) {\n            if (xi >= x[j] && xi <= x[j + 1]) {\n                i = j;\n                break;\n            }\n        }\n\n        const dx = xi - x[i];\n        return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;\n    }\n\n    // 主函数\n    console.log('[fillCubicSpline] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n\n    if (valid.length < 3) {\n        console.warn('[fillCubicSpline] Not enough valid points to perform cubic spline.');\n        return result;\n    }\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const coefs = cubicSplineCoefficients(x, y);\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            result[i] = cubicSplineInterpolate(i, coefs);\n        }\n    }\n\n    return result;\n}\n\n// 多项式插值--缺失值填充为多项式曲线\n// 注意：多项式插值可能会导致过拟合，需谨慎使用\n// 适用于数据点较少且趋势明显的情况，在数据点多时会出现“龙格现象”（数值震荡），一般不太建议用于大量点\nexport function fillPolynomial(data) {\n    console.log('[fillPolynomial] method is working');\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n    function lagrange(x) {\n        let y = 0;\n        for (let i = 0; i < n; i++) {\n            let term = valid[i].y;\n            for (let j = 0; j < n; j++) {\n                if (i !== j) {\n                    term *= (x - valid[j].x) / (valid[i].x - valid[j].x);\n                }\n            }\n            y += term;\n        }\n        return y;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lagrange(i);\n        }\n    }\n    return result;\n}\n\n// 前向填充--缺失值填充为左侧最近的非空值\n// 注意：如果第一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepBefore(data) {\n    console.log('[fillStepBefore] method is working');\n    const result = [...data];\n    const lastVal = null;\n    for (let i = 1; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 后向填充--缺失值填充为右侧最近的非空值\n// 注意：如果最后一个值为null，则无法填充\n// 适用于时间序列数据，保持趋势连续性\nexport function fillStepAfter(data) {\n    console.log('[fillStepAfter] method is working');\n    const result = [...data];\n    const lastVal = null;\n    for (let i = result.length - 2; i >= 0; i--) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            result[i] = lastVal;\n        } else {\n            lastVal = result[i];\n        }\n    }\n    return result;\n}\n\n// 基础插值--缺失值填充为基础插值曲线\n// 注意：基础插值通常是指线性插值或样条插值\n// 适用于数据点较少且趋势平滑的情况\nexport function fillBasis(data) {\n    // 首先构造均匀节点向量（open uniform knot vector）\n    function createUniformKnotVector(n, degree) {\n        const m = n + degree + 1;\n        const knots = [];\n        for (let i = 0; i < m; i++) {\n            if (i < degree) knots.push(0);\n            else if (i > n) knots.push(n - degree + 1);\n            else knots.push(i - degree);\n        }\n        return knots;\n    }\n    console.log('[fillBasis] method is working');\n}\n\n// 立方插值--缺失值填充为立方插值曲线\n// 注意：立方插值通常是指三次样条插值或立方多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillCardinal(data) {\n    console.log('[fillCardinal] method is working');\n\n    const result = [...data];\n    const valid = data.map((y, x) => ({ x, y }))\n        .filter(p => p.y != null && !isNaN(p.y));\n\n    if (valid.length < 4) {\n        console.warn('[fillCardinal] Not enough points');\n        return result;\n    }\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const p1Idx = valid.findIndex(p => p.x > i);\n            const p0Idx = p1Idx - 2;\n            if (p0Idx < 0 || p1Idx + 1 >= valid.length) continue;\n\n            const P0 = valid[p0Idx].y;\n            const P1 = valid[p0Idx + 1].y;\n            const P2 = valid[p0Idx + 2].y;\n            const P3 = valid[p0Idx + 3].y;\n\n            const x0 = valid[p0Idx + 1].x;\n            const x1 = valid[p0Idx + 2].x;\n\n            const t = (i - x0) / (x1 - x0); // normalized position\n            const t2 = t * t, t3 = t2 * t;\n\n            result[i] = 0.5 * (\n                (2 * P1) +\n                (-P0 + P2) * t +\n                (2 * P0 - 5 * P1 + 4 * P2 - P3) * t2 +\n                (-P0 + 3 * P1 - 3 * P2 + P3) * t3\n            );\n        }\n    }\n\n    return result;\n}\n\n// 单调插值--缺失值填充为单调插值曲线\n// 注意：单调插值通常是指单调样条插值或单调多项式插值\n// 适用于数据点较多且趋势单调的情况\nexport function fillMonotone(data) {\n    console.log('[fillMonotone] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 3) return result;\n\n    // 预计算斜率\n    const dx = [], dy = [], m = [], t = [];\n    for (let i = 0; i < n - 1; i++) {\n        dx[i] = valid[i + 1].x - valid[i].x;\n        dy[i] = valid[i + 1].y - valid[i].y;\n        m[i] = dy[i] / dx[i];\n    }\n\n    t[0] = m[0];\n    for (let i = 1; i < n - 1; i++) {\n        if (m[i - 1] * m[i] <= 0) {\n            t[i] = 0;\n        } else {\n            const w1 = 2 * dx[i] + dx[i - 1];\n            const w2 = dx[i] + 2 * dx[i - 1];\n            t[i] = (w1 + w2) === 0 ? 0 : (w1 + w2) / ((w1 / m[i - 1]) + (w2 / m[i]));\n        }\n    }\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = valid[idx - 1].x;\n            const x1 = valid[idx].x;\n            const y0 = valid[idx - 1].y;\n            const y1 = valid[idx].y;\n            const t0 = t[idx - 1];\n            const t1 = t[idx];\n\n            const h = x1 - x0;\n            const s = (i - x0) / h;\n            result[i] = hermite(s, y0, y1, t0 * h, t1 * h);\n        }\n    }\n\n    return result;\n}\n\n// 阿基玛插值--缺失值填充为阿基玛插值曲线\n// 注意：阿基玛插值通常是指阿基玛样条插值或阿基玛多项式插值\n// 适用于数据点较多且趋势平滑的情况\nexport function fillAkima(data) {\n    console.log('[fillAkima] method is working');\n\n    const result = [...data];\n    const valid = getValidPoints(data);\n    const n = valid.length;\n\n    if (n < 5) return result;\n\n    const x = valid.map(p => p.x);\n    const y = valid.map(p => p.y);\n    const m = new Array(n - 1);\n\n    for (let i = 0; i < n - 1; i++) {\n        m[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);\n    }\n\n    const t = [];\n    for (let i = 2; i < n - 2; i++) {\n        const w1 = Math.abs(m[i + 1] - m[i]);\n        const w2 = Math.abs(m[i - 1] - m[i - 2]);\n        t[i] = (w1 + w2 === 0) ? ((m[i - 1] + m[i]) / 2) :\n            (w1 * m[i - 1] + w2 * m[i]) / (w1 + w2);\n    }\n    // 端点斜率回退为邻近斜率\n    t[0] = m[0];\n    t[1] = m[1];\n    t[n - 2] = m[n - 2];\n    t[n - 1] = m[n - 2];\n\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] == null || isNaN(result[i])) {\n            const idx = valid.findIndex(p => p.x > i);\n            if (idx <= 0) continue;\n\n            const x0 = x[idx - 1], x1 = x[idx];\n            const y0 = y[idx - 1], y1 = y[idx];\n            const s = (i - x0) / (x1 - x0);\n            const t0 = t[idx - 1] * (x1 - x0);\n            const t1 = t[idx] * (x1 - x0);\n\n            result[i] = hermite(s, y0, y1, t0, t1);\n        }\n    }\n\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}