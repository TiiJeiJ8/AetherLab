{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n/**\n * 直接忽略缺失值（null/undefined/NaN）\n * @param {Array} data\n * @returns {Array}\n */\nexport function ignoreNull(data) {\n  console.log('[ignoreNull] method is working');\n  return data.filter(v => v !== null && v !== undefined && !Number.isNaN(v));\n}\n\n/**\n * 缺失值填充为0\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillZero(data) {\n  console.log('[fillZero] method is working');\n  return data.map(v => v === null || v === undefined || Number.isNaN(v) ? 0 : v);\n}\n\n/**\n * 用最近的非空值填充缺失值（前向/后向最近邻）\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillNearest(data) {\n  console.log('[fillNearest] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 前向查找\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      // 后向查找\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 距离更近的邻居\n        result[i] = i - prev <= next - i ? result[prev] : result[next];\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * 线性插值填充缺失值\n * @param {Array} data\n * @returns {Array}\n */\nexport function linearInterpolate(data) {\n  console.log('[linearInterpolate] method is working');\n  const result = [...data];\n  for (let i = 0; i < result.length; i++) {\n    if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n      // 找前一个和后一个非空\n      let prev = i - 1;\n      while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n      let next = i + 1;\n      while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n      if (prev >= 0 && next < result.length) {\n        // 线性插值\n        result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n      } else if (prev >= 0) {\n        result[i] = result[prev];\n      } else if (next < result.length) {\n        result[i] = result[next];\n      } else {\n        result[i] = 0;\n      }\n    }\n  }\n  return result;\n}\n\n// 其它高级插值方法如 step-before、step-after、spline、basis、cardinal、monotone、akima、polynomial\n// 可根据需要引入第三方库或后续补充实现\n// 这里只做接口占位\n\nexport function spline(data) {\n  return linearInterpolate(data);\n}\nexport function polynomial(data) {\n  return linearInterpolate(data);\n}\nexport function stepBefore(data) {\n  return fillNearest(data);\n}\nexport function stepAfter(data) {\n  return fillNearest(data);\n}\nexport function basis(data) {\n  return linearInterpolate(data);\n}\nexport function cardinal(data) {\n  return linearInterpolate(data);\n}\nexport function monotone(data) {\n  return linearInterpolate(data);\n}\nexport function akima(data) {\n  return linearInterpolate(data);\n}\n\n// 用法示例：\n// import { ignoreNull, fillZero, linearInterpolate } from './nullHandling.js'\n// const cleanData = linearInterpolate([1, null, 3, NaN, 5])","map":{"version":3,"names":["ignoreNull","data","console","log","filter","v","undefined","Number","isNaN","fillZero","map","fillNearest","result","i","length","prev","next","linearInterpolate","spline","polynomial","stepBefore","stepAfter","basis","cardinal","monotone","akima"],"sources":["D:/Learning Material/Git/Fuck-Charts/frontend/src/assets/JS/utils/nullHandling.js"],"sourcesContent":["// nullHandling.js\n// 通用缺失值处理方法模块\n// 每个方法接收原始数据（数组），返回处理后的新数组\n\n/* eslint-disable */\n\n/**\n * 直接忽略缺失值（null/undefined/NaN）\n * @param {Array} data\n * @returns {Array}\n */\nexport function ignoreNull(data) {\n    console.log('[ignoreNull] method is working');\n    return data.filter(v => v !== null && v !== undefined && !Number.isNaN(v));\n}\n\n/**\n * 缺失值填充为0\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillZero(data) {\n    console.log('[fillZero] method is working');\n    return data.map(v => (v === null || v === undefined || Number.isNaN(v)) ? 0 : v);\n}\n\n/**\n * 用最近的非空值填充缺失值（前向/后向最近邻）\n * @param {Array} data\n * @returns {Array}\n */\nexport function fillNearest(data) {\n    console.log('[fillNearest] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 前向查找\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            // 后向查找\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 距离更近的邻居\n                result[i] = (i - prev <= next - i) ? result[prev] : result[next];\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * 线性插值填充缺失值\n * @param {Array} data\n * @returns {Array}\n */\nexport function linearInterpolate(data) {\n    console.log('[linearInterpolate] method is working');\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n        if (result[i] === null || result[i] === undefined || Number.isNaN(result[i])) {\n            // 找前一个和后一个非空\n            let prev = i - 1;\n            while (prev >= 0 && (result[prev] === null || result[prev] === undefined || Number.isNaN(result[prev]))) prev--;\n            let next = i + 1;\n            while (next < result.length && (result[next] === null || result[next] === undefined || Number.isNaN(result[next]))) next++;\n            if (prev >= 0 && next < result.length) {\n                // 线性插值\n                result[i] = result[prev] + (result[next] - result[prev]) * (i - prev) / (next - prev);\n            } else if (prev >= 0) {\n                result[i] = result[prev];\n            } else if (next < result.length) {\n                result[i] = result[next];\n            } else {\n                result[i] = 0;\n            }\n        }\n    }\n    return result;\n}\n\n// 其它高级插值方法如 step-before、step-after、spline、basis、cardinal、monotone、akima、polynomial\n// 可根据需要引入第三方库或后续补充实现\n// 这里只做接口占位\n\nexport function spline(data) { return linearInterpolate(data); }\nexport function polynomial(data) { return linearInterpolate(data); }\nexport function stepBefore(data) { return fillNearest(data); }\nexport function stepAfter(data) { return fillNearest(data); }\nexport function basis(data) { return linearInterpolate(data); }\nexport function cardinal(data) { return linearInterpolate(data); }\nexport function monotone(data) { return linearInterpolate(data); }\nexport function akima(data) { return linearInterpolate(data); }\n\n// 用法示例：\n// import { ignoreNull, fillZero, linearInterpolate } from './nullHandling.js'\n// const cleanData = linearInterpolate([1, null, 3, NaN, 5])\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}