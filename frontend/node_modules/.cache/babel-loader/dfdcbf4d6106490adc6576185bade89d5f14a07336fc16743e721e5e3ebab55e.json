{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx';\nconst API_BASE_URL = '/api';\nconst CACHE_KEY = 'fuck_charts_files';\n\n// 后端连接状态\nlet isBackendConnected = false;\n\n/**\n * 检测后端连接状态\n * @returns {Promise<boolean>} 连接状态\n */\nexport async function checkBackendConnection() {\n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 3000);\n    const response = await fetch(`${API_BASE_URL}/health`, {\n      method: 'GET',\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    isBackendConnected = response.ok;\n    return isBackendConnected;\n  } catch (error) {\n    console.log('后端连接检测:', error.message);\n    isBackendConnected = false;\n    return false;\n  }\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n  return isBackendConnected;\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n  try {\n    const cached = localStorage.getItem(CACHE_KEY);\n    return cached ? JSON.parse(cached) : [];\n  } catch (error) {\n    console.error('读取缓存失败:', error);\n    return [];\n  }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n  try {\n    const cached = getCachedFiles();\n    cached.push(fileInfo);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(cached));\n  } catch (error) {\n    console.error('保存到缓存失败:', error);\n  }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n  try {\n    const cached = getCachedFiles();\n    const filtered = cached.filter(file => file.id !== fileId);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(filtered));\n  } catch (error) {\n    console.error('从缓存删除失败:', error);\n  }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = e.target.result;\n        let workbook, worksheet, jsonData;\n        if (file.name.toLowerCase().endsWith('.csv')) {\n          // CSV文件解析\n          workbook = XLSX.read(data, {\n            type: 'string'\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1\n          });\n        } else {\n          // Excel文件解析\n          workbook = XLSX.read(data, {\n            type: 'array'\n          });\n          worksheet = workbook.Sheets[workbook.SheetNames[0]];\n          jsonData = XLSX.utils.sheet_to_json(worksheet, {\n            header: 1\n          });\n        }\n\n        // 限制预览行数\n        const previewData = jsonData.slice(0, 200);\n        resolve({\n          data: previewData,\n          totalRows: jsonData.length,\n          totalColumns: jsonData[0] ? jsonData[0].length : 0,\n          headers: jsonData[0] || []\n        });\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    if (file.name.toLowerCase().endsWith('.csv')) {\n      reader.readAsText(file, 'utf-8');\n    } else {\n      reader.readAsArrayBuffer(file);\n    }\n  });\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * @param {File} file - 要上传的文件对象\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file) {\n  // 首先解析文件内容\n  const parsedContent = await parseFileContent(file);\n  const fileInfo = {\n    id: Date.now() + Math.random().toString(36).substr(2, 9),\n    name: file.name,\n    size: file.size,\n    type: file.type,\n    rows: parsedContent.totalRows,\n    columns: parsedContent.totalColumns,\n    headers: parsedContent.headers,\n    createdAt: new Date().toISOString(),\n    status: 'local',\n    // local, uploading, uploaded, error\n    data: parsedContent.data,\n    file: file // 保存原始文件对象用于后续上传\n  };\n\n  // 检查后端连接状态\n  const isConnected = await checkBackendConnection();\n  if (isConnected) {\n    // 后端连接时直接上传\n    try {\n      fileInfo.status = 'uploading';\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await fetch(`${API_BASE_URL}/files/upload`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error('Upload failed');\n      }\n      const result = await response.json();\n      fileInfo.status = 'uploaded';\n      fileInfo.serverId = result.fileId;\n\n      // 同时保存到缓存\n      saveToCache(fileInfo);\n      return fileInfo;\n    } catch (error) {\n      console.error('文件上传失败:', error);\n      fileInfo.status = 'error';\n      saveToCache(fileInfo);\n      throw error;\n    }\n  } else {\n    // 后端未连接时保存到本地缓存\n    fileInfo.status = 'local';\n    saveToCache(fileInfo);\n    return fileInfo;\n  }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise} 文件预览数据\n */\nexport async function getFilePreview(fileId) {\n  // 先从缓存查找\n  const cachedFiles = getCachedFiles();\n  const cachedFile = cachedFiles.find(file => file.id === fileId);\n  if (cachedFile && cachedFile.data) {\n    return {\n      data: cachedFile.data,\n      totalRows: cachedFile.rows,\n      totalColumns: cachedFile.columns,\n      headers: cachedFile.headers\n    };\n  }\n\n  // 如果缓存中没有，且后端连接，则从后端获取\n  if (isBackendConnected) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/files/${fileId}/preview`);\n      if (!response.ok) {\n        throw new Error('Failed to get preview');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('获取文件预览失败:', error);\n      throw error;\n    }\n  }\n  throw new Error('文件预览不可用');\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo || !fileInfo.file) {\n    throw new Error('本地文件不存在');\n  }\n  if (!(await checkBackendConnection())) {\n    throw new Error('后端未连接');\n  }\n  try {\n    const formData = new FormData();\n    formData.append('file', fileInfo.file);\n    const response = await fetch(`${API_BASE_URL}/files/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error('同步失败');\n    }\n    const result = await response.json();\n\n    // 更新缓存中的文件状态\n    fileInfo.status = 'uploaded';\n    fileInfo.serverId = result.fileId;\n    const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n    return fileInfo;\n  } catch (error) {\n    console.error('同步文件失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n  const cachedFiles = getCachedFiles();\n  if (!(await checkBackendConnection())) {\n    return cachedFiles;\n  }\n  try {\n    const response = await fetch(`${API_BASE_URL}/files`);\n    if (!response.ok) {\n      return cachedFiles;\n    }\n    const remoteFiles = await response.json();\n\n    // 合并本地和远程文件，避免重复\n    const allFiles = [...cachedFiles];\n    remoteFiles.forEach(remoteFile => {\n      const existsInCache = cachedFiles.some(cached => cached.serverId === remoteFile.id);\n      if (!existsInCache) {\n        allFiles.push({\n          ...remoteFile,\n          id: remoteFile.id,\n          serverId: remoteFile.id,\n          status: 'uploaded'\n        });\n      }\n    });\n    return allFiles;\n  } catch (error) {\n    console.error('获取远程文件列表失败:', error);\n    return cachedFiles;\n  }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时从服务器删除\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n          method: 'DELETE'\n        });\n        if (!response.ok) {\n          console.warn('从服务器删除文件失败');\n        }\n      } catch (error) {\n        console.error('从服务器删除文件失败:', error);\n      }\n    }\n  }\n\n  // 从本地缓存删除\n  removeFromCache(fileId);\n  return {\n    success: true\n  };\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n  const cachedFiles = getCachedFiles();\n  const fileInfo = cachedFiles.find(file => file.id === fileId);\n  if (!fileInfo) {\n    throw new Error('文件不存在');\n  }\n\n  // 如果文件已上传到服务器，同时更新服务器\n  if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n    if (await checkBackendConnection()) {\n      try {\n        const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            name: newName\n          })\n        });\n        if (!response.ok) {\n          console.warn('服务器重命名失败');\n        }\n      } catch (error) {\n        console.error('服务器重命名失败:', error);\n      }\n    }\n  }\n\n  // 更新本地缓存\n  fileInfo.name = newName;\n  const updatedFiles = cachedFiles.map(file => file.id === fileId ? fileInfo : file);\n  localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles));\n  return {\n    success: true,\n    file: fileInfo\n  };\n}","map":{"version":3,"names":["XLSX","API_BASE_URL","CACHE_KEY","isBackendConnected","checkBackendConnection","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","signal","clearTimeout","ok","error","console","log","message","getBackendStatus","getCachedFiles","cached","localStorage","getItem","JSON","parse","saveToCache","fileInfo","push","setItem","stringify","removeFromCache","fileId","filtered","filter","file","id","parseFileContent","Promise","resolve","reject","reader","FileReader","onload","e","data","target","result","workbook","worksheet","jsonData","name","toLowerCase","endsWith","read","type","Sheets","SheetNames","utils","sheet_to_json","header","previewData","slice","totalRows","length","totalColumns","headers","onerror","Error","readAsText","readAsArrayBuffer","uploadFile","parsedContent","Date","now","Math","random","toString","substr","size","rows","columns","createdAt","toISOString","status","isConnected","formData","FormData","append","body","json","serverId","getFilePreview","cachedFiles","cachedFile","find","syncFileToBackend","updatedFiles","map","getAllFiles","remoteFiles","allFiles","forEach","remoteFile","existsInCache","some","deleteFile","warn","success","renameFile","newName"],"sources":["D:/Learning Material/Git/Fuck-Charts/newArchitecture/frontend_vue_design/src/services/FileServices.js"],"sourcesContent":["/* eslint-disable */\n/**\n * 文件上传与管理相关的 API 服务\n * 支持前端缓存和后端同步的双模式工作\n */\nimport * as XLSX from 'xlsx'\n\nconst API_BASE_URL = '/api'\nconst CACHE_KEY = 'fuck_charts_files'\n\n// 后端连接状态\nlet isBackendConnected = false\n\n/**\n * 检测后端连接状态\n * @returns {Promise<boolean>} 连接状态\n */\nexport async function checkBackendConnection() {\n    try {\n        const controller = new AbortController()\n        const timeoutId = setTimeout(() => controller.abort(), 3000)\n        \n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            signal: controller.signal\n        })\n        \n        clearTimeout(timeoutId)\n        isBackendConnected = response.ok\n        return isBackendConnected\n    } catch (error) {\n        console.log('后端连接检测:', error.message)\n        isBackendConnected = false\n        return false\n    }\n}\n\n/**\n * 获取后端连接状态\n * @returns {boolean} 连接状态\n */\nexport function getBackendStatus() {\n    return isBackendConnected\n}\n\n/**\n * 从本地缓存获取文件列表\n * @returns {Array} 缓存的文件列表\n */\nexport function getCachedFiles() {\n    try {\n        const cached = localStorage.getItem(CACHE_KEY)\n        return cached ? JSON.parse(cached) : []\n    } catch (error) {\n        console.error('读取缓存失败:', error)\n        return []\n    }\n}\n\n/**\n * 保存文件到本地缓存\n * @param {Object} fileInfo - 文件信息\n */\nexport function saveToCache(fileInfo) {\n    try {\n        const cached = getCachedFiles()\n        cached.push(fileInfo)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(cached))\n    } catch (error) {\n        console.error('保存到缓存失败:', error)\n    }\n}\n\n/**\n * 从缓存中删除文件\n * @param {string} fileId - 文件ID\n */\nexport function removeFromCache(fileId) {\n    try {\n        const cached = getCachedFiles()\n        const filtered = cached.filter(file => file.id !== fileId)\n        localStorage.setItem(CACHE_KEY, JSON.stringify(filtered))\n    } catch (error) {\n        console.error('从缓存删除失败:', error)\n    }\n}\n\n/**\n * 解析Excel/CSV文件\n * @param {File} file - 文件对象\n * @returns {Promise<Object>} 解析结果\n */\nexport async function parseFileContent(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        \n        reader.onload = (e) => {\n            try {\n                const data = e.target.result\n                let workbook, worksheet, jsonData\n                \n                if (file.name.toLowerCase().endsWith('.csv')) {\n                    // CSV文件解析\n                    workbook = XLSX.read(data, { type: 'string' })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 })\n                } else {\n                    // Excel文件解析\n                    workbook = XLSX.read(data, { type: 'array' })\n                    worksheet = workbook.Sheets[workbook.SheetNames[0]]\n                    jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 })\n                }\n                \n                // 限制预览行数\n                const previewData = jsonData.slice(0, 200)\n                \n                resolve({\n                    data: previewData,\n                    totalRows: jsonData.length,\n                    totalColumns: jsonData[0] ? jsonData[0].length : 0,\n                    headers: jsonData[0] || []\n                })\n            } catch (error) {\n                reject(error)\n            }\n        }\n        \n        reader.onerror = () => reject(new Error('文件读取失败'))\n        \n        if (file.name.toLowerCase().endsWith('.csv')) {\n            reader.readAsText(file, 'utf-8')\n        } else {\n            reader.readAsArrayBuffer(file)\n        }\n    })\n}\n\n/**\n * 智能上传文件（根据后端连接状态决定上传或缓存）\n * @param {File} file - 要上传的文件对象\n * @returns {Promise} 上传结果\n */\nexport async function uploadFile(file) {\n    // 首先解析文件内容\n    const parsedContent = await parseFileContent(file)\n    \n    const fileInfo = {\n        id: Date.now() + Math.random().toString(36).substr(2, 9),\n        name: file.name,\n        size: file.size,\n        type: file.type,\n        rows: parsedContent.totalRows,\n        columns: parsedContent.totalColumns,\n        headers: parsedContent.headers,\n        createdAt: new Date().toISOString(),\n        status: 'local', // local, uploading, uploaded, error\n        data: parsedContent.data,\n        file: file // 保存原始文件对象用于后续上传\n    }\n    \n    // 检查后端连接状态\n    const isConnected = await checkBackendConnection()\n    \n    if (isConnected) {\n        // 后端连接时直接上传\n        try {\n            fileInfo.status = 'uploading'\n            const formData = new FormData()\n            formData.append('file', file)\n\n            const response = await fetch(`${API_BASE_URL}/files/upload`, {\n                method: 'POST',\n                body: formData\n            })\n\n            if (!response.ok) {\n                throw new Error('Upload failed')\n            }\n\n            const result = await response.json()\n            fileInfo.status = 'uploaded'\n            fileInfo.serverId = result.fileId\n            \n            // 同时保存到缓存\n            saveToCache(fileInfo)\n            \n            return fileInfo\n        } catch (error) {\n            console.error('文件上传失败:', error)\n            fileInfo.status = 'error'\n            saveToCache(fileInfo)\n            throw error\n        }\n    } else {\n        // 后端未连接时保存到本地缓存\n        fileInfo.status = 'local'\n        saveToCache(fileInfo)\n        return fileInfo\n    }\n}\n\n/**\n * 获取文件预览数据\n * @param {string} fileId - 文件ID\n * @returns {Promise} 文件预览数据\n */\nexport async function getFilePreview(fileId) {\n    // 先从缓存查找\n    const cachedFiles = getCachedFiles()\n    const cachedFile = cachedFiles.find(file => file.id === fileId)\n    \n    if (cachedFile && cachedFile.data) {\n        return {\n            data: cachedFile.data,\n            totalRows: cachedFile.rows,\n            totalColumns: cachedFile.columns,\n            headers: cachedFile.headers\n        }\n    }\n    \n    // 如果缓存中没有，且后端连接，则从后端获取\n    if (isBackendConnected) {\n        try {\n            const response = await fetch(`${API_BASE_URL}/files/${fileId}/preview`)\n            if (!response.ok) {\n                throw new Error('Failed to get preview')\n            }\n            return await response.json()\n        } catch (error) {\n            console.error('获取文件预览失败:', error)\n            throw error\n        }\n    }\n    \n    throw new Error('文件预览不可用')\n}\n\n/**\n * 同步本地文件到后端\n * @param {string} fileId - 文件ID\n * @returns {Promise} 同步结果\n */\nexport async function syncFileToBackend(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n    \n    if (!fileInfo || !fileInfo.file) {\n        throw new Error('本地文件不存在')\n    }\n    \n    if (!await checkBackendConnection()) {\n        throw new Error('后端未连接')\n    }\n    \n    try {\n        const formData = new FormData()\n        formData.append('file', fileInfo.file)\n        \n        const response = await fetch(`${API_BASE_URL}/files/upload`, {\n            method: 'POST',\n            body: formData\n        })\n        \n        if (!response.ok) {\n            throw new Error('同步失败')\n        }\n        \n        const result = await response.json()\n        \n        // 更新缓存中的文件状态\n        fileInfo.status = 'uploaded'\n        fileInfo.serverId = result.fileId\n        \n        const updatedFiles = cachedFiles.map(file => \n            file.id === fileId ? fileInfo : file\n        )\n        localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n        \n        return fileInfo\n    } catch (error) {\n        console.error('同步文件失败:', error)\n        throw error\n    }\n}\n\n/**\n * 获取所有文件列表（本地缓存 + 远程文件）\n * @returns {Promise<Array>} 文件列表\n */\nexport async function getAllFiles() {\n    const cachedFiles = getCachedFiles()\n    \n    if (!await checkBackendConnection()) {\n        return cachedFiles\n    }\n    \n    try {\n        const response = await fetch(`${API_BASE_URL}/files`)\n        if (!response.ok) {\n            return cachedFiles\n        }\n        \n        const remoteFiles = await response.json()\n        \n        // 合并本地和远程文件，避免重复\n        const allFiles = [...cachedFiles]\n        \n        remoteFiles.forEach(remoteFile => {\n            const existsInCache = cachedFiles.some(cached => \n                cached.serverId === remoteFile.id\n            )\n            \n            if (!existsInCache) {\n                allFiles.push({\n                    ...remoteFile,\n                    id: remoteFile.id,\n                    serverId: remoteFile.id,\n                    status: 'uploaded'\n                })\n            }\n        })\n        \n        return allFiles\n    } catch (error) {\n        console.error('获取远程文件列表失败:', error)\n        return cachedFiles\n    }\n}\n\n/**\n * 智能删除文件（根据文件状态决定删除位置）\n * @param {string} fileId - 要删除的文件ID\n */\nexport async function deleteFile(fileId) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n    \n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n    \n    // 如果文件已上传到服务器，同时从服务器删除\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}`, {\n                    method: 'DELETE'\n                })\n                if (!response.ok) {\n                    console.warn('从服务器删除文件失败')\n                }\n            } catch (error) {\n                console.error('从服务器删除文件失败:', error)\n            }\n        }\n    }\n    \n    // 从本地缓存删除\n    removeFromCache(fileId)\n    \n    return { success: true }\n}\n\n/**\n * 智能重命名文件\n * @param {string} fileId - 文件ID\n * @param {string} newName - 新文件名\n */\nexport async function renameFile(fileId, newName) {\n    const cachedFiles = getCachedFiles()\n    const fileInfo = cachedFiles.find(file => file.id === fileId)\n    \n    if (!fileInfo) {\n        throw new Error('文件不存在')\n    }\n    \n    // 如果文件已上传到服务器，同时更新服务器\n    if (fileInfo.status === 'uploaded' && fileInfo.serverId) {\n        if (await checkBackendConnection()) {\n            try {\n                const response = await fetch(`${API_BASE_URL}/files/${fileInfo.serverId}/rename`, {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ name: newName })\n                })\n                if (!response.ok) {\n                    console.warn('服务器重命名失败')\n                }\n            } catch (error) {\n                console.error('服务器重命名失败:', error)\n            }\n        }\n    }\n    \n    // 更新本地缓存\n    fileInfo.name = newName\n    const updatedFiles = cachedFiles.map(file => \n        file.id === fileId ? fileInfo : file\n    )\n    localStorage.setItem(CACHE_KEY, JSON.stringify(updatedFiles))\n    \n    return { success: true, file: fileInfo }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}