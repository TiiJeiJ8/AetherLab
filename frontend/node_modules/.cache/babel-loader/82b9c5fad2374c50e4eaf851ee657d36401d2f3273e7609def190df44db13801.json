{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/* eslint-disable */\n/**\n * 后端连接状态检测服务\n */\n\nclass BackendConnectionService {\n  constructor() {\n    this.apiBaseUrl = '/api';\n    this.isConnected = false;\n    this.connectionCheckInterval = null;\n    this.listeners = new Set();\n    this.checkInterval = 5000; // 5秒检查一次\n    this.timeoutDuration = 3000; // 3秒超时\n\n    this.startConnectionCheck();\n  }\n\n  // 开始连接检查\n  startConnectionCheck() {\n    this.checkConnection();\n    this.connectionCheckInterval = setInterval(() => {\n      this.checkConnection();\n    }, this.checkInterval);\n  }\n\n  // 停止连接检查\n  stopConnectionCheck() {\n    if (this.connectionCheckInterval) {\n      clearInterval(this.connectionCheckInterval);\n      this.connectionCheckInterval = null;\n    }\n  }\n\n  // 检查后端连接状态\n  async checkConnection() {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeoutDuration);\n      const response = await fetch(`${this.apiBaseUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      clearTimeout(timeoutId);\n      const wasConnected = this.isConnected;\n      this.isConnected = response.ok;\n      if (wasConnected !== this.isConnected) {\n        this.notifyListeners({\n          connected: this.isConnected,\n          timestamp: new Date().toISOString()\n        });\n      }\n      return this.isConnected;\n    } catch (error) {\n      const wasConnected = this.isConnected;\n      this.isConnected = false;\n      if (wasConnected !== this.isConnected) {\n        this.notifyListeners({\n          connected: this.isConnected,\n          timestamp: new Date().toISOString(),\n          error: error.message\n        });\n      }\n      return false;\n    }\n  }\n\n  // 添加连接状态监听器\n  addConnectionListener(callback) {\n    this.listeners.add(callback);\n\n    // 立即通知当前状态\n    callback({\n      connected: this.isConnected,\n      timestamp: new Date().toISOString()\n    });\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  // 通知所有监听器\n  notifyListeners(status) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(status);\n      } catch (error) {\n        console.error('通知连接状态监听器失败:', error);\n      }\n    });\n  }\n\n  // 获取当前连接状态\n  getConnectionStatus() {\n    return {\n      connected: this.isConnected,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  // 手动触发连接检查\n  async forceCheck() {\n    return await this.checkConnection();\n  }\n\n  // 测试API端点\n  async testEndpoint(endpoint) {\n    try {\n      const response = await fetch(`${this.apiBaseUrl}${endpoint}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      return {\n        success: response.ok,\n        status: response.status,\n        statusText: response.statusText\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // 销毁服务\n  destroy() {\n    this.stopConnectionCheck();\n    this.listeners.clear();\n  }\n}\n\n// 创建单例实例\nconst backendConnectionService = new BackendConnectionService();\nexport default backendConnectionService;","map":{"version":3,"names":["BackendConnectionService","constructor","apiBaseUrl","isConnected","connectionCheckInterval","listeners","Set","checkInterval","timeoutDuration","startConnectionCheck","checkConnection","setInterval","stopConnectionCheck","clearInterval","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","signal","headers","clearTimeout","wasConnected","ok","notifyListeners","connected","timestamp","Date","toISOString","error","message","addConnectionListener","callback","add","delete","status","forEach","listener","console","getConnectionStatus","forceCheck","testEndpoint","endpoint","success","statusText","destroy","clear","backendConnectionService"],"sources":["D:/Learning Material/Git/Fuck-Charts/newArchitecture/frontend_vue_design/src/services/BackendConnectionService.js"],"sourcesContent":["/* eslint-disable */\n/**\n * 后端连接状态检测服务\n */\n\nclass BackendConnectionService {\n    constructor() {\n        this.apiBaseUrl = '/api'\n        this.isConnected = false\n        this.connectionCheckInterval = null\n        this.listeners = new Set()\n        this.checkInterval = 5000 // 5秒检查一次\n        this.timeoutDuration = 3000 // 3秒超时\n        \n        this.startConnectionCheck()\n    }\n\n    // 开始连接检查\n    startConnectionCheck() {\n        this.checkConnection()\n        this.connectionCheckInterval = setInterval(() => {\n            this.checkConnection()\n        }, this.checkInterval)\n    }\n\n    // 停止连接检查\n    stopConnectionCheck() {\n        if (this.connectionCheckInterval) {\n            clearInterval(this.connectionCheckInterval)\n            this.connectionCheckInterval = null\n        }\n    }\n\n    // 检查后端连接状态\n    async checkConnection() {\n        try {\n            const controller = new AbortController()\n            const timeoutId = setTimeout(() => controller.abort(), this.timeoutDuration)\n            \n            const response = await fetch(`${this.apiBaseUrl}/health`, {\n                method: 'GET',\n                signal: controller.signal,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            \n            clearTimeout(timeoutId)\n            \n            const wasConnected = this.isConnected\n            this.isConnected = response.ok\n            \n            if (wasConnected !== this.isConnected) {\n                this.notifyListeners({\n                    connected: this.isConnected,\n                    timestamp: new Date().toISOString()\n                })\n            }\n            \n            return this.isConnected\n        } catch (error) {\n            const wasConnected = this.isConnected\n            this.isConnected = false\n            \n            if (wasConnected !== this.isConnected) {\n                this.notifyListeners({\n                    connected: this.isConnected,\n                    timestamp: new Date().toISOString(),\n                    error: error.message\n                })\n            }\n            \n            return false\n        }\n    }\n\n    // 添加连接状态监听器\n    addConnectionListener(callback) {\n        this.listeners.add(callback)\n        \n        // 立即通知当前状态\n        callback({\n            connected: this.isConnected,\n            timestamp: new Date().toISOString()\n        })\n        \n        return () => {\n            this.listeners.delete(callback)\n        }\n    }\n\n    // 通知所有监听器\n    notifyListeners(status) {\n        this.listeners.forEach(listener => {\n            try {\n                listener(status)\n            } catch (error) {\n                console.error('通知连接状态监听器失败:', error)\n            }\n        })\n    }\n\n    // 获取当前连接状态\n    getConnectionStatus() {\n        return {\n            connected: this.isConnected,\n            timestamp: new Date().toISOString()\n        }\n    }\n\n    // 手动触发连接检查\n    async forceCheck() {\n        return await this.checkConnection()\n    }\n\n    // 测试API端点\n    async testEndpoint(endpoint) {\n        try {\n            const response = await fetch(`${this.apiBaseUrl}${endpoint}`, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            \n            return {\n                success: response.ok,\n                status: response.status,\n                statusText: response.statusText\n            }\n        } catch (error) {\n            return {\n                success: false,\n                error: error.message\n            }\n        }\n    }\n\n    // 销毁服务\n    destroy() {\n        this.stopConnectionCheck()\n        this.listeners.clear()\n    }\n}\n\n// 创建单例实例\nconst backendConnectionService = new BackendConnectionService()\n\nexport default backendConnectionService\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}